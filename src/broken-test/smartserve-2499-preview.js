// 2015-10-16T13:50:43@3b4754
(function () {

var isGoodBrowser = function () {
  var ua = navigator.userAgent.toLowerCase()
  var isOldIe = (ua.indexOf('msie 6') > -1) || (ua.indexOf('msie 7') > -1)
  return !isOldIe
}

if (!isGoodBrowser()) {
  return
}


var require = {
  skipDataMain: true,
  map: {
    '*': {
      jquery: '@qubit---jquery@1.8.2'
    }
  }
};

/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.15 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.15',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i == 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue,
                           [defQueue.length, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return  getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if(args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    // QUBIT CUSTOM:
    // Load Requirejs Synchronously
    // make nextTick run without timeout

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    // req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
    //     setTimeout(fn, 4);
    // } : function (fn) { fn(); };
    req.nextTick = function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709

        // QUBIT CUSTOM: 
        // don't check for baseElement as this breaks clients using instartlogic.com
        // due to instart overriding document.getElementsByTagName
        // baseElement = document.getElementsByTagName('base')[0];
        // if (baseElement) {
        //     head = s.head = baseElement.parentNode;
        // }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation that a build has been done so that
                //only one script needs to be loaded anyway. This may need to be
                //reevaluated if other use cases become common.
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one.
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                 //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));
define('config',['require','exports','module'],function (require, exports, module) {module.exports = {
  "cookieDomain": ".i.am.wrong",
  "trackingId": "kn8",
  "experiments": [
    {
      "id": 42448,
      "iteration_id": 92435,
      "paused_at": null,
      "global_code": "",
      "activation_rules": {
        "min_page_views": 5
      },
      "profile_id": null,
      "profile_activations_enabled": true,
      "goals": [
        {
          "id": 109454,
          "key": "metrics.revenue_per_visitor",
          "type": "none",
          "op": "",
          "primary": false,
          "value": ""
        },
        {
          "id": 109455,
          "key": "metrics.revenue_per_converter",
          "type": "none",
          "op": "",
          "primary": false,
          "value": ""
        }
      ],
      "targeting_criteria": [
        {
          "id": 42448,
          "segment": [
            {
              "key": "custom_javascript",
              "type": "code",
              "value": ""
            }
          ],
          "creative_rates": [
            {
              "id": 212375,
              "rate": 0.5
            },
            {
              "id": 212376,
              "rate": 0.5
            }
          ],
          "creatives": [
            {
              "id": 212375,
              "creative_id": 212375,
              "is_control": true,
              "advanced_mode": false,
              "params": {}
            },
            {
              "id": 212376,
              "creative_id": 212376,
              "is_control": false,
              "advanced_mode": true,
              "params": {
                "execution_code": "function () {}",
                "custom_styles": ""
              }
            }
          ]
        }
      ]
    },
    {
      "id": 42449,
      "iteration_id": 92436,
      "paused_at": null,
      "global_code": "",
      "activation_rules": {},
      "profile_id": null,
      "profile_activations_enabled": true,
      "goals": [],
      "targeting_criteria": [
        {
          "id": 42449,
          "segment": [
            {
              "key": "custom_javascript",
              "type": "code",
              "value": ""
            }
          ],
          "creative_rates": [
            {
              "id": 212377,
              "rate": 0.5
            },
            {
              "id": 212378,
              "rate": 0.5
            }
          ],
          "creatives": [
            {
              "id": 212377,
              "creative_id": 212377,
              "is_control": true,
              "advanced_mode": false,
              "params": {}
            },
            {
              "id": 212378,
              "creative_id": 212378,
              "is_control": false,
              "advanced_mode": true,
              "params": {
                "execution_code": "function (){var t=function(){setTimeout(this.a,500)};t.prototype.a=function(){this.b()},t.prototype.b=function(){alert(\"yay i work\")},new t}",
                "custom_styles": ""
              }
            }
          ]
        }
      ]
    }
  ],
  "ignoreVirtualPageViews": false,
  "feedbackProfileId": 2444,
  "version": "2015-10-16T13:50:43@3b4754e",
  "profileIndex": [],
  "dependencies": [
    "@qubit/layer@^1.0.0",
    "@qubit/slider@^1.0.0",
    "@qubit/in_page@^1.0.0",
    "@qubit/rephrase@^1.0.0",
    "@qubit/textbox@^1.0.0",
    "@qubit/image@^1.0.0",
    "@qubit/close-button@^1.0.0",
    "@qubit/layer@^2.0.0",
    "@qubit/textbox@^2.3.3",
    "@qubit/block@^1.3.0",
    "@qubit/vanish@^1.0.0",
    "@qubit/mimic@^1.0.0",
    "@qubit/toggle-slider@^1.3.0",
    "@qubit/textbox@^2.4.12",
    "@qubit/modal@^0.1.0",
    "@qubit/image@^2.7.16",
    "@qubit/modal@^1.0.4",
    "@qubit-ce/qubit-recommendation@^2.1.0"
  ],
  "endpoints": {
    "deliverModules": "//d22rutvoghj3db.cloudfront.net",
    "orca": "//orca.qubitproducts.com/orca",
    "geolocation": "//orca.qubitproducts.com/ns",
    "stash": "//stash.qubitproducts.com",
    "preview": {
      "production": "smartserve.s3.amazonaws.com",
      "development": "smartserve-dev.s3.amazonaws.com"
    }
  },
  "sentryConfig": false,
  "dynamicModuleIds": {
    "poller": "@qubit/poller",
    "rememberPreview": "@qubit/remember-preview",
    "mvt": "@qubit/mvt",
    "sendUVEvent": "@qubit/send-uv-event",
    "uvMapper": "@qubit/uv-maps@^1.0.0/kn8/index"
  },
  "activationModuleIds": [],
  "flags": {
    "PROFILES": false,
    "UV_API_OFF": false,
    "JOLT": false,
    "PRONG": false,
    "PROFILE_COUNTS": false,
    "ORCA_SYNC": false,
    "SENTRY_STASH_ERRORS": false
  },
  "amd": {
    "map": {
      "*": {
        "@qubit/layer@^1.0.0": "@qubit---layer@1.0.4",
        "@qubit/slider@^1.0.0": "@qubit---slider@1.0.2",
        "@qubit/in_page@^1.0.0": "@qubit---in_page@1.0.6",
        "@qubit/rephrase@^1.0.0": "@qubit---rephrase@1.0.1",
        "@qubit/textbox@^1.0.0": "@qubit---textbox@1.0.0",
        "@qubit/image@^1.0.0": "@qubit---image@1.0.1",
        "@qubit/close-button@^1.0.0": "@qubit---close-button@1.0.0",
        "@qubit/layer@^2.0.0": "@qubit---layer@2.20.41",
        "@qubit/textbox@^2.3.3": "@qubit---textbox@2.4.12",
        "@qubit/block@^1.3.0": "@qubit---block@1.5.8",
        "@qubit/vanish@^1.0.0": "@qubit---vanish@1.0.0",
        "@qubit/mimic@^1.0.0": "@qubit---mimic@1.3.15",
        "@qubit/toggle-slider@^1.3.0": "@qubit---toggle-slider@1.3.2",
        "@qubit/textbox@^2.4.12": "@qubit---textbox@2.4.12",
        "@qubit/modal@^0.1.0": "@qubit---modal@0.1.0",
        "@qubit/image@^2.7.16": "@qubit---image@2.7.16",
        "@qubit/modal@^1.0.4": "@qubit---modal@1.0.4",
        "@qubit-ce/qubit-recommendation@^2.1.0": "@qubit-ce---qubit-recommendation@2.1.0",
        "@qubit/poller@^1.0.0": "@qubit---poller@1.2.7",
        "@qubit/remember-preview@^1.0.0": "@qubit---remember-preview@1.0.1",
        "@qubit/mvt@^1.0.0": "@qubit---mvt@1.1.1",
        "@qubit/send-uv-event@^1.0.0": "@qubit---send-uv-event@1.0.1",
        "@qubit/uv-maps@^1.0.0": "@qubit---uv-maps@1.12.0",
        "@qubit/uv-api@*": "@qubit---uv-api@2.0.1",
        "@qubit/jquery@^1.8.2": "@qubit---jquery@1.8.2",
        "@qubit/emitter@^1.0.0": "@qubit---emitter@1.0.0",
        "@qubit/underscore@^1.5.2": "@qubit---underscore@1.5.3",
        "@qubit/backbone@^1.0.0": "@qubit---backbone@1.1.2",
        "@qubit/jquery-ui@^1.10.3": "@qubit---jquery-ui@1.11.3",
        "@qubit/backbone-deep-model@^0.10.4": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/container_style_processor@^1.0.0": "@qubit---container_style_processor@1.0.0",
        "@qubit/text@^2.0.10": "@qubit---text@2.0.12",
        "@qubit/css@^0.1.5": "@qubit---css@0.1.6",
        "@qubit/inherits@^1.0.0": "@qubit---inherits@1.0.0",
        "@qubit/less@^1.7.0": "@qubit---less@1.7.0",
        "@qubit/maxz@^1.0.0": "@qubit---maxz@1.0.8",
        "@qubit/overlay@^0.0.2": "@qubit---overlay@0.0.2",
        "@qubit/jquery-simulate@^0.0.0": "@qubit---jquery-simulate@0.0.0",
        "@qubit/dropdown@^1.0.0": "@qubit---dropdown@1.0.3",
        "@qubit/selector@^1.0.0": "@qubit---selector@1.1.0",
        "@qubit/such-dom@^1.0.0": "@qubit---such-dom@1.1.3",
        "@qubit/attr@^1.0.0": "@qubit---attr@1.0.0",
        "@qubit/pill-maker@^0.1.0": "@qubit---pill-maker@0.1.2",
        "@qubit/editable@^0.0.1": "@qubit---editable@0.0.1",
        "@qubit/inspector@^0.0.1": "@qubit---inspector@0.0.1",
        "@qubit/proxify@^0.0.0": "@qubit---proxify@0.0.0",
        "@qubit/backbone-model-cursor@^1.0.0": "@qubit---backbone-model-cursor@1.1.0",
        "@qubit/biscotti@^2.0.0": "@qubit---biscotti@2.4.0",
        "@qubit/event-kit@^0.8.0": "@qubit---event-kit@0.8.0",
        "@qubit/hover@^1.0.0": "@qubit---hover@1.0.16",
        "@qubit/selector@^2.0.0": "@qubit---selector@2.2.1",
        "@qubit/deliver@^1.1.1": "@qubit---deliver@1.1.3",
        "@qubit/editable@^1.0.0": "@qubit---editable@1.0.0",
        "@qubit/inspector@^1.0.0": "@qubit---inspector@1.0.0",
        "@qubit/kii@^1.0.0": "@qubit---kii@1.3.17",
        "@qubit/kimono@^1.0.0": "@qubit---kimono@1.4.11",
        "@qubit/react@^0.11.3": "@qubit---react@0.11.3",
        "@qubit/url-smoothie@^1.0.1": "@qubit---url-smoothie@1.0.2",
        "@qubit/react@^0.11.1": "@qubit---react@0.11.3",
        "@qubit/css@^0.1.6": "@qubit---css@0.1.6",
        "@qubit/backbone@^1.1.2": "@qubit---backbone@1.1.2",
        "@qubit/kii@^1.1.3": "@qubit---kii@1.3.17",
        "@qubit/kimono@^1.0.1": "@qubit---kimono@1.4.11",
        "@qubit/kii@^1.0.4": "@qubit---kii@1.3.17",
        "@qubit/kimono@^1.1.4": "@qubit---kimono@1.4.11",
        "@qubit/backbone-deep-model@^0.10.5": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/close@^1.0.0": "@qubit---close@1.0.2",
        "@qubit/deliver@^1.1.2": "@qubit---deliver@1.1.3",
        "@qubit/jquery-ui@^1.11.3": "@qubit---jquery-ui@1.11.3",
        "@qubit/kii@^1.2.11": "@qubit---kii@1.3.17",
        "@qubit/kimono@^1.2.5": "@qubit---kimono@1.4.11",
        "@qubit/maxz@^1.0.2": "@qubit---maxz@1.0.8",
        "@qubit/overlay@^1.0.0": "@qubit---overlay@1.0.1",
        "@qubit/such-dom@^1.1.2": "@qubit---such-dom@1.1.3",
        "@qubit/velocity@^1.2.2": "@qubit---velocity@1.2.3",
        "@qubit/text@^2.0.12": "@qubit---text@2.0.12",
        "@qubit/kii@^1.1.1": "@qubit---kii@1.3.17",
        "@qubit/kimono@^1.3.10": "@qubit---kimono@1.4.11",
        "cookieman@^1.0.1": "cookieman@1.0.1",
        "cookieman@^1.0.0": "cookieman@1.0.1",
        "@qubit/underscore@^1.5.3": "@qubit---underscore@1.5.3",
        "@qubit/uv-mapper@^2.0.0": "@qubit---uv-mapper@2.1.0",
        "@qubit/each@^1.0.0": "@qubit---each@1.0.0",
        "base64int@^1.0.2": "base64int@1.1.0",
        "specificity@^0.1.4": "specificity@0.1.4",
        "font-awesome@^4.2.0": "font-awesome@4.4.0",
        "normalize.css@^3.0.2": "normalize.css@3.0.3",
        "@qubit/kii@^1.2.17": "@qubit---kii@1.3.17",
        "capitalize@^0.5.0": "capitalize@0.5.0",
        "really-unique-id@^1.0.2": "really-unique-id@1.1.0",
        "string-hash@^1.1.0": "string-hash@1.1.0",
        "@qubit/poller": "@qubit---poller@1.2.7",
        "@qubit/remember-preview": "@qubit---remember-preview@1.0.1",
        "@qubit/mvt": "@qubit---mvt@1.1.1",
        "@qubit/send-uv-event": "@qubit---send-uv-event@1.0.1",
        "@qubit/layer@1.0.4": "@qubit---layer@1.0.4",
        "@qubit/slider@1.0.2": "@qubit---slider@1.0.2",
        "@qubit/in_page@1.0.6": "@qubit---in_page@1.0.6",
        "@qubit/rephrase@1.0.1": "@qubit---rephrase@1.0.1",
        "@qubit/textbox@1.0.0": "@qubit---textbox@1.0.0",
        "@qubit/image@1.0.1": "@qubit---image@1.0.1",
        "@qubit/close-button@1.0.0": "@qubit---close-button@1.0.0",
        "@qubit/layer@2.20.41": "@qubit---layer@2.20.41",
        "@qubit/textbox@2.4.12": "@qubit---textbox@2.4.12",
        "@qubit/block@1.5.8": "@qubit---block@1.5.8",
        "@qubit/vanish@1.0.0": "@qubit---vanish@1.0.0",
        "@qubit/mimic@1.3.15": "@qubit---mimic@1.3.15",
        "@qubit/toggle-slider@1.3.2": "@qubit---toggle-slider@1.3.2",
        "@qubit/modal@0.1.0": "@qubit---modal@0.1.0",
        "@qubit/image@2.7.16": "@qubit---image@2.7.16",
        "@qubit/modal@1.0.4": "@qubit---modal@1.0.4",
        "@qubit-ce/qubit-recommendation@2.1.0": "@qubit-ce---qubit-recommendation@2.1.0",
        "@qubit/jquery@1.8.2": "@qubit---jquery@1.8.2",
        "@qubit/poller@1.2.7": "@qubit---poller@1.2.7",
        "@qubit/remember-preview@1.0.1": "@qubit---remember-preview@1.0.1",
        "@qubit/mvt@1.1.1": "@qubit---mvt@1.1.1",
        "@qubit/send-uv-event@1.0.1": "@qubit---send-uv-event@1.0.1",
        "@qubit/uv-maps@1.12.0": "@qubit---uv-maps@1.12.0",
        "@qubit/uv-api@2.0.1": "@qubit---uv-api@2.0.1",
        "@qubit/emitter@1.0.0": "@qubit---emitter@1.0.0",
        "@qubit/underscore@1.5.3": "@qubit---underscore@1.5.3",
        "@qubit/backbone@1.1.2": "@qubit---backbone@1.1.2",
        "@qubit/jquery-ui@1.11.3": "@qubit---jquery-ui@1.11.3",
        "@qubit/backbone-deep-model@0.10.5": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/container_style_processor@1.0.0": "@qubit---container_style_processor@1.0.0",
        "@qubit/text@2.0.12": "@qubit---text@2.0.12",
        "@qubit/css@0.1.6": "@qubit---css@0.1.6",
        "@qubit/inherits@1.0.0": "@qubit---inherits@1.0.0",
        "@qubit/less@1.7.0": "@qubit---less@1.7.0",
        "@qubit/maxz@1.0.8": "@qubit---maxz@1.0.8",
        "@qubit/overlay@0.0.2": "@qubit---overlay@0.0.2",
        "@qubit/jquery-simulate@0.0.0": "@qubit---jquery-simulate@0.0.0",
        "@qubit/dropdown@1.0.3": "@qubit---dropdown@1.0.3",
        "@qubit/selector@1.1.0": "@qubit---selector@1.1.0",
        "@qubit/such-dom@1.1.3": "@qubit---such-dom@1.1.3",
        "@qubit/attr@1.0.0": "@qubit---attr@1.0.0",
        "@qubit/pill-maker@0.1.2": "@qubit---pill-maker@0.1.2",
        "@qubit/editable@0.0.1": "@qubit---editable@0.0.1",
        "@qubit/inspector@0.0.1": "@qubit---inspector@0.0.1",
        "@qubit/proxify@0.0.0": "@qubit---proxify@0.0.0",
        "@qubit/backbone-model-cursor@1.1.0": "@qubit---backbone-model-cursor@1.1.0",
        "@qubit/biscotti@2.4.0": "@qubit---biscotti@2.4.0",
        "@qubit/event-kit@0.8.0": "@qubit---event-kit@0.8.0",
        "@qubit/hover@1.0.16": "@qubit---hover@1.0.16",
        "@qubit/selector@2.2.1": "@qubit---selector@2.2.1",
        "@qubit/deliver@1.1.3": "@qubit---deliver@1.1.3",
        "@qubit/editable@1.0.0": "@qubit---editable@1.0.0",
        "@qubit/inspector@1.0.0": "@qubit---inspector@1.0.0",
        "@qubit/kii@1.3.17": "@qubit---kii@1.3.17",
        "@qubit/kimono@1.4.11": "@qubit---kimono@1.4.11",
        "@qubit/react@0.11.3": "@qubit---react@0.11.3",
        "@qubit/url-smoothie@1.0.2": "@qubit---url-smoothie@1.0.2",
        "@qubit/close@1.0.2": "@qubit---close@1.0.2",
        "@qubit/overlay@1.0.1": "@qubit---overlay@1.0.1",
        "@qubit/velocity@1.2.3": "@qubit---velocity@1.2.3",
        "cookieman@1.0.1": "cookieman@1.0.1",
        "@qubit/uv-mapper@2.1.0": "@qubit---uv-mapper@2.1.0",
        "underscore@1.5.2": "underscore@1.5.2",
        "@qubit/each@1.0.0": "@qubit---each@1.0.0",
        "base64int@1.1.0": "base64int@1.1.0",
        "specificity@0.1.4": "specificity@0.1.4",
        "font-awesome@4.4.0": "font-awesome@4.4.0",
        "normalize.css@3.0.3": "normalize.css@3.0.3",
        "capitalize@0.5.0": "capitalize@0.5.0",
        "really-unique-id@1.1.0": "really-unique-id@1.1.0",
        "string-hash@1.1.0": "string-hash@1.1.0",
        "cookieman": "cookieman",
        "match-condition": "match-condition",
        "base64int": "base64int"
      },
      "@qubit---layer@1.0.4": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/emitter": "@qubit---emitter@1.0.0",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/backbone-deep-model": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/container_style_processor": "@qubit---container_style_processor@1.0.0",
        "text": "@qubit---text@2.0.12",
        "css": "@qubit---css@0.1.6",
        "@qubit/inherits": "@qubit---inherits@1.0.0",
        "@qubit/less": "@qubit---less@1.7.0"
      },
      "@qubit---slider@1.0.2": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/emitter": "@qubit---emitter@1.0.0",
        "@qubit/css": "@qubit---css@0.1.6",
        "@qubit/maxz": "@qubit---maxz@1.0.8",
        "@qubit/overlay": "@qubit---overlay@0.0.2",
        "@qubit/backbone-deep-model": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/jquery-simulate": "@qubit---jquery-simulate@0.0.0"
      },
      "@qubit---in_page@1.0.6": {
        "@qubit/backbone-deep-model": "@qubit---backbone-deep-model@0.10.5",
        "css": "@qubit---css@0.1.6",
        "@qubit/dropdown": "@qubit---dropdown@1.0.3",
        "@qubit/emitter": "@qubit---emitter@1.0.0",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-simulate": "@qubit---jquery-simulate@0.0.0",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/maxz": "@qubit---maxz@1.0.8",
        "@qubit/selector": "@qubit---selector@1.1.0",
        "@qubit/such-dom": "@qubit---such-dom@1.1.3"
      },
      "@qubit---rephrase@1.0.1": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "@qubit/layer": "@qubit---layer@1.0.4",
        "css": "@qubit---css@0.1.6",
        "text": "@qubit---text@2.0.12",
        "@qubit/in_page": "@qubit---in_page@1.0.6",
        "@qubit/selector": "@qubit---selector@1.1.0",
        "@qubit/emitter": "@qubit---emitter@1.0.0",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/backbone-deep-model": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/jquery-simulate": "@qubit---jquery-simulate@0.0.0",
        "@qubit/attr": "@qubit---attr@1.0.0",
        "@qubit/textbox": "@qubit---textbox@1.0.0",
        "@qubit/pill-maker": "@qubit---pill-maker@0.1.2",
        "@qubit/editable": "@qubit---editable@0.0.1",
        "@qubit/inspector": "@qubit---inspector@0.0.1",
        "@qubit/proxify": "@qubit---proxify@0.0.0"
      },
      "@qubit---textbox@1.0.0": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "@qubit/editable": "@qubit---editable@0.0.1",
        "@qubit/inspector": "@qubit---inspector@0.0.1",
        "@qubit/pill-maker": "@qubit---pill-maker@0.1.2",
        "@qubit/attr": "@qubit---attr@1.0.0"
      },
      "@qubit---close-button@1.0.0": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/inherits": "@qubit---inherits@1.0.0"
      },
      "@qubit---layer@2.20.41": {
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "@qubit/backbone-deep-model": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/backbone-model-cursor": "@qubit---backbone-model-cursor@1.1.0",
        "@qubit/biscotti": "@qubit---biscotti@2.4.0",
        "@qubit/container_style_processor": "@qubit---container_style_processor@1.0.0",
        "css": "@qubit---css@0.1.6",
        "@qubit/emitter": "@qubit---emitter@1.0.0",
        "@qubit/event-kit": "@qubit---event-kit@0.8.0",
        "@qubit/hover": "@qubit---hover@1.0.16",
        "@qubit/inherits": "@qubit---inherits@1.0.0",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/less": "@qubit---less@1.7.0",
        "@qubit/maxz": "@qubit---maxz@1.0.8",
        "@qubit/poller": "@qubit---poller@1.2.7",
        "@qubit/selector": "@qubit---selector@2.2.1",
        "@qubit/such-dom": "@qubit---such-dom@1.1.3",
        "text": "@qubit---text@2.0.12",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---textbox@2.4.12": {
        "@qubit/attr": "@qubit---attr@1.0.0",
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "css": "@qubit---css@0.1.6",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/editable": "@qubit---editable@1.0.0",
        "@qubit/inspector": "@qubit---inspector@1.0.0",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/kimono": "@qubit---kimono@1.4.11",
        "@qubit/pill-maker": "@qubit---pill-maker@0.1.2",
        "@qubit/react": "@qubit---react@0.11.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/url-smoothie": "@qubit---url-smoothie@1.0.2"
      },
      "@qubit---block@1.5.8": {
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "css": "@qubit---css@0.1.6",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/kimono": "@qubit---kimono@1.4.11",
        "@qubit/react": "@qubit---react@0.11.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---vanish@1.0.0": {
        "@qubit/jquery": "@qubit---jquery@1.8.2"
      },
      "@qubit---mimic@1.3.15": {
        "css": "@qubit---css@0.1.6",
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/kimono": "@qubit---kimono@1.4.11",
        "@qubit/react": "@qubit---react@0.11.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---toggle-slider@1.3.2": {
        "@qubit/css": "@qubit---css@0.1.6",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/kimono": "@qubit---kimono@1.4.11",
        "@qubit/react": "@qubit---react@0.11.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---modal@0.1.0": {
        "@qubit/backbone-deep-model": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/close": "@qubit---close@1.0.2",
        "css": "@qubit---css@0.1.6",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/kimono": "@qubit---kimono@1.4.11",
        "@qubit/maxz": "@qubit---maxz@1.0.8",
        "@qubit/overlay": "@qubit---overlay@1.0.1",
        "@qubit/react": "@qubit---react@0.11.3",
        "@qubit/such-dom": "@qubit---such-dom@1.1.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/velocity": "@qubit---velocity@1.2.3"
      },
      "@qubit---image@2.7.16": {
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "css": "@qubit---css@0.1.6",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/kimono": "@qubit---kimono@1.4.11",
        "@qubit/react": "@qubit---react@0.11.3",
        "text": "@qubit---text@2.0.12",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/url-smoothie": "@qubit---url-smoothie@1.0.2"
      },
      "@qubit---modal@1.0.4": {
        "@qubit/backbone-deep-model": "@qubit---backbone-deep-model@0.10.5",
        "@qubit/close": "@qubit---close@1.0.2",
        "css": "@qubit---css@0.1.6",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/kimono": "@qubit---kimono@1.4.11",
        "@qubit/maxz": "@qubit---maxz@1.0.8",
        "@qubit/overlay": "@qubit---overlay@1.0.1",
        "@qubit/react": "@qubit---react@0.11.3",
        "@qubit/such-dom": "@qubit---such-dom@1.1.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/velocity": "@qubit---velocity@1.2.3"
      },
      "@qubit-ce---qubit-recommendation@2.1.0": {
        "@qubit/attr": "@qubit---attr@1.0.0",
        "css": "@qubit---css@0.1.6",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/kimono": "@qubit---kimono@1.4.11",
        "@qubit/react": "@qubit---react@0.11.3",
        "text": "@qubit---text@2.0.12",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "cookieman": "cookieman@1.0.1"
      },
      "@qubit---poller@1.2.7": {
        "@qubit/attr": "@qubit---attr@1.0.0",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---mvt@1.1.1": {
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "cookieman": "cookieman@1.0.1"
      },
      "@qubit---send-uv-event@1.0.1": {
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---uv-maps@1.12.0": {
        "@qubit/uv-mapper": "@qubit---uv-mapper@2.1.0",
        "underscore": "underscore@1.5.2"
      },
      "@qubit---emitter@1.0.0": {
        "@qubit/each": "@qubit---each@1.0.0"
      },
      "@qubit---underscore@1.5.3": {
        "underscore": "underscore@1.5.2"
      },
      "@qubit---backbone@1.1.2": {
        "jquery": "@qubit---jquery@1.8.2",
        "underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---jquery-ui@1.11.3": {
        "jquery": "@qubit---jquery@1.8.2"
      },
      "@qubit---backbone-deep-model@0.10.5": {
        "@qubit/backbone": "@qubit---backbone@1.1.2",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---container_style_processor@1.0.0": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---maxz@1.0.8": {
        "@qubit/jquery": "@qubit---jquery@1.8.2"
      },
      "@qubit---overlay@0.0.2": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/maxz": "@qubit---maxz@1.0.8"
      },
      "@qubit---jquery-simulate@0.0.0": {
        "@qubit/jquery": "@qubit---jquery@1.8.2"
      },
      "@qubit---dropdown@1.0.3": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/emitter": "@qubit---emitter@1.0.0",
        "css": "@qubit---css@0.1.6"
      },
      "@qubit---selector@1.1.0": {
        "@qubit/jquery": "@qubit---jquery@1.8.2"
      },
      "@qubit---such-dom@1.1.3": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---attr@1.0.0": {
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---pill-maker@0.1.2": {
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/emitter": "@qubit---emitter@1.0.0",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "css": "@qubit---css@0.1.6"
      },
      "@qubit---inspector@0.0.1": {
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "@qubit/backbone": "@qubit---backbone@1.1.2"
      },
      "@qubit---biscotti@2.4.0": {
        "base64int": "base64int@1.1.0",
        "cookieman": "cookieman@1.0.1",
        "underscore": "underscore@1.5.2"
      },
      "@qubit---hover@1.0.16": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/maxz": "@qubit---maxz@1.0.8",
        "@qubit/such-dom": "@qubit---such-dom@1.1.3"
      },
      "@qubit---selector@2.2.1": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "specificity": "specificity@0.1.4"
      },
      "@qubit---deliver@1.1.3": {
        "@qubit/emitter": "@qubit---emitter@1.0.0",
        "@qubit/react": "@qubit---react@0.11.3"
      },
      "@qubit---inspector@1.0.0": {
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---kii@1.3.17": {
        "css": "@qubit---css@0.1.6",
        "@qubit/deliver": "@qubit---deliver@1.1.3",
        "@qubit/react": "@qubit---react@0.11.3",
        "text": "@qubit---text@2.0.12",
        "@qubit/underscore": "@qubit---underscore@1.5.3",
        "font-awesome": "font-awesome@4.4.0",
        "normalize.css": "normalize.css@3.0.3"
      },
      "@qubit---kimono@1.4.11": {
        "@qubit/react": "@qubit---react@0.11.3",
        "css": "@qubit---css@0.1.6",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "text": "@qubit---text@2.0.12",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---close@1.0.2": {
        "css": "@qubit---css@0.1.6",
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/jquery-ui": "@qubit---jquery-ui@1.11.3",
        "@qubit/kii": "@qubit---kii@1.3.17",
        "@qubit/react": "@qubit---react@0.11.3",
        "@qubit/underscore": "@qubit---underscore@1.5.3"
      },
      "@qubit---overlay@1.0.1": {
        "@qubit/jquery": "@qubit---jquery@1.8.2",
        "@qubit/maxz": "@qubit---maxz@1.0.8"
      },
      "@qubit---uv-mapper@2.1.0": {
        "capitalize": "capitalize@0.5.0",
        "really-unique-id": "really-unique-id@1.1.0",
        "underscore": "underscore@1.5.2"
      },
      "really-unique-id@1.1.0": {
        "string-hash": "string-hash@1.1.0"
      }
    },
    "packages": [
      {
        "name": "@qubit---layer@1.0.4",
        "main": "src/layer",
        "location": "@qubit/layer@1.0.4"
      },
      {
        "name": "@qubit---slider@1.0.2",
        "main": "src/slider",
        "location": "@qubit/slider@1.0.2"
      },
      {
        "name": "@qubit---in_page@1.0.6",
        "main": "src/in_page",
        "location": "@qubit/in_page@1.0.6"
      },
      {
        "name": "@qubit---rephrase@1.0.1",
        "main": "src/index",
        "location": "@qubit/rephrase@1.0.1"
      },
      {
        "name": "@qubit---textbox@1.0.0",
        "main": "textbox",
        "location": "@qubit/textbox@1.0.0"
      },
      {
        "name": "@qubit---image@1.0.1",
        "main": "image",
        "location": "@qubit/image@1.0.1"
      },
      {
        "name": "@qubit---close-button@1.0.0",
        "main": "close-button",
        "location": "@qubit/close-button@1.0.0"
      },
      {
        "name": "@qubit---layer@2.20.41",
        "main": "lib/layer",
        "location": "@qubit/layer@2.20.41"
      },
      {
        "name": "@qubit---textbox@2.4.12",
        "main": "textbox",
        "location": "@qubit/textbox@2.4.12"
      },
      {
        "name": "@qubit---block@1.5.8",
        "main": "block",
        "location": "@qubit/block@1.5.8"
      },
      {
        "name": "@qubit---vanish@1.0.0",
        "main": "index",
        "location": "@qubit/vanish@1.0.0"
      },
      {
        "name": "@qubit---mimic@1.3.15",
        "main": "mimic",
        "location": "@qubit/mimic@1.3.15"
      },
      {
        "name": "@qubit---toggle-slider@1.3.2",
        "main": "index.js",
        "location": "@qubit/toggle-slider@1.3.2"
      },
      {
        "name": "@qubit---modal@0.1.0",
        "main": "modal",
        "location": "@qubit/modal@0.1.0"
      },
      {
        "name": "@qubit---image@2.7.16",
        "main": "image",
        "location": "@qubit/image@2.7.16"
      },
      {
        "name": "@qubit---modal@1.0.4",
        "main": "modal",
        "location": "@qubit/modal@1.0.4"
      },
      {
        "name": "@qubit-ce---qubit-recommendation@2.1.0",
        "main": "index.js",
        "location": "@qubit-ce/qubit-recommendation@2.1.0"
      },
      {
        "name": "@qubit---jquery@1.8.2",
        "main": "jquery",
        "location": "@qubit/jquery@1.8.2"
      },
      {
        "name": "@qubit---poller@1.2.7",
        "main": "poller",
        "location": "@qubit/poller@1.2.7"
      },
      {
        "name": "@qubit---remember-preview@1.0.1",
        "main": "index.js",
        "location": "@qubit/remember-preview@1.0.1"
      },
      {
        "name": "@qubit---mvt@1.1.1",
        "main": "index",
        "location": "@qubit/mvt@1.1.1"
      },
      {
        "name": "@qubit---send-uv-event@1.0.1",
        "main": "index.js",
        "location": "@qubit/send-uv-event@1.0.1"
      },
      {
        "name": "@qubit---uv-maps@1.12.0",
        "main": "index",
        "location": "@qubit/uv-maps@1.12.0"
      },
      {
        "name": "@qubit---uv-api@2.0.1",
        "main": "uv-api.js",
        "location": "@qubit/uv-api@2.0.1"
      },
      {
        "name": "@qubit---emitter@1.0.0",
        "main": "emitter",
        "location": "@qubit/emitter@1.0.0"
      },
      {
        "name": "@qubit---underscore@1.5.3",
        "main": "underscore",
        "location": "@qubit/underscore@1.5.3"
      },
      {
        "name": "@qubit---backbone@1.1.2",
        "main": "backbone",
        "location": "@qubit/backbone@1.1.2"
      },
      {
        "name": "@qubit---jquery-ui@1.11.3",
        "main": "index",
        "location": "@qubit/jquery-ui@1.11.3"
      },
      {
        "name": "@qubit---backbone-deep-model@0.10.5",
        "main": "main",
        "location": "@qubit/backbone-deep-model@0.10.5"
      },
      {
        "name": "@qubit---container_style_processor@1.0.0",
        "main": "src/container_style_processor",
        "location": "@qubit/container_style_processor@1.0.0"
      },
      {
        "name": "@qubit---text@2.0.12",
        "main": "text",
        "location": "@qubit/text@2.0.12"
      },
      {
        "name": "@qubit---css@0.1.6",
        "main": "css",
        "location": "@qubit/css@0.1.6"
      },
      {
        "name": "@qubit---inherits@1.0.0",
        "main": "inherits",
        "location": "@qubit/inherits@1.0.0"
      },
      {
        "name": "@qubit---less@1.7.0",
        "main": "less",
        "location": "@qubit/less@1.7.0"
      },
      {
        "name": "@qubit---maxz@1.0.8",
        "main": "maxz",
        "location": "@qubit/maxz@1.0.8"
      },
      {
        "name": "@qubit---overlay@0.0.2",
        "main": "src/overlay",
        "location": "@qubit/overlay@0.0.2"
      },
      {
        "name": "@qubit---jquery-simulate@0.0.0",
        "main": "jquery-simulate",
        "location": "@qubit/jquery-simulate@0.0.0"
      },
      {
        "name": "@qubit---dropdown@1.0.3",
        "main": "src/dropdown",
        "location": "@qubit/dropdown@1.0.3"
      },
      {
        "name": "@qubit---selector@1.1.0",
        "main": "selector",
        "location": "@qubit/selector@1.1.0"
      },
      {
        "name": "@qubit---such-dom@1.1.3",
        "main": "such-dom",
        "location": "@qubit/such-dom@1.1.3"
      },
      {
        "name": "@qubit---attr@1.0.0",
        "main": "attr",
        "location": "@qubit/attr@1.0.0"
      },
      {
        "name": "@qubit---pill-maker@0.1.2",
        "main": "pill-maker",
        "location": "@qubit/pill-maker@0.1.2"
      },
      {
        "name": "@qubit---editable@0.0.1",
        "main": "editable.js",
        "location": "@qubit/editable@0.0.1"
      },
      {
        "name": "@qubit---inspector@0.0.1",
        "main": "inspector",
        "location": "@qubit/inspector@0.0.1"
      },
      {
        "name": "@qubit---proxify@0.0.0",
        "main": "./proxify.js",
        "location": "@qubit/proxify@0.0.0"
      },
      {
        "name": "@qubit---backbone-model-cursor@1.1.0",
        "main": "cursor.js",
        "location": "@qubit/backbone-model-cursor@1.1.0"
      },
      {
        "name": "@qubit---biscotti@2.4.0",
        "main": "lib/biscotti.js",
        "location": "@qubit/biscotti@2.4.0"
      },
      {
        "name": "@qubit---event-kit@0.8.0",
        "main": "./lib/event-kit",
        "location": "@qubit/event-kit@0.8.0"
      },
      {
        "name": "@qubit---hover@1.0.16",
        "main": "hover.js",
        "location": "@qubit/hover@1.0.16"
      },
      {
        "name": "@qubit---selector@2.2.1",
        "main": "selector",
        "location": "@qubit/selector@2.2.1"
      },
      {
        "name": "@qubit---deliver@1.1.3",
        "main": "deliver",
        "location": "@qubit/deliver@1.1.3"
      },
      {
        "name": "@qubit---editable@1.0.0",
        "main": "editable.js",
        "location": "@qubit/editable@1.0.0"
      },
      {
        "name": "@qubit---inspector@1.0.0",
        "main": "inspector",
        "location": "@qubit/inspector@1.0.0"
      },
      {
        "name": "@qubit---kii@1.3.17",
        "main": "base",
        "location": "@qubit/kii@1.3.17"
      },
      {
        "name": "@qubit---kimono@1.4.11",
        "main": "index",
        "location": "@qubit/kimono@1.4.11"
      },
      {
        "name": "@qubit---react@0.11.3",
        "main": "react",
        "location": "@qubit/react@0.11.3"
      },
      {
        "name": "@qubit---url-smoothie@1.0.2",
        "main": "src/index.js",
        "location": "@qubit/url-smoothie@1.0.2"
      },
      {
        "name": "@qubit---close@1.0.2",
        "main": "index",
        "location": "@qubit/close@1.0.2"
      },
      {
        "name": "@qubit---overlay@1.0.1",
        "main": "src/overlay",
        "location": "@qubit/overlay@1.0.1"
      },
      {
        "name": "@qubit---velocity@1.2.3",
        "main": "velocity",
        "location": "@qubit/velocity@1.2.3"
      },
      {
        "name": "cookieman@1.0.1",
        "main": "lib/cookieman",
        "location": "cookieman@1.0.1"
      },
      {
        "name": "@qubit---uv-mapper@2.1.0",
        "main": "lib/mapper.js",
        "location": "@qubit/uv-mapper@2.1.0"
      },
      {
        "name": "underscore@1.5.2",
        "main": "underscore.js",
        "location": "underscore@1.5.2"
      },
      {
        "name": "@qubit---each@1.0.0",
        "main": "each",
        "location": "@qubit/each@1.0.0"
      },
      {
        "name": "base64int@1.1.0",
        "main": "index.js",
        "location": "base64int@1.1.0"
      },
      {
        "name": "specificity@0.1.4",
        "main": "specificity",
        "location": "specificity@0.1.4"
      },
      {
        "name": "font-awesome@4.4.0",
        "main": "index",
        "location": "font-awesome@4.4.0"
      },
      {
        "name": "normalize.css@3.0.3",
        "main": "normalize.css",
        "location": "normalize.css@3.0.3"
      },
      {
        "name": "capitalize@0.5.0",
        "main": "index.js",
        "location": "capitalize@0.5.0"
      },
      {
        "name": "really-unique-id@1.1.0",
        "main": "really-unique-id.js",
        "location": "really-unique-id@1.1.0"
      },
      {
        "name": "string-hash@1.1.0",
        "main": "./index",
        "location": "string-hash@1.1.0"
      },
      {
        "name": "cookieman",
        "main": "cookieman",
        "location": "cookieman/lib"
      },
      {
        "name": "match-condition",
        "main": "index", 
        "location": "match-condition"
      },
      {
        "name": "base64int",
        "main": "index",
        "location": "base64int"
      }
    ]
  }
};
});

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash legacy exports="amd" include="keys, each, reduce, bind, map, all, any, pluck, flatten, isBoolean, isString, isArray, bindAll, extend, some, merge, find, filter"`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used to pool arrays and objects used internally */
  var arrayPool = [];

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to fix the JScript [[DontEnum]] bug */
  var shadowedProps = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      errorClass = '[object Error]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used as the data object for `iteratorTemplate` */
  var iteratorData = {
    'args': '',
    'array': null,
    'bottom': '',
    'firstArg': '',
    'init': '',
    'keys': null,
    'loop': '',
    'shadowedProps': null,
    'support': null,
    'top': '',
    'useHas': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Checks if `value` is a DOM node in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
   */
  function isNode(value) {
    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
    // methods that are `typeof` "string" and still can coerce nodes to strings
    return typeof value.toString != 'function' && typeof (value + '') == 'string';
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Used for `Array` method references.
   *
   * Normally `Array.prototype` would suffice, however, using an array literal
   * avoids issues in Narwhal.
   */
  var arrayRef = [];

  /** Used for native method references */
  var errorProto = Error.prototype,
      objectProto = Object.prototype,
      stringProto = String.prototype;

  /** Used to resolve the internal [[Class]] of values */
  var toString = objectProto.toString;

  /** Native method shortcuts */
  var hasOwnProperty = objectProto.hasOwnProperty,
      push = arrayRef.push,
      propertyIsEnumerable = objectProto.propertyIsEnumerable;

  /** Used to avoid iterating non-enumerable properties in IE < 9 */
  var nonEnumProps = {};
  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
  nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
  nonEnumProps[objectClass] = { 'constructor': true };

  (function() {
    var length = shadowedProps.length;
    while (length--) {
      var key = shadowedProps[length];
      for (var className in nonEnumProps) {
        if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
          nonEnumProps[className][key] = false;
        }
      }
    }
  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps the given value to enable intuitive
   * method chaining.
   *
   * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
   * and `unshift`
   *
   * Chaining is supported in custom builds as long as the `value` method is
   * implicitly or explicitly included in the build.
   *
   * The chainable wrapper functions are:
   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
   * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
   * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
   * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
   * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
   * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
   * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
   * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
   * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
   * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
   * and `zip`
   *
   * The non-chainable wrapper functions are:
   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
   * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
   * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
   * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
   * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
   * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
   * `template`, `unescape`, `uniqueId`, and `value`
   *
   * The wrapper functions `first` and `last` return wrapped values when `n` is
   * provided, otherwise they return unwrapped values.
   *
   * Explicit chaining can be enabled by using the `_.chain` method.
   *
   * @name _
   * @constructor
   * @category Chaining
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns a `lodash` instance.
   * @example
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // returns an unwrapped value
   * wrapped.reduce(function(sum, num) {
   *   return sum + num;
   * });
   * // => 6
   *
   * // returns a wrapped value
   * var squares = wrapped.map(function(num) {
   *   return num * num;
   * });
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash() {
    // no operation performed
  }

  /**
   * An object used to flag environments features.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  var support = lodash.support = {};

  (function() {
    var ctor = function() { this.x = 1; },
        object = { '0': 1, 'length': 1 },
        props = [];

    ctor.prototype = { 'valueOf': 1, 'y': 1 };
    for (var key in new ctor) { props.push(key); }
    for (key in arguments) { }

    /**
     * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsClass = false;

    /**
     * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);

    /**
     * Detect if `name` or `message` properties of `Error.prototype` are
     * enumerable by default. (IE < 9, Safari < 5.1)
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');

    /**
     * Detect if `prototype` properties are enumerable by default.
     *
     * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
     * (if the prototype or a property on the prototype has been set)
     * incorrectly sets a function's `prototype` property [[Enumerable]]
     * value to `true`.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');

    /**
     * Detect if `arguments` object indexes are non-enumerable
     * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumArgs = key != 0;

    /**
     * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
     *
     * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
     * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumShadows = !/valueOf/.test(props);

    /**
     * Detect if own properties are iterated after inherited properties (all but IE < 9).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.ownLast = props[0] != 'x';

    /**
     * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
     *
     * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
     * and `splice()` functions that fail to remove the last element, `value[0]`,
     * of array-like objects even though the `length` property is set to `0`.
     * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
     * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);

    /**
     * Detect lack of support for accessing string characters by index.
     *
     * IE < 8 can't access characters by index and IE 8 can only access
     * characters by index on string literals.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';

    /**
     * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
     * and that the JS engine errors when attempting to coerce an object to
     * a string without a `toString` function.
     *
     * @memberOf _.support
     * @type boolean
     */
    try {
      support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
    } catch(e) {
      support.nodeClass = true;
    }
  }(1));

  /*--------------------------------------------------------------------------*/

  /**
   * The template used to create iterator functions.
   *
   * @private
   * @param {Object} data The data object used to populate the text.
   * @returns {string} Returns the interpolated text.
   */
  var iteratorTemplate = function(obj) {

    var __p = 'var index, iterable = ' +
    (obj.firstArg) +
    ', result = ' +
    (obj.init) +
    ';\nif (!iterable) return result;\n' +
    (obj.top) +
    ';';
     if (obj.array) {
    __p += '\nvar length = iterable.length; index = -1;\nif (' +
    (obj.array) +
    ') {  ';
     if (support.unindexedChars) {
    __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
     }
    __p += '\n  while (++index < length) {\n    ' +
    (obj.loop) +
    ';\n  }\n}\nelse {  ';
     } else if (support.nonEnumArgs) {
    __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' +
    (obj.loop) +
    ';\n    }\n  } else {  ';
     }

     if (support.enumPrototypes) {
    __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
     }

     if (support.enumErrorProps) {
    __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
     }

        var conditions = [];    if (support.enumPrototypes) { conditions.push('!(skipProto && index == "prototype")'); }    if (support.enumErrorProps)  { conditions.push('!(skipErrorProps && (index == "message" || index == "name"))'); }
    __p += '\n  for (index in iterable) {\n';
        if (obj.useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }    if (conditions.length) {
    __p += '    if (' +
    (conditions.join(' && ')) +
    ') {\n  ';
     }
    __p +=
    (obj.loop) +
    ';    ';
     if (conditions.length) {
    __p += '\n    }';
     }
    __p += '\n  }    ';
     if (support.nonEnumShadows) {
    __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
     for (k = 0; k < 7; k++) {
    __p += '\n    index = \'' +
    (obj.shadowedProps[k]) +
    '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
            if (!obj.useHas) {
    __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
     }
    __p += ') {\n      ' +
    (obj.loop) +
    ';\n    }      ';
     }
    __p += '\n  }    ';
     }

     if (obj.array || support.nonEnumArgs) {
    __p += '\n}';
     }
    __p +=
    (obj.bottom) +
    ';\nreturn result';

    return __p
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.bind` that creates the bound function and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new bound function.
   */
  function baseBind(bindData) {
    var func = bindData[0],
        partialArgs = bindData[2],
        thisArg = bindData[4];

    function bound() {
      // `Function#bind` spec
      // http://es5.github.io/#x15.3.4.5
      if (partialArgs) {
        // avoid `arguments` object deoptimizations by using `slice` instead
        // of `Array.prototype.slice.call` and not assigning `arguments` to a
        // variable as a ternary expression
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      // mimic the constructor's `return` behavior
      // http://es5.github.io/#x13.2.2
      if (this instanceof bound) {
        // ensure `new bound` is an instance of `func`
        var thisBinding = baseCreate(func.prototype),
            result = func.apply(thisBinding, args || arguments);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisArg, args || arguments);
    }
    return bound;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function Object() {}
    return function(prototype) {
      if (isObject(prototype)) {
        Object.prototype = prototype;
        var result = new Object;
        Object.prototype = null;
      }
      return result || root.Object();
    };
  }());

  /**
   * The base implementation of `_.createCallback` without support for creating
   * "_.pluck" or "_.where" style callbacks.
   *
   * @private
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   */
  function baseCreateCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    // exit early for no `thisArg` or already bound by `Function#bind`
    if (typeof thisArg == 'undefined' || !('prototype' in func)) {
      return func;
    }
    switch (argCount) {
      case 1: return function(value) {
        return func.call(thisArg, value);
      };
      case 2: return function(a, b) {
        return func.call(thisArg, a, b);
      };
      case 3: return function(value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(thisArg, accumulator, value, index, collection);
      };
    }
    return bind(func, thisArg);
  }

  /**
   * The base implementation of `createWrapper` that creates the wrapper and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new function.
   */
  function baseCreateWrapper(bindData) {
    var func = bindData[0],
        bitmask = bindData[1],
        partialArgs = bindData[2],
        partialRightArgs = bindData[3],
        thisArg = bindData[4],
        arity = bindData[5];

    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        key = func;

    function bound() {
      var thisBinding = isBind ? thisArg : this;
      if (partialArgs) {
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      if (partialRightArgs || isCurry) {
        args || (args = slice(arguments));
        if (partialRightArgs) {
          push.apply(args, partialRightArgs);
        }
        if (isCurry && args.length < arity) {
          bitmask |= 16 & ~32;
          return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
        }
      }
      args || (args = arguments);
      if (isBindKey) {
        func = thisBinding[key];
      }
      if (this instanceof bound) {
        thisBinding = baseCreate(func.prototype);
        var result = func.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisBinding, args);
    }
    return bound;
  }

  /**
   * The base implementation of `_.flatten` without support for callback
   * shorthands or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
   * @param {number} [fromIndex=0] The index to start from.
   * @returns {Array} Returns a new flattened array.
   */
  function baseFlatten(array, isShallow, isStrict, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (value && typeof value == 'object' && typeof value.length == 'number'
          && (isArray(value) || isArguments(value))) {
        // recursively flatten arrays (susceptible to call stack limits)
        if (!isShallow) {
          value = baseFlatten(value, isShallow, isStrict);
        }
        var valIndex = -1,
            valLength = value.length,
            resIndex = result.length;

        result.length += valLength;
        while (++valIndex < valLength) {
          result[resIndex++] = value[valIndex];
        }
      } else if (!isStrict) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.isEqual`, without support for `thisArg` binding,
   * that allows partial "_.where" style comparisons.
   *
   * @private
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
   * @param {Array} [stackA=[]] Tracks traversed `a` objects.
   * @param {Array} [stackB=[]] Tracks traversed `b` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
    // used to indicate that when comparing objects, `a` has at least the properties of `b`
    if (callback) {
      var result = callback(a, b);
      if (typeof result != 'undefined') {
        return !!result;
      }
    }
    // exit early for identical values
    if (a === b) {
      // treat `+0` vs. `-0` as not equal
      return a !== 0 || (1 / a == 1 / b);
    }
    var type = typeof a,
        otherType = typeof b;

    // exit early for unlike primitive values
    if (a === a &&
        !(a && objectTypes[type]) &&
        !(b && objectTypes[otherType])) {
      return false;
    }
    // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
    // http://es5.github.io/#x15.3.4.4
    if (a == null || b == null) {
      return a === b;
    }
    // compare [[Class]] names
    var className = toString.call(a),
        otherClass = toString.call(b);

    if (className == argsClass) {
      className = objectClass;
    }
    if (otherClass == argsClass) {
      otherClass = objectClass;
    }
    if (className != otherClass) {
      return false;
    }
    switch (className) {
      case boolClass:
      case dateClass:
        // coerce dates and booleans to numbers, dates to milliseconds and booleans
        // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
        return +a == +b;

      case numberClass:
        // treat `NaN` vs. `NaN` as equal
        return (a != +a)
          ? b != +b
          // but treat `+0` vs. `-0` as not equal
          : (a == 0 ? (1 / a == 1 / b) : a == +b);

      case regexpClass:
      case stringClass:
        // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
        // treat string primitives and their corresponding object instances as equal
        return a == String(b);
    }
    var isArr = className == arrayClass;
    if (!isArr) {
      // unwrap any `lodash` wrapped values
      var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
          bWrapped = hasOwnProperty.call(b, '__wrapped__');

      if (aWrapped || bWrapped) {
        return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
      }
      // exit for functions and DOM nodes
      if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
        return false;
      }
      // in older versions of Opera, `arguments` objects have `Array` constructors
      var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
          ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;

      // non `Object` object instances with different constructors are not equal
      if (ctorA != ctorB &&
            !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
            ('constructor' in a && 'constructor' in b)
          ) {
        return false;
      }
    }
    // assume cyclic structures are equal
    // the algorithm for detecting cyclic structures is adapted from ES 5.1
    // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
    var initedStack = !stackA;
    stackA || (stackA = getArray());
    stackB || (stackB = getArray());

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == a) {
        return stackB[length] == b;
      }
    }
    var size = 0;
    result = true;

    // add `a` and `b` to the stack of traversed objects
    stackA.push(a);
    stackB.push(b);

    // recursively compare objects and arrays (susceptible to call stack limits)
    if (isArr) {
      // compare lengths to determine if a deep comparison is necessary
      length = a.length;
      size = b.length;
      result = size == length;

      if (result || isWhere) {
        // deep compare the contents, ignoring non-numeric properties
        while (size--) {
          var index = length,
              value = b[size];

          if (isWhere) {
            while (index--) {
              if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                break;
              }
            }
          } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
            break;
          }
        }
      }
    }
    else {
      // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
      // which, in this case, is more costly
      forIn(b, function(value, key, b) {
        if (hasOwnProperty.call(b, key)) {
          // count the number of properties.
          size++;
          // deep compare each property value.
          return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
        }
      });

      if (result && !isWhere) {
        // ensure both objects have the same number of properties
        forIn(a, function(value, key, a) {
          if (hasOwnProperty.call(a, key)) {
            // `size` will be `-1` if `a` has more properties than `b`
            return (result = --size > -1);
          }
        });
      }
    }
    stackA.pop();
    stackB.pop();

    if (initedStack) {
      releaseArray(stackA);
      releaseArray(stackB);
    }
    return result;
  }

  /**
   * The base implementation of `_.merge` without argument juggling or support
   * for `thisArg` binding.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {Function} [callback] The function to customize merging properties.
   * @param {Array} [stackA=[]] Tracks traversed source objects.
   * @param {Array} [stackB=[]] Associates values with source counterparts.
   */
  function baseMerge(object, source, callback, stackA, stackB) {
    (isArray(source) ? forEach : forOwn)(source, function(source, key) {
      var found,
          isArr,
          result = source,
          value = object[key];

      if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
        // avoid merging previously merged cyclic sources
        var stackLength = stackA.length;
        while (stackLength--) {
          if ((found = stackA[stackLength] == source)) {
            value = stackB[stackLength];
            break;
          }
        }
        if (!found) {
          var isShallow;
          if (callback) {
            result = callback(value, source);
            if ((isShallow = typeof result != 'undefined')) {
              value = result;
            }
          }
          if (!isShallow) {
            value = isArr
              ? (isArray(value) ? value : [])
              : (isPlainObject(value) ? value : {});
          }
          // add `source` and associated `value` to the stack of traversed objects
          stackA.push(source);
          stackB.push(value);

          // recursively merge objects and arrays (susceptible to call stack limits)
          if (!isShallow) {
            baseMerge(value, source, callback, stackA, stackB);
          }
        }
      }
      else {
        if (callback) {
          result = callback(value, source);
          if (typeof result == 'undefined') {
            result = source;
          }
        }
        if (typeof result != 'undefined') {
          value = result;
        }
      }
      object[key] = value;
    });
  }

  /**
   * Creates a function that, when called, either curries or invokes `func`
   * with an optional `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of method flags to compose.
   *  The bitmask may be composed of the following flags:
   *  1 - `_.bind`
   *  2 - `_.bindKey`
   *  4 - `_.curry`
   *  8 - `_.curry` (bound)
   *  16 - `_.partial`
   *  32 - `_.partialRight`
   * @param {Array} [partialArgs] An array of arguments to prepend to those
   *  provided to the new function.
   * @param {Array} [partialRightArgs] An array of arguments to append to those
   *  provided to the new function.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new function.
   */
  function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        isPartial = bitmask & 16,
        isPartialRight = bitmask & 32;

    if (!isBindKey && !isFunction(func)) {
      throw new TypeError;
    }
    if (isPartial && !partialArgs.length) {
      bitmask &= ~16;
      isPartial = partialArgs = false;
    }
    if (isPartialRight && !partialRightArgs.length) {
      bitmask &= ~32;
      isPartialRight = partialRightArgs = false;
    }
    // fast path for `_.bind`
    var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
    return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
  }

  /**
   * Creates compiled iteration functions.
   *
   * @private
   * @param {...Object} [options] The compile options object(s).
   * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
   * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
   * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
   * @param {string} [options.args] A comma separated string of iteration function arguments.
   * @param {string} [options.top] Code to execute before the iteration branches.
   * @param {string} [options.loop] Code to execute in the object loop.
   * @param {string} [options.bottom] Code to execute after the iteration branches.
   * @returns {Function} Returns the compiled function.
   */
  function createIterator() {
    // data properties
    iteratorData.shadowedProps = shadowedProps;

    // iterator options
    iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
    iteratorData.init = 'iterable';
    iteratorData.useHas = true;

    // merge options into a template data object
    for (var object, index = 0; object = arguments[index]; index++) {
      for (var key in object) {
        iteratorData[key] = object[key];
      }
    }
    var args = iteratorData.args;
    iteratorData.firstArg = /^[^,]+/.exec(args)[0];

    // create the function factory
    var factory = Function(
        'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
        'indicatorObject, isArguments, isArray, isString, objectProto, ' +
        'objectTypes, nonEnumProps, stringClass, stringProto, toString',
      'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
    );

    // return the compiled function
    return factory(
      baseCreateCallback, errorClass, errorProto, hasOwnProperty,
      indicatorObject, isArguments, isArray, isString, objectProto,
      objectTypes, nonEnumProps, stringClass, stringProto, toString
    );
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if `value` is an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
   * @example
   *
   * (function() { return _.isArguments(arguments); })(1, 2, 3);
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = function(value) {
    return value && typeof value == 'object' && typeof value.length == 'number' &&
      hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
  };

  /**
   * Checks if `value` is an array.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
   * @example
   *
   * (function() { return _.isArray(arguments); })();
   * // => false
   *
   * _.isArray([1, 2, 3]);
   * // => true
   */
  var isArray = function(value) {
    return value && typeof value == 'object' && typeof value.length == 'number' &&
      toString.call(value) == arrayClass || false;
  };

  /**
   * Creates an array composed of the own enumerable property names of an object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   * @example
   *
   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
   * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
   */
  var keys = createIterator({
    'args': 'object',
    'init': '[]',
    'top': 'if (!(objectTypes[typeof object])) return result',
    'loop': 'result.push(index)'
  });

  /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
  var eachIteratorOptions = {
    'args': 'collection, callback, thisArg',
    'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
    'array': "typeof length == 'number'",
    'loop': 'if (callback(iterable[index], index, collection) === false) return result'
  };

  /** Reusable iterator options for `assign` and `defaults` */
  var defaultsIteratorOptions = {
    'args': 'object, source, guard',
    'top':
      'var args = arguments,\n' +
      '    argsIndex = 0,\n' +
      "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
      'while (++argsIndex < argsLength) {\n' +
      '  iterable = args[argsIndex];\n' +
      '  if (iterable && objectTypes[typeof iterable]) {',
    'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
    'bottom': '  }\n}'
  };

  /** Reusable iterator options for `forIn` and `forOwn` */
  var forOwnIteratorOptions = {
    'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
    'array': false
  };

  /**
   * A function compiled to iterate `arguments` objects, arrays, objects, and
   * strings consistenly across environments, executing the callback for each
   * element in the collection. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index|key, collection). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @private
   * @type Function
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   */
  var baseEach = createIterator(eachIteratorOptions);

  /*--------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources will overwrite property assignments of previous
   * sources. If a callback is provided it will be executed to produce the
   * assigned values. The callback is bound to `thisArg` and invoked with two
   * arguments; (objectValue, sourceValue).
   *
   * @static
   * @memberOf _
   * @type Function
   * @alias extend
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param {Function} [callback] The function to customize assigning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
   * // => { 'name': 'fred', 'employer': 'slate' }
   *
   * var defaults = _.partialRight(_.assign, function(a, b) {
   *   return typeof a == 'undefined' ? b : a;
   * });
   *
   * var object = { 'name': 'barney' };
   * defaults(object, { 'name': 'fred', 'employer': 'slate' });
   * // => { 'name': 'barney', 'employer': 'slate' }
   */
  var assign = createIterator(defaultsIteratorOptions, {
    'top':
      defaultsIteratorOptions.top.replace(';',
        ';\n' +
        "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
        '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
        "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
        '  callback = args[--argsLength];\n' +
        '}'
      ),
    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
  });

  /**
   * Iterates over own and inherited enumerable properties of an object,
   * executing the callback for each property. The callback is bound to `thisArg`
   * and invoked with three arguments; (value, key, object). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * Shape.prototype.move = function(x, y) {
   *   this.x += x;
   *   this.y += y;
   * };
   *
   * _.forIn(new Shape, function(value, key) {
   *   console.log(key);
   * });
   * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
   */
  var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
    'useHas': false
  });

  /**
   * Iterates over own enumerable properties of an object, executing the callback
   * for each property. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, key, object). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
   *   console.log(key);
   * });
   * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
   */
  var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);

  /**
   * Creates a sorted array of property names of all enumerable properties,
   * own and inherited, of `object` that have function values.
   *
   * @static
   * @memberOf _
   * @alias methods
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names that have function values.
   * @example
   *
   * _.functions(_);
   * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
   */
  function functions(object) {
    var result = [];
    forIn(object, function(value, key) {
      if (isFunction(value)) {
        result.push(key);
      }
    });
    return result.sort();
  }

  /**
   * Checks if `value` is a boolean value.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
   * @example
   *
   * _.isBoolean(null);
   * // => false
   */
  function isBoolean(value) {
    return value === true || value === false ||
      value && typeof value == 'object' && toString.call(value) == boolClass || false;
  }

  /**
   * Checks if `value` is a function.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   */
  function isFunction(value) {
    return typeof value == 'function';
  }
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value == 'function' && toString.call(value) == funcClass;
    };
  }

  /**
   * Checks if `value` is the language type of Object.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // check if the value is the ECMAScript language type of Object
    // http://es5.github.io/#x8
    // and avoid a V8 bug
    // http://code.google.com/p/v8/issues/detail?id=2291
    return !!(value && objectTypes[typeof value]);
  }

  /**
   * Checks if `value` is an object created by the `Object` constructor.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * _.isPlainObject(new Shape);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   */
  var isPlainObject = function(value) {
    var ctor,
        result;

    // avoid non Object objects, `arguments` objects, and DOM elements
    if (!(value && toString.call(value) == objectClass) ||
        (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||
        (!support.argsClass && isArguments(value)) ||
        (!support.nodeClass && isNode(value))) {
      return false;
    }
    // IE < 9 iterates inherited properties before own properties. If the first
    // iterated property is an object's own property then there are no inherited
    // enumerable properties.
    if (support.ownLast) {
      forIn(value, function(value, key, object) {
        result = hasOwnProperty.call(object, key);
        return false;
      });
      return result !== false;
    }
    // In most environments an object's own properties are iterated before
    // its inherited properties. If the last iterated property is an object's
    // own property then there are no inherited enumerable properties.
    forIn(value, function(value, key) {
      result = key;
    });
    return typeof result == 'undefined' || hasOwnProperty.call(value, result);
  };

  /**
   * Checks if `value` is a string.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
   * @example
   *
   * _.isString('fred');
   * // => true
   */
  function isString(value) {
    return typeof value == 'string' ||
      value && typeof value == 'object' && toString.call(value) == stringClass || false;
  }

  /**
   * Recursively merges own enumerable properties of the source object(s), that
   * don't resolve to `undefined` into the destination object. Subsequent sources
   * will overwrite property assignments of previous sources. If a callback is
   * provided it will be executed to produce the merged values of the destination
   * and source properties. If the callback returns `undefined` merging will
   * be handled by the method instead. The callback is bound to `thisArg` and
   * invoked with two arguments; (objectValue, sourceValue).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param {Function} [callback] The function to customize merging properties.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * var names = {
   *   'characters': [
   *     { 'name': 'barney' },
   *     { 'name': 'fred' }
   *   ]
   * };
   *
   * var ages = {
   *   'characters': [
   *     { 'age': 36 },
   *     { 'age': 40 }
   *   ]
   * };
   *
   * _.merge(names, ages);
   * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
   *
   * var food = {
   *   'fruits': ['apple'],
   *   'vegetables': ['beet']
   * };
   *
   * var otherFood = {
   *   'fruits': ['banana'],
   *   'vegetables': ['carrot']
   * };
   *
   * _.merge(food, otherFood, function(a, b) {
   *   return _.isArray(a) ? a.concat(b) : undefined;
   * });
   * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
   */
  function merge(object) {
    var args = arguments,
        length = 2;

    if (!isObject(object)) {
      return object;
    }
    // allows working with `_.reduce` and `_.reduceRight` without using
    // their `index` and `collection` arguments
    if (typeof args[2] != 'number') {
      length = args.length;
    }
    if (length > 3 && typeof args[length - 2] == 'function') {
      var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
    } else if (length > 2 && typeof args[length - 1] == 'function') {
      callback = args[--length];
    }
    var sources = slice(arguments, 1, length),
        index = -1,
        stackA = getArray(),
        stackB = getArray();

    while (++index < length) {
      baseMerge(object, sources[index], callback, stackA, stackB);
    }
    releaseArray(stackA);
    releaseArray(stackB);
    return object;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if the given callback returns truey value for **all** elements of
   * a collection. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias all
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if all elements passed the callback check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes']);
   * // => false
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.every(characters, 'age');
   * // => true
   *
   * // using "_.where" callback shorthand
   * _.every(characters, { 'age': 36 });
   * // => false
   */
  function every(collection, callback, thisArg) {
    var result = true;
    callback = lodash.createCallback(callback, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if (!(result = !!callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      baseEach(collection, function(value, index, collection) {
        return (result = !!callback(value, index, collection));
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning an array of all elements
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias select
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that passed the callback check.
   * @example
   *
   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [2, 4, 6]
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.filter(characters, 'blocked');
   * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
   *
   * // using "_.where" callback shorthand
   * _.filter(characters, { 'age': 36 });
   * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
   */
  function filter(collection, callback, thisArg) {
    var result = [];
    callback = lodash.createCallback(callback, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          result.push(value);
        }
      }
    } else {
      baseEach(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result.push(value);
        }
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning the first element that
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias detect, findWhere
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the found element, else `undefined`.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney',  'age': 36, 'blocked': false },
   *   { 'name': 'fred',    'age': 40, 'blocked': true },
   *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
   * ];
   *
   * _.find(characters, function(chr) {
   *   return chr.age < 40;
   * });
   * // => { 'name': 'barney', 'age': 36, 'blocked': false }
   *
   * // using "_.where" callback shorthand
   * _.find(characters, { 'age': 1 });
   * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
   *
   * // using "_.pluck" callback shorthand
   * _.find(characters, 'blocked');
   * // => { 'name': 'fred', 'age': 40, 'blocked': true }
   */
  function find(collection, callback, thisArg) {
    callback = lodash.createCallback(callback, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          return value;
        }
      }
    } else {
      var result;
      baseEach(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }
  }

  /**
   * Iterates over elements of a collection, executing the callback for each
   * element. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * Note: As with other "Collections" methods, objects with a `length` property
   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
   * may be used for object iteration.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
   * // => logs each number and returns '1,2,3'
   *
   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
   * // => logs each number and returns the object (property order is not guaranteed across environments)
   */
  function forEach(collection, callback, thisArg) {
    if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if (callback(collection[index], index, collection) === false) {
          break;
        }
      }
    } else {
      baseEach(collection, callback, thisArg);
    }
    return collection;
  }

  /**
   * Creates an array of values by running each element in the collection
   * through the callback. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * _.map([1, 2, 3], function(num) { return num * 3; });
   * // => [3, 6, 9]
   *
   * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
   * // => [3, 6, 9] (property order is not guaranteed across environments)
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.map(characters, 'name');
   * // => ['barney', 'fred']
   */
  function map(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    callback = lodash.createCallback(callback, thisArg, 3);
    if (isArray(collection)) {
      while (++index < length) {
        result[index] = callback(collection[index], index, collection);
      }
    } else {
      baseEach(collection, function(value, key, collection) {
        result[++index] = callback(value, key, collection);
      });
    }
    return result;
  }

  /**
   * Retrieves the value of a specified property from all elements in the collection.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {string} property The name of the property to pluck.
   * @returns {Array} Returns a new array of property values.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * _.pluck(characters, 'name');
   * // => ['barney', 'fred']
   */
  var pluck = map;

  /**
   * Reduces a collection to a value which is the accumulated result of running
   * each element in the collection through the callback, where each successive
   * callback execution consumes the return value of the previous execution. If
   * `accumulator` is not provided the first element of the collection will be
   * used as the initial `accumulator` value. The callback is bound to `thisArg`
   * and invoked with four arguments; (accumulator, value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias foldl, inject
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [accumulator] Initial value of the accumulator.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the accumulated value.
   * @example
   *
   * var sum = _.reduce([1, 2, 3], function(sum, num) {
   *   return sum + num;
   * });
   * // => 6
   *
   * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
   *   result[key] = num * 3;
   *   return result;
   * }, {});
   * // => { 'a': 3, 'b': 6, 'c': 9 }
   */
  function reduce(collection, callback, accumulator, thisArg) {
    var noaccum = arguments.length < 3;
    callback = lodash.createCallback(callback, thisArg, 4);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      if (noaccum) {
        accumulator = collection[++index];
      }
      while (++index < length) {
        accumulator = callback(accumulator, collection[index], index, collection);
      }
    } else {
      baseEach(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection)
      });
    }
    return accumulator;
  }

  /**
   * Checks if the callback returns a truey value for **any** element of a
   * collection. The function returns as soon as it finds a passing value and
   * does not iterate over the entire collection. The callback is bound to
   * `thisArg` and invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias any
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if any element passed the callback check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36, 'blocked': false },
   *   { 'name': 'fred',   'age': 40, 'blocked': true }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.some(characters, 'blocked');
   * // => true
   *
   * // using "_.where" callback shorthand
   * _.some(characters, { 'age': 1 });
   * // => false
   */
  function some(collection, callback, thisArg) {
    var result;
    callback = lodash.createCallback(callback, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if ((result = callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      baseEach(collection, function(value, index, collection) {
        return !(result = callback(value, index, collection));
      });
    }
    return !!result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Flattens a nested array (the nesting can be to any depth). If `isShallow`
   * is truey, the array will only be flattened a single level. If a callback
   * is provided each element of the array is passed through the callback before
   * flattening. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created "_.pluck" style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created "_.where" style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a "_.pluck" or "_.where" style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new flattened array.
   * @example
   *
   * _.flatten([1, [2], [3, [[4]]]]);
   * // => [1, 2, 3, 4];
   *
   * _.flatten([1, [2], [3, [[4]]]], true);
   * // => [1, 2, 3, [[4]]];
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
   *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
   * ];
   *
   * // using "_.pluck" callback shorthand
   * _.flatten(characters, 'pets');
   * // => ['hoppy', 'baby puss', 'dino']
   */
  function flatten(array, isShallow, callback, thisArg) {
    // juggle arguments
    if (typeof isShallow != 'boolean' && isShallow != null) {
      thisArg = callback;
      callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
      isShallow = false;
    }
    if (callback != null) {
      array = map(array, callback, thisArg);
    }
    return baseFlatten(array, isShallow);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any additional `bind` arguments to those
   * provided to the bound function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to bind.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {...*} [arg] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var func = function(greeting) {
   *   return greeting + ' ' + this.name;
   * };
   *
   * func = _.bind(func, { 'name': 'fred' }, 'hi');
   * func();
   * // => 'hi fred'
   */
  function bind(func, thisArg) {
    return arguments.length > 2
      ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
      : createWrapper(func, 1, null, null, thisArg);
  }

  /**
   * Binds methods of an object to the object itself, overwriting the existing
   * method. Method names may be specified as individual arguments or as arrays
   * of method names. If no method names are provided all the function properties
   * of `object` will be bound.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Object} object The object to bind and assign the bound methods to.
   * @param {...string} [methodName] The object method names to
   *  bind, specified as individual method names or arrays of method names.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var view = {
   *   'label': 'docs',
   *   'onClick': function() { console.log('clicked ' + this.label); }
   * };
   *
   * _.bindAll(view);
   * jQuery('#docs').on('click', view.onClick);
   * // => logs 'clicked docs', when the button is clicked
   */
  function bindAll(object) {
    var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
        index = -1,
        length = funcs.length;

    while (++index < length) {
      var key = funcs[index];
      object[key] = createWrapper(object[key], 1, null, null, object);
    }
    return object;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Produces a callback bound to an optional `thisArg`. If `func` is a property
   * name the created callback will return the property value for a given element.
   * If `func` is an object the created callback will return `true` for elements
   * that contain the equivalent object properties, otherwise it will return `false`.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   * @example
   *
   * var characters = [
   *   { 'name': 'barney', 'age': 36 },
   *   { 'name': 'fred',   'age': 40 }
   * ];
   *
   * // wrap to create custom callback shorthands
   * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
   *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
   *   return !match ? func(callback, thisArg) : function(object) {
   *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
   *   };
   * });
   *
   * _.filter(characters, 'age__gt38');
   * // => [{ 'name': 'fred', 'age': 40 }]
   */
  function createCallback(func, thisArg, argCount) {
    var type = typeof func;
    if (func == null || type == 'function') {
      return baseCreateCallback(func, thisArg, argCount);
    }
    // handle "_.pluck" style callback shorthands
    if (type != 'object') {
      return property(func);
    }
    var props = keys(func),
        key = props[0],
        a = func[key];

    // handle "_.where" style callback shorthands
    if (props.length == 1 && a === a && !isObject(a)) {
      // fast path the common case of providing an object with a single
      // property containing a primitive value
      return function(object) {
        var b = object[key];
        return a === b && (a !== 0 || (1 / a == 1 / b));
      };
    }
    return function(object) {
      var length = props.length,
          result = false;

      while (length--) {
        if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
          break;
        }
      }
      return result;
    };
  }

  /**
   * This method returns the first argument provided to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.identity(object) === object;
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * A no-operation function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.noop(object) === undefined;
   * // => true
   */
  function noop() {
    // no operation performed
  }

  /**
   * Creates a "_.pluck" style function, which returns the `key` value of a
   * given object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} key The name of the property to retrieve.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var characters = [
   *   { 'name': 'fred',   'age': 40 },
   *   { 'name': 'barney', 'age': 36 }
   * ];
   *
   * var getName = _.property('name');
   *
   * _.map(characters, getName);
   * // => ['barney', 'fred']
   *
   * _.sortBy(characters, getName);
   * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
   */
  function property(key) {
    return function(object) {
      return object[key];
    };
  }

  /*--------------------------------------------------------------------------*/

  lodash.assign = assign;
  lodash.bind = bind;
  lodash.bindAll = bindAll;
  lodash.createCallback = createCallback;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.forEach = forEach;
  lodash.forIn = forIn;
  lodash.forOwn = forOwn;
  lodash.functions = functions;
  lodash.keys = keys;
  lodash.map = map;
  lodash.merge = merge;
  lodash.pluck = pluck;
  lodash.property = property;

  // add aliases
  lodash.collect = map;
  lodash.each = forEach;
  lodash.extend = assign;
  lodash.methods = functions;
  lodash.select = filter;

  /*--------------------------------------------------------------------------*/

  lodash.every = every;
  lodash.find = find;
  lodash.identity = identity;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isBoolean = isBoolean;
  lodash.isFunction = isFunction;
  lodash.isObject = isObject;
  lodash.isPlainObject = isPlainObject;
  lodash.isString = isString;
  lodash.noop = noop;
  lodash.reduce = reduce;
  lodash.some = some;

  // add aliases
  lodash.all = every;
  lodash.any = some;
  lodash.detect = find;
  lodash.findWhere = find;
  lodash.foldl = reduce;
  lodash.inject = reduce;

  /*--------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type string
   */
  lodash.VERSION = '2.4.1';

  /*--------------------------------------------------------------------------*/

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define('mini_lodash',[],function() {
      return lodash;
    });
  }

}.call(this));

define('normalize_endpoints',['require','exports','module','mini_lodash'],function (require, exports, module) {/**
 * Given an object with keys/endpoints
 * loop over all endpoints (recursively entering nested objects)
 * and normalize the endpoint.
 *
 * Normalization is
 *
 * - prepending current page's protocol if protocol is not
 * already specified
 * - removing the trailing slash
 *
 */

var _ = require('mini_lodash')

function normalizeEndpoint (endpoint) {
  endpoint = /^(https?:)?\/\//.test(endpoint) ? endpoint : window.location.protocol + '//' + endpoint
  return endpoint.replace(/\/$/, '')
}

function normalizeEndpoints (endpoints) {
  _.each(endpoints, function (url, key) {
    if (_.isString(url)) {
      endpoints[key] = normalizeEndpoint(url)
    } else {
      normalizeEndpoints(endpoints[key])
    }
  })
}

module.exports = function (config) {
  return normalizeEndpoints(config.endpoints)
}

});

/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

define('json',[],function () {

var JSON = {};
// ALWAYS OVERWRITE JSON LOCALLY, ASSUME THIS FILE WILL ALWAYS BE IN CLOSURE
// if (!JSON || window.forceJSONRewrite) {
//     JSON = {};
// }

(function () {
    

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    // PROTECTING AGAINST PROTOTYPE.JS
    // don't rely on Date, Number, String and Boolean prototypes
    
    // if (typeof Date.prototype.toJSON !== 'function') {

    //     Date.prototype.toJSON = function (key) {

    //         return isFinite(this.valueOf()) ?
    //             this.getUTCFullYear()     + '-' +
    //             f(this.getUTCMonth() + 1) + '-' +
    //             f(this.getUTCDate())      + 'T' +
    //             f(this.getUTCHours())     + ':' +
    //             f(this.getUTCMinutes())   + ':' +
    //             f(this.getUTCSeconds())   + 'Z' : null;
    //     };

    //     String.prototype.toJSON      =
    //         Number.prototype.toJSON  =
    //         Boolean.prototype.toJSON = function (key) {
    //             return this.valueOf();
    //         };
    // }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }

    // PROTECTION AGAINST PROTOTYPE.JS
    // we'll use this function to stringify Date
    function stringifyDate(key) {
        return isFinite(key.valueOf()) ?
            key.getUTCFullYear()     + '-' +
            f(key.getUTCMonth() + 1) + '-' +
            f(key.getUTCDate())      + 'T' +
            f(key.getUTCHours())     + ':' +
            f(key.getUTCMinutes())   + ':' +
            f(key.getUTCSeconds())   + 'Z' : null;
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];


        // PROTECTION AGAINST PROTOTYPE.JS
        // don't call value.toJSON, only specially treat Date, Number, String and Boolean

// If the value has a toJSON method, call it to obtain a replacement value.

        // if (value && typeof value === 'object' &&
        //         typeof value.toJSON === 'function') {
        //     value = value.toJSON(key);
        // }

        if (value instanceof Date) {
            value = stringifyDate(value);
        } else if ((value instanceof String) || (value instanceof Number) || (value instanceof Boolean)) {
            value = value.valueOf();
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
    
return JSON;
});
define('logger',['require','json'],function (require) {
  var JSON = require('json')

  return {
    logVariation: function (id, isControl, textArray, isError) {
      if (window._ss_debug) {
        var args = [isControl ? 'control  ' : 'variation', id]
        var extra = Array.prototype.slice.call(textArray, 0)
        args.push.apply(args, extra)
        if (isError) {
          this.logError.apply(this, args)
        } else {
          this.log.apply(this, args)
        }
      }
    },
    logExperiment: function (id, textArray, isError) {
      if (window._ss_debug) {
        var args = ['experiment', id]
        var extra = Array.prototype.slice.call(textArray, 0)
        args.push.apply(args, extra)
        if (isError) {
          this.logError.apply(this, args)
        } else {
          this.log.apply(this, args)
        }
      }
    },
    logError: function () {
      if (window._ss_debug) {
        var args = Array.prototype.slice.call(arguments, 0)
        if (window.console) {
          try {
            console.error.apply(console, args)
          } catch (e) {
            console.error(JSON.stringify(args))
          }
        }
        window._qb_messages = window._qb_messages || []
        window._qb_messages.push(args)
      }
    },
    log: function () {
      if (window._ss_debug) {
        var args = Array.prototype.slice.call(arguments, 0)
        if (window.console) {
          try {
            console.log.apply(console, args)
          } catch (e) {
            console.log(JSON.stringify(args))
          }
        }
        window._qb_messages = window._qb_messages || []
        window._qb_messages.push(args)
      }
    }
  }
})
;
/** @license MIT License (c) copyright 2011-2013 original author or authors */

/**
 * A lightweight CommonJS Promises/A and when() implementation
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @author Brian Cavalier
 * @author John Hann
 *
 * @version 1.8.1
 */

(function(define) { 
define('when',[],function () {
  var reduceArray, slice, undef;

  //
  // Public API
  //

  when.defer     = defer;     // Create a deferred
  when.resolve   = resolve;   // Create a resolved promise
  when.reject    = reject;    // Create a rejected promise

  when.join      = join;      // Join 2 or more promises

  when.all       = all;       // Resolve a list of promises
  when.map       = map;       // Array.map() for promises
  when.reduce    = reduce;    // Array.reduce() for promises

  when.any       = any;       // One-winner race
  when.some      = some;      // Multi-winner race

  when.chain     = chain;     // Make a promise trigger another resolver

  when.isPromise = isPromise; // Determine if a thing is a promise

  /**
   * Register an observer for a promise or immediate value.
   *
   * @param {*} promiseOrValue
   * @param {function?} [onFulfilled] callback to be called when promiseOrValue is
   *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
   *   will be invoked immediately.
   * @param {function?} [onRejected] callback to be called when promiseOrValue is
   *   rejected.
   * @param {function?} [onProgress] callback to be called when progress updates
   *   are issued for promiseOrValue.
   * @returns {Promise} a new {@link Promise} that will complete with the return
   *   value of callback or errback or the completion value of promiseOrValue if
   *   callback and/or errback is not supplied.
   */
  function when(promiseOrValue, onFulfilled, onRejected, onProgress) {
    // Get a trusted promise for the input promiseOrValue, and then
    // register promise handlers
    return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);
  }

  /**
   * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
   * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}
   * whose value is promiseOrValue if promiseOrValue is an immediate value.
   *
   * @param {*} promiseOrValue
   * @returns {Promise} Guaranteed to return a trusted Promise.  If promiseOrValue
   *   is trusted, returns promiseOrValue, otherwise, returns a new, already-resolved
   *   when.js promise whose resolution value is:
   *   * the resolution value of promiseOrValue if it's a foreign promise, or
   *   * promiseOrValue if it's a value
   */
  function resolve(promiseOrValue) {
    var promise;

    if(promiseOrValue instanceof Promise) {
      // It's a when.js promise, so we trust it
      promise = promiseOrValue;

    } else if(isPromise(promiseOrValue)) {
      // Assimilate foreign promises
      promise = assimilate(promiseOrValue);
    } else {
      // It's a value, create a fulfilled promise for it.
      promise = fulfilled(promiseOrValue);
    }

    return promise;
  }

  /**
   * Assimilate an untrusted thenable by introducing a trusted middle man.
   * Not a perfect strategy, but possibly the best we can do.
   * IMPORTANT: This is the only place when.js should ever call an untrusted
   * thenable's then() on an. Don't expose the return value to the untrusted thenable
   *
   * @param {*} thenable
   * @param {function} thenable.then
   * @returns {Promise}
   */
  function assimilate(thenable) {
    var d = defer();

    // TODO: Enqueue this for future execution in 2.0
    try {
      thenable.then(
        function(value)  { d.resolve(value); },
        function(reason) { d.reject(reason); },
        function(update) { d.progress(update); }
      );
    } catch(e) {
      d.reject(e);
    }

    return d.promise;
  }

  /**
   * Returns a rejected promise for the supplied promiseOrValue.  The returned
   * promise will be rejected with:
   * - promiseOrValue, if it is a value, or
   * - if promiseOrValue is a promise
   *   - promiseOrValue's value after it is fulfilled
   *   - promiseOrValue's reason after it is rejected
   * @param {*} promiseOrValue the rejected value of the returned {@link Promise}
   * @return {Promise} rejected {@link Promise}
   */
  function reject(promiseOrValue) {
    return when(promiseOrValue, rejected);
  }

  /**
   * Trusted Promise constructor.  A Promise created from this constructor is
   * a trusted when.js promise.  Any other duck-typed promise is considered
   * untrusted.
   * @constructor
   * @name Promise
   */
  function Promise(then) {
    this.then = then;
  }

  Promise.prototype = {
    /**
     * Register a callback that will be called when a promise is
     * fulfilled or rejected.  Optionally also register a progress handler.
     * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)
     * @param {function?} [onFulfilledOrRejected]
     * @param {function?} [onProgress]
     * @return {Promise}
     */
    always: function(onFulfilledOrRejected, onProgress) {
      return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);
    },

    /**
     * Register a rejection handler.  Shortcut for .then(undefined, onRejected)
     * @param {function?} onRejected
     * @return {Promise}
     */
    otherwise: function(onRejected) {
      return this.then(undef, onRejected);
    },

    /**
     * Shortcut for .then(function() { return value; })
     * @param  {*} value
     * @return {Promise} a promise that:
     *  - is fulfilled if value is not a promise, or
     *  - if value is a promise, will fulfill with its value, or reject
     *    with its reason.
     */
    'yield': function(value) {
      return this.then(function() {
        return value;
      });
    },

    /**
     * Assumes that this promise will fulfill with an array, and arranges
     * for the onFulfilled to be called with the array as its argument list
     * i.e. onFulfilled.apply(undefined, array).
     * @param {function} onFulfilled function to receive spread arguments
     * @return {Promise}
     */
    spread: function(onFulfilled) {
      return this.then(function(array) {
        // array may contain promises, so resolve its contents.
        return all(array, function(array) {
          return onFulfilled.apply(undef, array);
        });
      });
    }
  };

  /**
   * Create an already-resolved promise for the supplied value
   * @private
   *
   * @param {*} value
   * @return {Promise} fulfilled promise
   */
  function fulfilled(value) {
    var p = new Promise(function(onFulfilled) {
      try {
        return resolve(typeof onFulfilled == 'function' ? onFulfilled(value) : value);
      } catch(e) {
        return rejected(e);
      }
    });

    return p;
  }

  /**
   * Create an already-rejected {@link Promise} with the supplied
   * rejection reason.
   * @private
   *
   * @param {*} reason
   * @return {Promise} rejected promise
   */
  function rejected(reason) {
    var p = new Promise(function(_, onRejected) {
      try {
        return resolve(typeof onRejected == 'function' ? onRejected(reason) : rejected(reason));
      } catch(e) {
        return rejected(e);
      }
    });

    return p;
  }

  /**
   * Creates a new, Deferred with fully isolated resolver and promise parts,
   * either or both of which may be given out safely to consumers.
   * The Deferred itself has the full API: resolve, reject, progress, and
   * then. The resolver has resolve, reject, and progress.  The promise
   * only has then.
   *
   * @return {Deferred}
   */
  function defer() {
    var deferred, promise, handlers, progressHandlers,
      _then, _notify, _resolve;

    /**
     * The promise for the new deferred
     * @type {Promise}
     */
    promise = new Promise(then);

    /**
     * The full Deferred object, with {@link Promise} and {@link Resolver} parts
     * @class Deferred
     * @name Deferred
     */
    deferred = {
      then:     then, // DEPRECATED: use deferred.promise.then
      resolve:  promiseResolve,
      reject:   promiseReject,
      progress: promiseNotify, // DEPRECATED: use deferred.notify
      notify:   promiseNotify,

      promise:  promise,

      resolver: {
        resolve:  promiseResolve,
        reject:   promiseReject,
        progress: promiseNotify, // DEPRECATED: use deferred.notify
        notify:   promiseNotify
      }
    };

    handlers = [];
    progressHandlers = [];

    /**
     * Pre-resolution then() that adds the supplied callback, errback, and progback
     * functions to the registered listeners
     * @private
     *
     * @param {function?} [onFulfilled] resolution handler
     * @param {function?} [onRejected] rejection handler
     * @param {function?} [onProgress] progress handler
     */
    _then = function(onFulfilled, onRejected, onProgress) {
      var deferred, progressHandler;

      deferred = defer();

      progressHandler = typeof onProgress === 'function'
        ? function(update) {
          try {
            // Allow progress handler to transform progress event
            deferred.notify(onProgress(update));
          } catch(e) {
            // Use caught value as progress
            deferred.notify(e);
          }
        }
        : function(update) { deferred.notify(update); };

      handlers.push(function(promise) {
        promise.then(onFulfilled, onRejected)
          .then(deferred.resolve, deferred.reject, progressHandler);
      });

      progressHandlers.push(progressHandler);

      return deferred.promise;
    };

    /**
     * Issue a progress event, notifying all progress listeners
     * @private
     * @param {*} update progress event payload to pass to all listeners
     */
    _notify = function(update) {
      processQueue(progressHandlers, update);
      return update;
    };

    /**
     * Transition from pre-resolution state to post-resolution state, notifying
     * all listeners of the resolution or rejection
     * @private
     * @param {*} value the value of this deferred
     */
    _resolve = function(value) {
      // Replace _then with one that directly notifies with the result.
      _then = value.then;
      // Replace _resolve so that this Deferred can only be resolved once
      _resolve = resolve;
      // Make _progress a noop, to disallow progress for the resolved promise.
      _notify = identity;

      // Notify handlers
      processQueue(handlers, value);

      // Free progressHandlers array since we'll never issue progress events
      progressHandlers = handlers = undef;

      return value;
    };

    return deferred;

    /**
     * Wrapper to allow _then to be replaced safely
     * @param {function?} [onFulfilled] resolution handler
     * @param {function?} [onRejected] rejection handler
     * @param {function?} [onProgress] progress handler
     * @return {Promise} new promise
     */
    function then(onFulfilled, onRejected, onProgress) {
      // TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
      return _then(onFulfilled, onRejected, onProgress);
    }

    /**
     * Wrapper to allow _resolve to be replaced
     */
    function promiseResolve(val) {
      return _resolve(resolve(val));
    }

    /**
     * Wrapper to allow _reject to be replaced
     */
    function promiseReject(err) {
      return _resolve(rejected(err));
    }

    /**
     * Wrapper to allow _notify to be replaced
     */
    function promiseNotify(update) {
      return _notify(update);
    }
  }

  /**
   * Determines if promiseOrValue is a promise or not.  Uses the feature
   * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
   * promiseOrValue is a promise.
   *
   * @param {*} promiseOrValue anything
   * @returns {boolean} true if promiseOrValue is a {@link Promise}
   */
  function isPromise(promiseOrValue) {
    return promiseOrValue && typeof promiseOrValue.then === 'function';
  }

  /**
   * Initiates a competitive race, returning a promise that will resolve when
   * howMany of the supplied promisesOrValues have resolved, or will reject when
   * it becomes impossible for howMany to resolve, for example, when
   * (promisesOrValues.length - howMany) + 1 input promises reject.
   *
   * @param {Array} promisesOrValues array of anything, may contain a mix
   *      of promises and values
   * @param howMany {number} number of promisesOrValues to resolve
   * @param {function?} [onFulfilled] resolution handler
   * @param {function?} [onRejected] rejection handler
   * @param {function?} [onProgress] progress handler
   * @returns {Promise} promise that will resolve to an array of howMany values that
   * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1
   * rejection reasons.
   */
  function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {

    checkCallbacks(2, arguments);

    return when(promisesOrValues, function(promisesOrValues) {

      var toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, notify, len, i;

      len = promisesOrValues.length >>> 0;

      toResolve = Math.max(0, Math.min(howMany, len));
      values = [];

      toReject = (len - toResolve) + 1;
      reasons = [];

      deferred = defer();

      // No items in the input, resolve immediately
      if (!toResolve) {
        deferred.resolve(values);

      } else {
        notify = deferred.notify;

        rejectOne = function(reason) {
          reasons.push(reason);
          if(!--toReject) {
            fulfillOne = rejectOne = noop;
            deferred.reject(reasons);
          }
        };

        fulfillOne = function(val) {
          // This orders the values based on promise resolution order
          // Another strategy would be to use the original position of
          // the corresponding promise.
          values.push(val);

          if (!--toResolve) {
            fulfillOne = rejectOne = noop;
            deferred.resolve(values);
          }
        };

        for(i = 0; i < len; ++i) {
          if(i in promisesOrValues) {
            when(promisesOrValues[i], fulfiller, rejecter, notify);
          }
        }
      }

      return deferred.promise.then(onFulfilled, onRejected, onProgress);

      function rejecter(reason) {
        rejectOne(reason);
      }

      function fulfiller(val) {
        fulfillOne(val);
      }

    });
  }

  /**
   * Initiates a competitive race, returning a promise that will resolve when
   * any one of the supplied promisesOrValues has resolved or will reject when
   * *all* promisesOrValues have rejected.
   *
   * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
   *      of {@link Promise}s and values
   * @param {function?} [onFulfilled] resolution handler
   * @param {function?} [onRejected] rejection handler
   * @param {function?} [onProgress] progress handler
   * @returns {Promise} promise that will resolve to the value that resolved first, or
   * will reject with an array of all rejected inputs.
   */
  function any(promisesOrValues, onFulfilled, onRejected, onProgress) {

    function unwrapSingleResult(val) {
      return onFulfilled ? onFulfilled(val[0]) : val[0];
    }

    return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);
  }

  /**
   * Return a promise that will resolve only once all the supplied promisesOrValues
   * have resolved. The resolution value of the returned promise will be an array
   * containing the resolution values of each of the promisesOrValues.
   * @memberOf when
   *
   * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
   *      of {@link Promise}s and values
   * @param {function?} [onFulfilled] resolution handler
   * @param {function?} [onRejected] rejection handler
   * @param {function?} [onProgress] progress handler
   * @returns {Promise}
   */
  function all(promisesOrValues, onFulfilled, onRejected, onProgress) {
    checkCallbacks(1, arguments);
    return map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);
  }

  /**
   * Joins multiple promises into a single returned promise.
   * @return {Promise} a promise that will fulfill when *all* the input promises
   * have fulfilled, or will reject when *any one* of the input promises rejects.
   */
  function join(/* ...promises */) {
    return map(arguments, identity);
  }

  /**
   * Traditional map function, similar to `Array.prototype.map()`, but allows
   * input to contain {@link Promise}s and/or values, and mapFunc may return
   * either a value or a {@link Promise}
   *
   * @param {Array|Promise} promise array of anything, may contain a mix
   *      of {@link Promise}s and values
   * @param {function} mapFunc mapping function mapFunc(value) which may return
   *      either a {@link Promise} or value
   * @returns {Promise} a {@link Promise} that will resolve to an array containing
   *      the mapped output values.
   */
  function map(promise, mapFunc) {
    return when(promise, function(array) {
      var results, len, toResolve, resolve, i, d;

      // Since we know the resulting length, we can preallocate the results
      // array to avoid array expansions.
      toResolve = len = array.length >>> 0;
      results = [];
      d = defer();

      if(!toResolve) {
        d.resolve(results);
      } else {

        resolve = function resolveOne(item, i) {
          when(item, mapFunc).then(function(mapped) {
            results[i] = mapped;

            if(!--toResolve) {
              d.resolve(results);
            }
          }, d.reject, d.notify);
        };

        // Since mapFunc may be async, get all invocations of it into flight
        for(i = 0; i < len; i++) {
          if(i in array) {
            resolve(array[i], i);
          } else {
            --toResolve;
          }
        }

      }

      return d.promise;

    });
  }

  /**
   * Traditional reduce function, similar to `Array.prototype.reduce()`, but
   * input may contain promises and/or values, and reduceFunc
   * may return either a value or a promise, *and* initialValue may
   * be a promise for the starting value.
   *
   * @param {Array|Promise} promise array or promise for an array of anything,
   *      may contain a mix of promises and values.
   * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),
   *      where total is the total number of items being reduced, and will be the same
   *      in each call to reduceFunc.
   * @returns {Promise} that will resolve to the final reduced value
   */
  function reduce(promise, reduceFunc /*, initialValue */) {
    var args = slice.call(arguments, 1);

    return when(promise, function(array) {
      var total;

      total = array.length;

      // Wrap the supplied reduceFunc with one that handles promises and then
      // delegates to the supplied.
      args[0] = function (current, val, i) {
        return when(current, function (c) {
          return when(val, function (value) {
            return reduceFunc(c, value, i, total);
          });
        });
      };

      return reduceArray.apply(array, args);
    });
  }

  /**
   * Ensure that resolution of promiseOrValue will trigger resolver with the
   * value or reason of promiseOrValue, or instead with resolveValue if it is provided.
   *
   * @param promiseOrValue
   * @param {Object} resolver
   * @param {function} resolver.resolve
   * @param {function} resolver.reject
   * @param {*} [resolveValue]
   * @returns {Promise}
   */
  function chain(promiseOrValue, resolver, resolveValue) {
    var useResolveValue = arguments.length > 2;

    return when(promiseOrValue,
      function(val) {
        val = useResolveValue ? resolveValue : val;
        resolver.resolve(val);
        return val;
      },
      function(reason) {
        resolver.reject(reason);
        return rejected(reason);
      },
      function(update) {
        typeof resolver.notify === 'function' && resolver.notify(update);
        return update;
      }
    );
  }

  //
  // Utility functions
  //

  /**
   * Apply all functions in queue to value
   * @param {Array} queue array of functions to execute
   * @param {*} value argument passed to each function
   */
  function processQueue(queue, value) {
    var handler, i = 0;

    while (handler = queue[i++]) {
      handler(value);
    }
  }

  /**
   * Helper that checks arrayOfCallbacks to ensure that each element is either
   * a function, or null or undefined.
   * @private
   * @param {number} start index at which to start checking items in arrayOfCallbacks
   * @param {Array} arrayOfCallbacks array to check
   * @throws {Error} if any element of arrayOfCallbacks is something other than
   * a functions, null, or undefined.
   */
  function checkCallbacks(start, arrayOfCallbacks) {
    // TODO: Promises/A+ update type checking and docs
    var arg, i = arrayOfCallbacks.length;

    while(i > start) {
      arg = arrayOfCallbacks[--i];

      if (arg != null && typeof arg != 'function') {
        throw new Error('arg '+i+' must be a function');
      }
    }
  }

  /**
   * No-Op function used in method replacement
   * @private
   */
  function noop() {}

  slice = [].slice;

  // ES5 reduce implementation if native not available
  // See: http://es5.github.com/#x15.4.4.21 as there are many
  // specifics and edge cases.
  reduceArray = [].reduce ||
    function(reduceFunc /*, initialValue */) {
      /*jshint maxcomplexity: 7*/

      // ES5 dictates that reduce.length === 1

      // This implementation deviates from ES5 spec in the following ways:
      // 1. It does not check if reduceFunc is a Callable

      var arr, args, reduced, len, i;

      i = 0;
      // This generates a jshint warning, despite being valid
      // "Missing 'new' prefix when invoking a constructor."
      // See https://github.com/jshint/jshint/issues/392
      arr = Object(this);
      len = arr.length >>> 0;
      args = arguments;

      // If no initialValue, use first item of array (we know length !== 0 here)
      // and adjust i to start at second item
      if(args.length <= 1) {
        // Skip to the first real element in the array
        for(;;) {
          if(i in arr) {
            reduced = arr[i++];
            break;
          }

          // If we reached the end of the array without finding any real
          // elements, it's a TypeError
          if(++i >= len) {
            throw new TypeError();
          }
        }
      } else {
        // If initialValue provided, use it
        reduced = args[1];
      }

      // Do the actual reduce
      for(;i < len; ++i) {
        // Skip holes
        if(i in arr) {
          reduced = reduceFunc(reduced, arr[i], i, arr);
        }
      }

      return reduced;
    };

  function identity(x) {
    return x;
  }

  return when;
});
})(typeof define == 'function' && define.amd
  ? define
  : function (factory) { typeof exports === 'object'
    ? (module.exports = factory())
    : (this.when      = factory());
  }
  // Boilerplate for AMD, Node, and browser global
);
define('when_map',['require','mini_lodash','when'],function (require) {

  return function (object) {

    var _    = require('mini_lodash');
    var when = require('when');

    var keys = _.keys(object);
    var vals = _.map(keys, function (key) {
      return object[key];
    });

    var d = when.defer();
    when.all(vals).then(function (args) {
      var results = {};
      _.each(keys, function (key, i) {
        return results[key] = args[i];
      });
      d.resolve(results);
    });
    return d.promise;

  };

});

define('cookieman/get_domains',['require','exports','module'],function (require, exports, module) {module.exports = function getDomains(domain) {
  var domains = [], fragments = domain.split(".");
  var i = 0, l = fragments.length, fragment;
  for (i; i < l - 1; i++) {
    fragment = fragments.slice(i, fragments.length).join(".");
    domains.push(fragment, "." + fragment);
  }
  domains.push(null);
  return domains;
};

});

define('cookieman/get_paths',['require','exports','module'],function (require, exports, module) {module.exports = function getPaths(path) {
  path = path.replace(/\/$/, "").split("/");
  var paths = [], i = 0, l = path.length;
  for (i; i < l; i++) {
    paths.push(path.slice(0, i + 1).join("/") || "/")
  }
  return paths;
};
});

define('cookieman/trim',['require','exports','module'],function (require, exports, module) {module.exports = function (str) {
  return str.replace(/(^\s+|\s+$)/gi, "");
};
});

define('cookieman/cookieman',['require','exports','module','./get_domains','./get_paths','./trim'],function (require, exports, module) {(function() {
  var getDomains = require("./get_domains");
  var getPaths = require("./get_paths");
  var trim = require("./trim");

  /**
   * Get a cookie
   *
   * @public
   * @param {String} name The cookie name
   * @returns {Array} Returns an array of matching cookies
   */
  function getCookie (name) {
    var cookie = [];
    var cookies = getCookies();
    var i = 0, l = cookies.length;
    for (i; i < l; i++) {
      if (cookies[i].name === name) {
        cookie.push(cookies[i]);
      }
    }
    return cookie;
  }

  /**
   * Set a cookie
   *
   * @public
   * @param {String} name The cookie name
   * @param {String} value The cookie value
   * @param {Object} options Optionally set expires, path or cookie domain
   */
  function setCookie(name, value, options) {
    var cookie = name + "=" + value + ";";
    options = options || {};
    if (options.expires) {
      cookie += "Expires=" + options.expires.toUTCString() + ";";
    }
    if (options.path) {
      cookie += "Path=" + options.path + ";";
    }
    if (options.domain) {
      cookie += "Domain=" + options.domain + ";";
    }
    document.cookie = cookie;
  }

  function splitCookie (cookie) {
    var parts = cookie.match(/([^=]+)(?:=([^;]*))?/);
    return parts ? parts.slice(1) : cookie;
  }

  /**
   * Get all cookies
   *
   * @public
   * @returns {Array} Returns the name and value of all available cookies
   */
  function getCookies() {
    if (!document.cookie) {
      return [];
    }
    var allCookies = [], cookie;
    var cookies = document.cookie.split(";");
    var i = 0, l = cookies.length;
    for (i;i < l; i++) {
      cookie = splitCookie(cookies[i]);
      allCookies.push({
        name: trim(cookie[0]),
        value: (cookie[1] && trim(cookie[1])) || null
      });
    }
    return allCookies;
  }

  /**
   * clear first instance of cookie
   *
   * @public
   * @param {String} name The cookie name
   * @param {Object} options Optionally set path or domain of cookie to be cleard
   * @returns {Boolean} Returns a boolean indicating whether the cookie was successfully cleard
   */
  function clearCookie(name, options) {
    var length = getCookies().length;
    options = options || {};
    options.expires = new Date(1);
    setCookie(name, "", options);
    return getCookies().length !== length;
  }

  /**
   * clear all instances of cookie
   *
   * @public
   * @param {String} name The cookie name
   * @returns {Boolean} Returns an array of objects containing the domain and path of any cleard cookies
   */
  function clearAll(name) {
    var d, p, cleard = [];
    var paths = getPaths(window.location.pathname);
    var domains = getDomains(window.location.hostname);

    if (clearCookie(name)) {
      return [{
        path: null,
        domain: null
      }];
    }

    // try deleting on all paths and domains, return the combination that actually works
    for (d = 0; d < domains.length; d++) {
      for (p = 0; p < paths.length; p++) {
        // track cleard cookies
        if (clearCookie(name, {
          path: paths[p],
          domain: domains[d]
        })) {
          cleard.push({
            domain: domains[d],
            path: paths[p]
          });
        }
      }
    }
    return cleard;
  }

  module.exports = {
    'get': getCookie,
    'set': setCookie,
    'cookies': getCookies,
    'clear': clearCookie,
    'clearAll': clearAll
  };

})();

});

define('cookieman', ['cookieman/cookieman'], function (main) { return main; });

define('base64int/index',['require','exports','module'],function (require, exports, module) {var base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

module.exports = {
  encode: function encode64(num) {
    return (prefix(num) + map(toBase(Math.abs(num), 64), function (pos) {
      return base64Chars.charAt(pos);
    }).join('')) || base64Chars.charAt(0);
  },
  decode: function decode64(base64) {
    return (prefix(base64) ? -1 : 1) * fromBase(map(base64.replace(/^-/, '').split(''), function (pos) {
      return base64Chars.indexOf(pos);
    }), 64);
  }
};

function fromBase(input, base) {
  var val = 0;
  for (var i = 0; i < input.length; i++) {
    val += Math.pow(base, (input.length - 1) - i) * input[i];
  }
  return val;
}

function prefix(num) {
  if (String(num).charAt(0) === '-') return '-'
  return ''
}

function toBase(value, outputBase) {
  var digits = [];
  while (value > 0) {
    var remainder = value % outputBase;
    digits.unshift(remainder);
    value = (value - remainder) / outputBase;
  }
  return digits;
}

function map(list, it) {
  var vals = [];
  for (var i = 0; i < list.length; i++) {
    vals.push(it(list[i], i));
  }
  return vals;
}

});

define('base64int', ['base64int/index'], function (main) { return main; });

define('etc.widget/lib/helpers',['require','exports','module'],function (require, exports, module) {module.exports = {
  forEach: forEach,
  map: map,
  lossy: lossy,
  every: every,
  size: size,
  isNumber: isNumber,
  isArray: isArray,
  debounce: debounce
};


function isArray(obj) {
  return obj && obj.constructor === Array;
}

function forEach(obj, it) {
  if (isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      it(obj[i], i);
    }
  } else {
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        it(obj[k], k);
      }
    }
  }
}

function map(obj, it) {
  var vals = [];
  for (var i = 0; i < obj.length; i++) {
    vals.push(it(obj[i], i));
  }
  return vals;
}

function lossy(compressor, value) {
  return compressor.decode(compressor.encode(value)) !== value;
}

function every(list, predicate) {
  var passes = true;
  forEach(list, function () {
    if (!predicate.apply(window, arguments)) {
      passes = false;
    }
  });
  return passes;
}

function size(list) {
  var i = 0;
  forEach(list, function () {
    i++;
  });
  return i;
}

function isNumber(val) {
  return isFinite(parseFloat(val));
}

function debounce(func, wait, immediate) {
  var args,
    result,
    thisArg,
    timeoutId;

  function delayed() {
    timeoutId = null;
    if (!immediate) {
      result = func.apply(thisArg, args);
    }
  }
  return function () {
    var isImmediate = immediate && !timeoutId;
    args = arguments;
    thisArg = this;

    clearTimeout(timeoutId);
    timeoutId = setTimeout(delayed, wait);

    if (isImmediate) {
      result = func.apply(thisArg, args);
    }
    return result;
  };
}
});

define('etc.widget/lib/encoders/_qb_se',['require','exports','module','base64int','../helpers','json'],function (require, exports, module) {var base64int = require("base64int");
var _ = require("../helpers");
var JSON = require("json"); // jshint ignore:line

/**********************************************************************
*  Side effects of compression
*  - will add attribute "e": 0
*
*  e.g.
*  {"1":{"t":1415210570031}} =>
*  {"1":{"e":0,"t":1415210570031}}
*
*  {"undefined":{"e":{},"t":1415210876496}} =>
*  {"0":{"e":0,"t":1415210876496}}
*
* - turns falsey values into zero
*
* e.g.
* {"undefined":{"t":1415210740553}} =>
* {"0":{"e":0,"t":1415210740553}}
*
*  - will turn value for attribute "e" into zero if object
*  {"undefined":{"e":{},"t":1415212134042}} =>
*  {"0":{"e":0,"t":1415212134042}}
*
***********************************************************************/

module.exports = {
  encoded: function (value) {
    return /^[0-9A-Za-z+\/]+:/.test(value);
  },
  canEncode: function (json) {
    var value;
    try {
      value = JSON.parse(json);
    } catch (e) {
      return false;
    }
    return _.every(value, function (v, k) {
      return _.isNumber(k) &&
        Number(k) >= 0 &&
        _.size(v) === 2 &&
        _.isNumber(v.e) &&
        _.isNumber(v.t) &&
        Number(v.e) >= 0 &&
        Number(v.t) >= 0;
    });
  },
  encode: function (value) {
    var valueList = [];
    _.forEach(JSON.parse(value), function (val, key) {
      valueList.push(
        base64int.encode(Number(key)) + ":" +
        base64int.encode(Number(val.e)) + "&" +
        base64int.encode(Number(val.t))
      );
    });
    return valueList.join("|");
  },
  decode: function (value) {
    var segments = {};
    var valueList = value.split("|");
    _.forEach(valueList, function (val) {
      var key = base64int.decode(val.match(/^[^:]+/)[0]);
      var vals = _.map(val.match(/[^:]+$/)[0].split("&"), function (n) {
        return base64int.decode(n);
      });
      segments[key] = {
        e: vals[0],
        t: vals[1]
      };
    });
    return JSON.stringify(segments);
  }
};

});

define('etc.widget/lib/encoders/qb_ss_status',['require','exports','module','base64int','../helpers','json'],function (require, exports, module) {var base64int = require("base64int");
var _ = require("../helpers");
var JSON = require("json"); // jshint ignore:line

/**********************************************************************
*  Side effects of compression
*  - will remove attribute "cg"
*  - assumes last value in array is always zero
*
*  e.g.
*  {"b":{"1500":[0.785, 45, 45, 1], "1700":[0.234, 70, 70, 2]}, "cg":0.324} =>
*  {"b":{"1500":[0.785, 45, 45, 0], "1700":[0.234, 70, 70, 0]}}
*
* - turns falsey values into zero
*
*  e.g.
*  {"b":{"undefined":[null, null, null, 0]}} =>
*  {"b":{"0":[0, 0, 0, 0]}}
*
* - will turn non numeric attributes into zero (removes attr c_id into 0)
*
*  e.g.
*  {"b":{"c_id":[0.4, "e_id", "tc_id", 0]}}
*  {"b":{"0":[0.4, 0, 0, 0]}}
*
* - second value duplicated into third value
***********************************************************************/

module.exports = {
  encoded: function (value) {
    return /^[0-9A-Za-z+\/]+:/.test(value);
  },
  canEncode: function (json) {
    var value;
    try {
      value = JSON.parse(json);
    } catch (e) {
      return false;
    }
    if (_.size(value) !== 1) {
      return false;
    }
    if ((typeof value.b !== "object") ||
      value.b instanceof Array ||
      (_.size(value.b) < 1)) {
      return false;
    }
    return _.every(value.b, function (v, k) {
      if (!_.isNumber(k) || (Number(k) < 0)) {
        return false;
      }
      if (!(v instanceof Array)) {
        return false;
      }
      if (_.size(v) !== 4) {
        return false;
      }
      if (!_.isNumber(v[0])) {
        return false;
      }
      if ((Number(v[0]) < 0) || ( Number(v[0]) > 1)) {
        return false;
      }
      if (!_.isNumber(v[1]) || Number(v[1] < 0)) {
        return false;
      }
      if (Number(v[1]) !== Number(v[2])) {
        return false;
      }
      if (v[3] !== 0) {
        return false;
      }
      return true;
    });
  },
  encode: function (value) {
    var experiments = [];
    var obj = JSON.parse(value).b;
    _.forEach(obj, function (val, key) {
      experiments.push(
        base64int.encode(Number(key)) + ":" +
        base64int.encode(Math.round(val[0] * 1000)) + "&" +
        base64int.encode(val[1])
      );
    });
    return experiments.join("|");
  },
  decode: function (value) {
    var obj = {};
    var experiments = value.split("|");
    _.forEach(experiments, function (experiments) {
      var key = base64int.decode(experiments.match(/^[^:]+/)[0]);
      var vals = experiments.match(/[^:]+$/)[0].split("&");
      var experimentId = base64int.decode(vals[1]);
      obj[key] = [
        base64int.decode(vals[0]) / 1000,
        experimentId,
        experimentId,
        0
      ];
    });
    return JSON.stringify({
      b: obj
    });
  }
};

});

define('etc.widget/lib/encoders/ss_opts',['require','exports','module','base64int','../helpers','json'],function (require, exports, module) {var base64int = require("base64int");
var _ = require("../helpers");
var JSON = require("json"); // jshint ignore:line

/**********************************************************************
*  Side effects of compression
*  - will remove attribute "other_property"
*  - will add attribute "times_activated_session"
*  - will add attributes "sc" and "scv" to the "global" key
*
*  e.g.
*  {
*    "1300":{"times_activated":1,"other_property":1},
*    "1600":{"times_activated":4,"other_property":1},
*    "1700":{"times_activated":2,"other_property":1},
*    "global":{"session_timer":123,"refresh_timer":123}
*   } =>
*  {
*    "1300":{"times_activated":1,"times_activated_session":0},
*    "1600":{"times_activated":4,"times_activated_session":0},
*    "1700":{"times_activated":2,"times_activated_session":0},
*    "global":{"session_timer":123,"refresh_timer":123,"sc":0,"svc":0}
*   }
*
***********************************************************************/

function positiveNumber(val) {
  return _.isNumber(val) && (Number(val) >= 0);
}

module.exports = {
  encoded: function (value) {
    return /^([0-9A-Za-z+\/]+|_g):/.test(value);
  },
  canEncode: function (json) {
    var value;
    try {
      value = JSON.parse(json);
    } catch (e) {
      return false;
    }
    if (_.size(value) < 1) {
      return false;
    }
    return _.every(value, function (v, k) {
      if (typeof v !== "object") {
        return false;
      }

      if (k === "global" && !positiveNumber(v["session_timer"])) {
        return false;
      }
      if (k === "global" && !positiveNumber(v["refresh_timer"])) {
        return false;
      }
      if (k === "global") {
        return true;
      }

      if (!_.isNumber(k) || (Number(k) < 0)) {
        return false;
      }

      return _.every(v, function (val, key) {
        if (!/^(close_time|close_duration|times_activated|times_activated_session)$/.test(key)) {
          return false;
        }
        if (!positiveNumber(val)) {
          return false;
        }
        return true;
      });
    });
  },
  encode: function (value) {
    var valueList = [];
    _.forEach(JSON.parse(value), function (variant, key) {
      var vals;
      if (key === "global") {
        vals = [
          base64int.encode(variant.session_timer),
          base64int.encode(variant.refresh_timer),
          base64int.encode(variant.sc),
          base64int.encode(variant.svc)
        ];
      } else {
        vals = [
          _.isNumber(variant.times_activated) ? base64int.encode(variant.times_activated) : "",
          _.isNumber(variant.times_activated_session) ? base64int.encode(variant.times_activated_session) : "",
          _.isNumber(variant.close_time) ? base64int.encode(variant.close_time) : "",
          _.isNumber(variant.close_duration) ? base64int.encode(variant.close_duration) : ""
        ];
      }
      valueList.push(
        (key === "global" ? "_g" : base64int.encode(Number(key))) +
        ":" +
        vals.join("&")
      );
    });
    return valueList.join("|");
  },
  decode: function (value) {
    var variants = {};
    var valueList = value.split("|");
    _.forEach(valueList, function (val) {
      var key = val.match(/^[^:]+/)[0];
      var vals = val.match(/[^:]+$/)[0].split("&");
      var variant;
      if (key === "_g") {
        key = "global";
        variant = {
          session_timer: base64int.decode(vals[0]),
          refresh_timer: base64int.decode(vals[1]),
          sc: base64int.decode(vals[2] || ""),
          svc: base64int.decode(vals[3] || "")
        };
      } else {
        variant = {};
        key = base64int.decode(key);
        if (vals[0] && vals[0] !== "") {
          variant.times_activated = base64int.decode(vals[0]);
        }
        if (vals[1] && vals[1] !== "") {
          variant.times_activated_session = base64int.decode(vals[1]);
        }
        if (vals[2] && vals[2] !== "") {
          variant.close_time = base64int.decode(vals[2]);
        }
        if (vals[3] && vals[3] !== "") {
          variant.close_duration = base64int.decode(vals[3]);
        }
      }
      variants[key] = variant;
    });
    return JSON.stringify(variants);
  }
};

});

define('etc.widget/lib/compressed_cookie',['require','exports','module','cookieman','./encoders/_qb_se','./encoders/qb_ss_status','./encoders/ss_opts'],function (require, exports, module) {var cookieman = require("cookieman");
var encoders = {
  _qb_se: require("./encoders/_qb_se"),
  qb_ss_status: require("./encoders/qb_ss_status"),
  ss_opts: require("./encoders/ss_opts")
};

function readEncodedCookie(name) {
  var cookie = cookieman.get(name);
  var value = cookie.length ? (cookie[0].value && unescape(cookie[0].value)) : null;
  if (value && encoders[name]) {
    if (encoders[name].encoded(value)) {
      // if cookie has a decoder and has been encoded, decode it
      return encoders[name].decode(value);
    }
  }
  return value;
}

function writeEncodedCookie(name, value, days, domain) {
  if (encoders[name] && encoders[name].canEncode(value)) {
    // if cookie has an encoder and encode it
    value = encoders[name].encode(value);
  } else {
    value = escape(value);
  }
  var options = {};
  if (days) {
    options.expires = new Date(new Date().valueOf() + (1000 * 60 * 60 * 24 * days));
  }
  if (domain) {
    options.domain = domain;
  }
  options.path = "/";
  return cookieman.set(name, value, options);
}

function readAllEncodedCookies(name) {
  var decoded = [];
  var value, decodable, cookies = cookieman.get(name);
  var i = 0, l = cookies.length;
  for (i = 0; i < l; i++) {
    value = unescape(cookies[i].value), decodable = false;
    if (encoders[name]) {
      if (encoders[name].encoded(value || "")) {
        decodable = true;
        decoded.push(encoders[name].decode(value));
      }
    }
    if (!decodable) {
      decoded.push(value);
    }
  }
  return decoded;
}

function api() {
  return {
    v1: {
      get: readEncodedCookie,
      encoders: encoders
    }
  };
}

module.exports = {
  readCookie: readEncodedCookie,
  writeCookie: writeEncodedCookie,
  readAllCookies: readAllEncodedCookies,
  api: api
};
});

define('etc.widget/lib/cookie',['require','exports','module','./compressed_cookie'],function (require, exports, module) {var compressedCookieLib = require("./compressed_cookie");

module.exports = {
  readCookie: compressedCookieLib.readCookie,
  readAllCookies: function (name) {
    var r, cookie, value, cookies, nameSearchString, i, ii, values;
    nameSearchString = name + "=";
    cookies = document.cookie.split(";");
    r = /^\s+|\s+$/g;
    values = [];
    for (i = 0, ii = cookies.length; i < ii; i += 1) {
      cookie = cookies[i].replace(r, "");
      if (cookie.indexOf(nameSearchString) === 0) {
        value = unescape(cookie.substring(nameSearchString.length));
        if (value.length > 0) {
          values.push(value);
        }
      }
    }
    return values;
  },
  writeCookie: function (name, value, days, domain) {
    var date, expires, cookie;
    if (days) {
      date = new Date();
      date.setTime(date.getTime() + (days * 86400000));
      expires = "; expires=" + date.toGMTString();
    } else {
      expires = "";
    }
    cookie = escape(name) + "=" + escape(value) + expires + "; path=/;";
    if (domain) {
      cookie += " domain=" + domain;
    }
    document.cookie = cookie;
  }
};

});

define('cookie_manager',['require','json','./etc.widget/lib/cookie','etc.widget/lib/compressed_cookie'],function (require) {
  var JSON = require('json')
  var cookie = require('./etc.widget/lib/cookie')
  var compressedCookieLib = require('etc.widget/lib/compressed_cookie')
  var cookieName = 'ss_opts'
  var CookieManager = (function () {
    return {
      api: function () {
        return compressedCookieLib.api()
      },
      read: function (variant, key) {
        return this.getVariant(variant)[key]
      },
      readGlobal: function (key) {
        return this.read('global', key)
      },
      readInt: function (variant, key) {
        var value = this.read(variant, key)
        try {
          value = parseInt(value, 10) || 0
        } catch (e) {
          value = 0
        }
        return value
      },
      write: function (variant, key, value) {
        var vals = this.getValues()
        var variantData = vals[variant] || (vals[variant] = {})
        variantData[key] = value

        var domain
        if (window._qb_ss && window._qb_ss[0]) {
          domain = window._qb_ss[0].domain
        }

        this.writeCookie(cookieName, '{}', -1)
        this.writeCookie(cookieName, '{}', -1, domain)
        this.writeCookie(cookieName, JSON.stringify(vals), 365, domain)
      },
      writeGlobal: function (key, value) {
        this.write('global', key, value)
      },
      getValues: function () {
        var vals = this.readCookie(cookieName)
        if (vals) {
          vals = JSON.parse(vals)
        } else {
          vals = {}
        }
        return vals
      },
      getVariant: function (variant) {
        var vals = this.getValues()
        return vals[variant] || (vals[variant] = {})
      },
      readCookie: cookie.readCookie,
      writeCookie: cookie.writeCookie
    }
  })()

  CookieManager.readCookie = compressedCookieLib.readCookie
  CookieManager.writeCookie = compressedCookieLib.writeCookie

  return CookieManager
})
;
define('data_util',['require','cookie_manager'],function (require) {
  var Cookie = require('cookie_manager')

  function poll (test, cb, iterator) {
    if (test()) {
      cb()
    } else {
      iterator = (iterator || 0) + 1
      setTimeout(function () {
        poll(test, cb, iterator)
      }, iterator * 50)
    }
  }

  return {
    visitorId: function (cb) {
      poll(function () {
        return Cookie.readCookie('_qubitTracker')
      }, function () {
        cb(Cookie.readCookie('_qubitTracker'))
      })
    },

    trackingId: function () {
      if (window._qb_ss && window._qb_ss.length > 0 && window._qb_ss[0].trackingId) {
        return window._qb_ss[0].trackingId
      } else {
        return window.location.hostname
      }
    },

    cookieDomain: function () {
      var domain
      if (window._qb_ss && window._qb_ss.length > 0) {
        domain = window._qb_ss[0].domain
      }
      return domain
    },

    protocol: function () {
      return document.location.protocol === 'https:' ? 'https://' : 'http://'
    },

    supportLocalStorage: function () {
      try {
        return 'localStorage' in window && window['localStorage'] !== null
      } catch (e) {
        return false
      }
    }
  }
})
;
define('orca',['require','config','mini_lodash','jquery','when','data_util','json'],function (require) {
  var config = require('config')
  var _ = require('mini_lodash')
  var $ = require('jquery')
  var when = require('when')
  var DataUtil = require('data_util')
  var JSON = require('json')

  var hour = 1000 * 60 * 60
  var day = 24 * hour

  var undef

  var defaults = {
    expiresInMs: 1 * day,
    VISITOR_KEY: '_q_visitor',
    TIMESTAMP_KEY: '_q_lookup_time'
  }

  function Orca (options) {
    this.options = _.extend({}, this.defaults, options)
  }

  // Result cache
  var promises = {}

  Orca.prototype.defaults = defaults

  Orca.prototype.now = function () {
    return new Date().getTime()
  }

  Orca.prototype.getItem = function (key) {
    var jsonObject = window.localStorage.getItem(key)
    if (jsonObject) {
      try {
        jsonObject = JSON.parse(jsonObject)
      } catch (e) {
        jsonObject = {}
      }
    } else {
      jsonObject = {}
    }
    return jsonObject
  }

  Orca.prototype.setItem = function (key, object) {
    window.localStorage.setItem(key, JSON.stringify(object))
  }

  Orca.prototype.createRequestUrl = function (options) {
    options = _.extend({}, this.options, options)
    var defer = when.defer()
    DataUtil.visitorId(function (visitorId) {
      var endpoint = options.endpoint
      defer.resolve([
        endpoint, '/',
        DataUtil.trackingId(), '/',
        visitorId,
        '?attr=', options.attr
      ].join(''))
    })
    return defer.promise
  }

  Orca.prototype.recordExpired = function (options) {
    options = _.extend({}, this.options, options)
    var lookupTime = this.getItem(options.TIMESTAMP_KEY)
    // record does not exists means expired
    if (!lookupTime.hasOwnProperty(options.attr)) {
      return true
    }

    var timePassedMs = this.now() - lookupTime[options.attr]
    return timePassedMs >= (options.expiresInMs)
  }

  Orca.prototype.updateRecordTime = function (options) {
    options = _.extend({}, this.options, options)
    var timeRecord = this.getItem(options.TIMESTAMP_KEY)
    timeRecord[options.attr] = this.now()
    this.setItem(options.TIMESTAMP_KEY, timeRecord)
  }

  /*
   *  Returns local history JSON object
   */
  Orca.prototype.getLocalHistory = function (options) {
    options = _.extend({}, this.options, options)
    return this.getItem(options.VISITOR_KEY)
  }

  Orca.prototype.resetLocalHistryByPath = function (history, options) {
    options = _.extend({}, this.options, options)
    var children = options.path.split('.')
    var i = 0
    var ii = children.length
    var currentNode = history

    for (i = 0; i < ii; i++) {
      if (currentNode.hasOwnProperty(children[i])) {
        if ((ii - i) === 1) {
          delete currentNode[children[i]]
          break
        }
        currentNode = currentNode[children[i]]
      } else {
        break
      }
    }
    return history
  }

  Orca.prototype.updateLocalHistory = function (objData, options) {
    options = _.extend({}, this.options, options)
    var history = this.getLocalHistory()
    // deep merge does not guarantee we receive latest update
    // an edge case would be local history has data, but remote tells
    // user has new data which is empty
    history = this.resetLocalHistryByPath(history, options)
    history = _.merge(history, objData)
    this.setItem(options.VISITOR_KEY, history)
  }

  Orca.prototype.getRemoteHistory = function (options) {
    options = _.extend({}, this.options, options)
    return this.createRequestUrl(options).then(function (url) {
      return $.when($.ajax({
        url: url,
        crossDomain: true,
        dataType: 'jsonp'
      }))
    })
  }

  Orca.prototype.getJsonValueByPath = function (nestedObject, path, defaultValue) {
    var children = path.split('.')
    var i = 0
    var ii = children.length
    var resultValue
    var currentNode = nestedObject

    for (i = 0; i < ii; i++) {
      if (currentNode.hasOwnProperty(children[i])) {
        currentNode = currentNode[children[i]]
        if ((ii - i) === 1) {
          resultValue = currentNode
          break
        }
      } else {
        resultValue = defaultValue === undef ? null : defaultValue
        break
      }
    }
    return resultValue
  }

  /*
   * Return speicified value for given JSON path in options
   * Otherwise return the full orca object
   */
  Orca.prototype.resolve = function (defer, historyObj, options) {
    options = _.extend({}, this.options, options)
    if (options.path) {
      defer.resolve(this.getJsonValueByPath(historyObj, options.path, options.defaultValue))
    } else {
      defer.resolve(historyObj)
    }
  }

  /*
   *  @options
   *    {
   *      attr: "the attributes for orca api",
   *            e.g. "numConversions"
   *      path: "path to the value to extract from"
   *            e.g. "0.numConversions",
   *      defaultValue: a fallback value to be returned in case the attribute is not found,
   *                    only used when combined with path. By default, the return value is null
   *                    in case the attribute is not found.
   *                    e.g. 0
   *      endpoint: "orca.qubitproducts.com/orca"
   *            Optional Orca base URL
   *      expiresInMs: 12131312
   *            Optional custom expiration time in million seconds
   *    }
   *
   *
   */
  Orca.prototype.lookup = function (options) {
    options.endpoint = options.endpoint || config.endpoints.orca
    options = _.extend({}, this.options, options)
    if (!promises) {
      promises = {}
    }
    if (!promises[options.endpoint]) {
      promises[options.endpoint] = {}
    }
    if (!promises[options.endpoint][options.attr]) {
      promises[options.endpoint][options.attr] = {}
    }
    if (!promises[options.endpoint][options.attr][options.path]) {
      promises[options.endpoint][options.attr][options.path] = this._lookup(options)
    }

    return promises[options.endpoint][options.attr][options.path]
  }

  Orca.prototype.clearCache = function () {
    promises = {}
  }

  Orca.prototype._lookup = function (options) {
    options = _.extend({}, this.options, options)
    var defer = when.defer()

    if (!DataUtil.supportLocalStorage()) {
      // Ensures return value is consistent using promise
      defer.reject()
      return defer.promise
    }

    var self = this
    if (self.recordExpired(options)) {
      // Not requested before, try request it
      self.getRemoteHistory(options).then(function (history) {
        self.updateRecordTime(options)
        self.updateLocalHistory(history, options)
        self.resolve(defer, history, options)
      }, function () { defer.reject() })
    } else {
      // Found history and it hasn't expired yet
      // Return history object even though the value could be empty
      var history = self.getLocalHistory(options)
      self.resolve(defer, history, options)
    }

    return defer.promise
  }

  return Orca
})
;
define('segmenter/segments/firstconversiondate',['require','orca'],function (require) {
  return function () {
    var Orca = require('orca')
    return (new Orca()).lookup({
      attr: 'firstConversionDate',
      path: '0.firstConversionDate'
    })
  }
})
;
define('segmenter/segments/firstpageviewdate',['require','orca'],function (require) {
  return function () {
    var Orca = require('orca')
    return (new Orca()).lookup({
      attr: 'firstPageViewDate',
      path: '0.firstPageViewDate'
    })
  }
})
;
define('segmenter/segments/lastconversiondate',['require','orca'],function (require) {
  return function () {
    var Orca = require('orca')
    return (new Orca()).lookup({
      attr: 'lastConversionDate',
      path: '0.lastConversionDate'
    })
  }
})
;
/**
  Example callback JSON
  {
   "geo": {
     "ip": "212.74.97.241",
     "country": "GB",
     "country_string": "united kingdom",
     "region": "25451",
     "region_string": "medway",
     "metro_area": "826027",
     "metro_area_string": "london/meridian",
     "city": "253766",
     "city_string": "chattenden",
     "latitude": "53.0041",
     "longitude": "0.4467"
    }
  }
*/

define('geolocation',['require','config','jquery','when','cookie_manager','data_util','json'],function (require) {
  var config = require('config')
  var $ = require('jquery')
  var when = require('when')
  var Cookie = require('cookie_manager')
  var DataUtil = require('data_util')
  var JSON = require('json')
  var cookieName = '_q_geo'
  var version = '2'

  function createUrl (baseUrl) {
    var defer = when.defer()
    DataUtil.visitorId(function (visitorId) {
      var trackingId = DataUtil.trackingId()
      defer.resolve(baseUrl + '?cid=' + visitorId + '&id=' + trackingId)
    })
    return defer.promise
  }

  function compressCookie (obj) {
    return [
      version,
      obj.ip,
      obj.country,
      obj.region,
      obj.metro_area,
      obj.city,
      obj.latitude,
      obj.longitude
    ]
  }

  function uncompressCookie (arrayObj) {
    // Force request current version with correct configuration
    var cookiedVersion = arrayObj[0]
    if (version !== cookiedVersion) {
      return null
    }

    return {
      version: arrayObj[0],
      ip: arrayObj[1],
      country: arrayObj[2],
      region: arrayObj[3],
      metro_area: arrayObj[4],
      city: arrayObj[5],
      latitude: arrayObj[6],
      longitude: arrayObj[7]
    }
  }

  function readGeoCookie () {
    var cookie = Cookie.readCookie(cookieName)
    if (cookie) {
      try {
        cookie = uncompressCookie(JSON.parse(cookie))
      } catch (e) {
        cookie = null
      }
    } else {
      cookie = null
    }
    return cookie
  }

  function writeGeoCookie (obj) {
    var domain = DataUtil.cookieDomain()
    var cookieText = JSON.stringify(compressCookie(obj))
    Cookie.writeCookie(cookieName, cookieText, 1, domain)
  }

  function resolve (d, obj, key) {
    if (key) {
      d.resolve(obj[key])
    } else {
      d.resolve(obj)
    }
  }

  function getGeolocation (key, baseUrl) {
    var defer = when.defer()
    var geoInfo = readGeoCookie()
    baseUrl = baseUrl || '//orca.qubitproducts.com/ns'

    function callmemaybe (response) {
      if (response.geo) {
        geoInfo = response.geo
        writeGeoCookie(geoInfo)
        resolve(defer, geoInfo, key)
      }
    }

    if (geoInfo) {
      resolve(defer, geoInfo, key)
    } else {
      createUrl(baseUrl).then(function (url) {
        $.ajax({
          url: url,
          crossDomain: true,
          dataType: 'jsonp',
          success: callmemaybe,
          error: function () {
            defer.reject()
          }
        })
      })
    }

    return defer.promise
  }

  var clearGeoCache
  var geoWrapper
  geoWrapper = (function () {
    var promises = {}

    clearGeoCache = function () { promises = {} }

    return function (key, baseUrl) {
      baseUrl = baseUrl || config.endpoints.geolocation
      if (!promises[baseUrl]) {
        promises[baseUrl] = {}
      }
      if (typeof promises[baseUrl][key] === 'undefined') {
        promises[baseUrl][key] = getGeolocation(key, baseUrl)
      }
      return promises[baseUrl][key]
    }
  })()
  geoWrapper.clearCache = clearGeoCache
  return geoWrapper
})
;
define('segmenter/segments/lastgeolocation',['require','geolocation'],function (require) {
  return function () {
    return require('geolocation')('country')
  }
})
;
define('segmenter/segments/lastgeolocationdetail.city',['geolocation'],function () {
  return function () {
    return require('geolocation')('city')
  }
})
;
define('segmenter/segments/lastgeolocationdetail.metro_area',['require','geolocation'],function (require) {
  return function () {
    return require('geolocation')('metro_area')
  }
})
;
define('segmenter/segments/lastgeolocationdetail.region',['geolocation'],function () {
  return function () {
    return require('geolocation')('region')
  }
})
;
define('segmenter/segments/lastpageviewdate',['require','orca'],function (require) {
  return function () {
    var Orca = require('orca')
    return (new Orca()).lookup({
      attr: 'lastPageViewDate',
      path: '0.lastPageViewDate'
    })
  }
})
;
define('segmenter/lib/browser_string_search',[],function () {
  return function (data, navigator) {
    for (var i = 0; i < data.length; i++) {
      var dataString = data[i].string
      var userAgent = navigator ? navigator.userAgent : window.navigator.userAgent
      dataString = dataString || userAgent
      dataString = dataString.toLowerCase()
      var dataProp = data[i].prop
      if (dataString) {
        var subStrings = data[i].subString.split(',')
        var j
        for (j = 0; j < subStrings.length; j++) {
          if (dataString.indexOf(subStrings[j].toLowerCase()) !== -1) {
            return data[i].identity
          }
        }
      } else if (dataProp) {
        return data[i].identity
      }
    }
  }
})
;
define('segmenter/segments/lastuserwebagent.browser',['require','segmenter/lib/browser_string_search'],function (require) {
  var stringSearch = require('segmenter/lib/browser_string_search')
  return function () {
    var BrowserDetect = {
      init: function () {
        this.browser = stringSearch(this.dataBrowser) || 'unknown'
      },
      dataBrowser: [{
        subString: 'Silk-Accelerated',
        identity: 'Silk'
      }, {
        subString: 'Googlebot,baiduspider,Google Web Preview,BingPreview',
        identity: 'robot/spider'
      }, {
        subString: 'Camino',
        identity: 'Camino'
      }, {
        subString: 'Opera',
        identity: 'Opera'
      }, {
        subString: 'IEMobile',
        identity: 'IE Mobile'
      }, {
        subString: 'MSIE',
        identity: 'Internet Explorer'
      }, {
        subString: 'Chrome',
        identity: 'Chrome'
      }, {
        subString: 'OmniWeb',
        versionSearch: 'OmniWeb/',
        identity: 'OmniWeb'
      }, {
        subString: 'CriOS,CrMo',
        identity: 'Chrome Mobile'
      }, {
        subString: 'Safari',
        identity: 'Safari'
      }, {
        subString: 'Flock',
        identity: 'Flock'
      }, {
        string: window.navigator.vendor,
        subString: 'iCab',
        identity: 'iCab'
      }, {
        subString: 'Konqueror',
        identity: 'Konqueror'
      }, {
        string: window.navigator.vendor,
        subString: 'KDE',
        identity: 'Konqueror'
      }, {
        subString: 'Firefox',
        identity: 'Firefox'
      }, {
        subString: 'Netscape',
        identity: 'Netscape'
      }, {
        subString: 'AppleWebKit',
        identity: 'Apple WebKit'
      }, {
        subString: 'Gecko,Mozilla',
        identity: 'Mozilla'
      }]
    }
    BrowserDetect.init()

    return BrowserDetect.browser === null ? null : BrowserDetect.browser.toLowerCase()
  }
})
;
define('segmenter/segments/lastuserwebagent.browser_version',[],function () {
  return function (nav) {
    nav = window.__karma__ ? (nav || navigator) : navigator

    var ua = nav.userAgent
    var match = ua.match(/(opera|chrome|mobile.*safari|trident|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i)

    var temp
    if (match && (temp = ua.match(/version\/([\.\d]+)/i)) !== null) {
      match[2] = temp[1]
    }

    if (match && match[1].toLowerCase().indexOf('trident') > -1 && (temp = ua.match(/rv\:([\.\d]+)/i)) !== null) {
      match[2] = temp[1]
    }

    if (!match) {
      match = [ua, nav.appName, nav.appVersion]
    }

    var name = match[1].toLowerCase()
      .replace('msie', 'internet explorer')
      .replace('trident', 'internet explorer')

    // this is to rename "mobile/9B206 safari" to "mobile safari"
    if (name.indexOf('mobile') === 0 && name.indexOf('safari') > -1) {
      name = 'mobile safari'
    }

    var version = match[2].split('.').slice(0, 2).join('.')

    return name + ' ' + version
  }
})
;
define('segmenter/segments/lastuserwebagent.device_type',['require','segmenter/lib/browser_string_search'],function (require) {
  var stringSearch = require('segmenter/lib/browser_string_search')

  return function (nav) {
    var BrowserDetect = {
      init: function () {
        nav = window.__karma__ ? (nav || window.navigator) : window.navigator
        this.browser = stringSearch(this.dataBrowser, nav) || 'unknown'
      },

      dataBrowser: [{
        subString: 'Slurp,Baiduspider,Googlebot,Seznam,masking-agent,CrOS',
        identity: 'unknown'
      }, {
        subString: 'GoogleTV',
        identity: 'digital media receiver'
      }, {
        subString: 'NintendoBrowser,PlayStation',
        identity: 'Game Console'
      }, {
        subString: 'WOW64,IBIS,Macintosh,Linux i686,Windows NT,Linux Mint,Linux Next',
        identity: 'computer'
      }, {
        subString: 'iPad,Opera,Tab,TouchPad,Nexus 7,Nexus 10,' +
          'GT-N,Pad,GT-P,IdeaTab,SM-T,HP Slate,Xoom,Aurora-II,' +
          'ME301T,A1-810,A1-811,NookHD,PMP5880D,QUANTUM7,Kindle Fire,' +
          'KFTT,KFOT,KFJWI,KFJWA,KFSOWI,KFTHWI,KFTHWA,KFAPWI,KFAPWA,Silk,' +
          'SGP3,Nook HD,Transformer,AT300,COBALT,MOMO,Sweet M,ARCHOS,' +
          'NOOK,NABI2,MZ60,Vega,Slider,MID7,Streak,LePanII,HTC_Flyer,' +
          'JRO03H,BNTV400,A500,KFTT Build,M805,POM727MC,cm_tenderloin',
        identity: 'tablet'
      }, {
        subString: 'iPhone,iPod,iOS,IEMobile,Mobile,Opera Mobi',
        identity: 'mobile'
      }, {
        subString: '',
        identity: 'computer'
      }]
    }

    BrowserDetect.init()
    return BrowserDetect.browser === null ? null : BrowserDetect.browser.toLowerCase()
  }
})
;
define('segmenter/segments/numconversions',['require','orca'],function (require) {
  return function () {
    var Orca = require('orca')
    return (new Orca()).lookup({
      attr: 'numConversions',
      path: '0.numConversions',
      defaultValue: 0
    })
  }
})
;
define('segmenter/segments/pageviews.entrance.referrerdetails.search_keywords',[],function () {
  return function () {
    try {
      var q = decodeURIComponent((new RegExp('[?|&]q=' + '([^&;]+?)(&|#|;|$)').exec(document.referrer) ||
        [undefined, ''])[1].replace(/\+/g, '%20').replace('/', '')) || ''
      return q.toLowerCase()
    } catch (e) {
      return ''
    }
  }
})
;
define('segmenter/segments/pageviews.entrance.referrertype',[],function () {
  return function () {
    var referrer = document.referrer
    var url = document.location.href
    var matches = function (r) {
      if (r && r.length > 0) {
        return true
      }
      return false
    }

    var referrerMatch = function (pattern) {
      return matches(referrer.match(pattern))
    }

    var urlMatch = function (pattern) {
      return matches(url.match(pattern))
    }

    var seo = referrerMatch(/^(?![^\?]*(https?:\/\/)?(mail|messag)).*/) ||
      referrerMatch(/(http:\/\/)?(www\.)?search\..*/) ||
      referrerMatch(/https?:\/\/([\-a-z]+\.search-results)\.com.*/) ||
      referrerMatch(/https?:\/\/(yourbestsearch)\.net.*/) ||
      referrerMatch(/https?:\/\/www\.(k9safesearch)\.com.*/) ||
      referrerMatch(/https?:\/\/(optu\.search-help)\.net.*/) ||
      referrerMatch(/https?:\/\/(www.)?(suche\.(t-online|web))\.de.*/) ||
      referrerMatch(/https?:\/\/www\.(t-mobile[\-a-z\/\.]+)\/search.*/) ||
      referrerMatch(/https?:\/\/www\.(talktalk)\.co\.uk\/search.*/) ||
      referrerMatch(/https?:\/\/(isearch\.(babylon|avg))\.com.* /) ||
      referrerMatch(/https?:\/\/(search(completion|ya))\.com.*/) ||
      referrerMatch(/https?:\/\/(advancedsearch\d\.virginmedia)\.com.*/) ||
      referrerMatch(/https?:\/\/(www.)?google.*/) ||
      referrerMatch(/https?:\/\/mybroadband.three.co.uk\/[^?#]*\/search_results.html.*/)

    // email
    if (urlMatch(/.*utm_medium=e-?mail.*/) || referrerMatch(/[^?]*mail\.(aol|live|yahoo)\.com.*/) ||
      referrerMatch(/[^?]mail\.yahoo\.net.*/) || referrerMatch(/.*\?mail=.*/) ||
      referrerMatch(/[^?]*(e|fs)mail\d\d\.(orange)\.co\.uk.*/) || referrerMatch(/https?:\/\/(webmail).*/) ||
      referrerMatch(/[^?]*m\.(yahoo)\.com\/[a-z]+\/[a-z]+-mail\/.*/) ||
      referrerMatch(/https?:\/\/(messagingsuite\.(orange)|messagerie(pro|-\d{1,2})?\.(\w+))\..*/) ||
      referrerMatch(/https?:\/\/[a-z0-9]{6}\d{4}\.(outlook)\.com\/.*/) ||
      referrerMatch(/https?:\/\/posta\d\d?[a-z]\.mailbeta\.(libero)\.it.*/) ||
      referrerMatch(/https?:\/\/[mw]\d+\.mail\.(qq)\.com.*/) ||
      referrerMatch(/https?:\/\/(mail(-attachment|er|box[a-z]*|\d[a-z0-9]*)?)\.[\-a-z0-9\.]+\/.*/) ||
      referrerMatch(/https?:\/\/(www\.)?(email\d{0,3})\.[\-a-z0-9\.]+\/.*/) || urlMatch(/.*INT_[A-Z]+_EM.*/) ||
      urlMatch(/.*s_emcid.*/)
    ) {
      return 'email'
    }

    // vertical search
    if (urlMatch(/.*utm_medium=(cse|vertical_search|comparison-?shopping).*/) ||
      referrerMatch(/.*google.*productsearch.*/) ||
      referrerMatch(/.*yell\.com.*/) || referrerMatch(/.*(shopzilla).*/) ||
      urlMatch(/.*[\?|&]s_pccid=.*/)) {
      return 'vertical search'
    }

    // direct
    if (referrerMatch(/^$/) && urlMatch(/.+/) && !urlMatch(/.*gclid.*/) &&
      !urlMatch(/.*utm_source=.*/) && !urlMatch(/.*s_kenid=.*/) && !urlMatch(/.*bfdqbt=.*/) &&
      !urlMatch(/.*s_dscid=.*/) &&
      !urlMatch(/.*[\?|&]source=[0-9]*.*/)) {
      return 'direct'
    }

    // sem paid search
    if ((urlMatch(/.*utm_medium=(cpc|ppc|sem|paid_search).*/) ||
      (urlMatch(/.*gclid=.*/) && referrerMatch(/.*(google|bing|yahoo|ask)\..*/)) ||
      (urlMatch(/.*gclid=.*/) && document.referrer === '') ||
      urlMatch(/.*s_kenid=.*/) || urlMatch(/.*s_kwcid.*/) ||
      referrerMatch(/https?:\/\/[a-z\.]*google(adservices)?.*(\.[a-z]{2})?(\/(m|hws))?\/((pagead\/)?aclk|uds\/afs)\?.*/)) &&
      !referrerMatch(/.*chatzum\.com.*/)) {
      return 'sem'
    }

    // display
    if ((urlMatch(/.*[&\?]gclid=.*/) && !referrerMatch(/.*(google|bing|yahoo|ask)\..*/) && document.referrer !== '') ||
      urlMatch(/.*utm_medium=(display|banner|Display|retargeting).*/) ||
      referrerMatch(/[^?]*\.(criteo)\.(com|net)\/.*/) ||
      referrerMatch(/[^?]*\.(struq)\.(com|net)\/.*/) ||
      urlMatch(/.*utm_source=(struq).*/) ||
      referrerMatch(/http:\/\/[a-z\.]+\.(doubleclick)\..*/) ||
      referrerMatch(/.*utm_source=criteo.*/) ||
      referrerMatch(/.*utm_source=banner.*/) ||
      referrerMatch(/.*doubleclick.net.*/) ||
      urlMatch(/.*[&\?]s_dscid=.*/)) {
      return 'display'
    }

    // affiliates
    if (urlMatch(/.*utm_medium=affiliate.*/) || urlMatch(/.*utm_source=awin.*/) ||
      referrerMatch(/https?:\/\/(?!www)([^\/]+)\.polyvore.com\/.*/) ||
      referrerMatch(/http:\/\/[^\/]+\.shopstyle\..*/) ||
      referrerMatch(/.*(shopping-time|shoerazzi|leblogdebetty|hotukdeals.com|ipad-stock|offeroftheday|lyst|upscalehype|studentbeans|commeuncamion|collegefashion|promocodefor|easyfundraising|discountvouchers|money.co.uk|quidco|myvouchercodes|coolspotters|polyvore|rstyle|vouchercodes).*/) ||
      urlMatch(/.*[&\?]source=[0-9]*.*/)) {
      return 'affiliate'
    }
    var social_sites = referrerMatch(/http(s)?:\/\/.*(facebook|pinterest|vk|tumblr|reddit|youtube|blogspot|squidoo|odnoklassniki|vk\.com).*/)
    // social
    if (!referrerMatch(/.*(bt\.com).*/) && !referrerMatch(/.*google.*/) &&
      (urlMatch(/.*utm_medium=social.*/) || social_sites ||
      referrerMatch(/.*[&\?]eid=[^=]{1,100}.*/) ||
      referrerMatch(/.*t\.co.*/))) {
      return 'social'
    }

    // organic search, seo
    if (seo && !social_sites) {
      return 'seo'
    }

    return 'other'
  }
})
;
define('segmenter/segments/pageviews.entrance.referrerurl.url',[],function () {
  return function () {
    return document.referrer
  }
})
;
define('segmenter/segments/pageviews.sessionnumber',['require','cookie_manager','json'],function (require) {
  return function () {
    var cookie = require('cookie_manager')
    var JSON = require('json')
    var sc = cookie.readCookie('_qst')
    try {
      if (sc) {
        sc = JSON.parse(sc)
        return sc[0] >= sc[1] ? sc[0] : sc[1]
      }
    } catch (e) {
      return null
    }
  }
})
;
define('segmenter/segments/pageviews.url',[],function () {
  return function () {
    return document.location.href
  }
})
;
define('segmenter/segments/totalconversionvalue.gbp',['require','orca'],function (require) {
  return function () {
    var Orca = require('orca')
    return (new Orca()).lookup({
      attr: 'totalConversionValueGBP',
      path: '0.totalConversionValueGBP'
    })
  }
})
;
define('segmenter/segments/totalconversionvalue',['require','orca'],function (require) {
  return function () {
    var Orca = require('orca')
    return (new Orca()).lookup({
      attr: 'totalConversionValueBASE',
      path: '0.totalConversionValueBASE'
    })
  }
})
;
define('segmenter/segments/totalpagenum',['require','orca'],function (require) {
  return function () {
    var Orca = require('orca')
    return (new Orca()).lookup({
      attr: 'numPageViews',
      path: '0.numPageViews'
    })
  }
})
;
define('segmenter/segments/custom_javascript',[],function () {
  return function () {
    // custom_javascript is special
    // there's no value we need to compare against
    // but we need this module so that the segment_one function
    // handles the custom_javascript filter
  }
})
;
define('segmenter/segments/uv',['require','mini_lodash'],function (require) {
  var _ = require('mini_lodash')

  function attr (object, path) {
    return _.reduce(path.split('.'), function (memo, val) {
      return (memo && memo[val])
    }, object)
  }

  return function (path) {
    return attr(window, path.replace('pageviews.customvalues.uv', 'universal_variable'))
  }
})
;
/**
 * Returns the value of a segment (e.g. the value of numconversions, or lastgeolocation)
 */
define('segmenter/lib/get_segment_value',['require','../segments/firstconversiondate','../segments/firstpageviewdate','../segments/lastconversiondate','../segments/lastgeolocation','../segments/lastgeolocationdetail.city','../segments/lastgeolocationdetail.metro_area','../segments/lastgeolocationdetail.region','../segments/lastpageviewdate','../segments/lastuserwebagent.browser','../segments/lastuserwebagent.browser_version','../segments/lastuserwebagent.device_type','../segments/numconversions','../segments/pageviews.entrance.referrerdetails.search_keywords','../segments/pageviews.entrance.referrertype','../segments/pageviews.entrance.referrerurl.url','../segments/pageviews.sessionnumber','../segments/pageviews.url','../segments/totalconversionvalue.gbp','../segments/totalconversionvalue','../segments/totalpagenum','../segments/custom_javascript','../segments/uv'],function (require) {
  // list them out to build them all into the output script
  require('../segments/firstconversiondate')
  require('../segments/firstpageviewdate')
  require('../segments/lastconversiondate')
  require('../segments/lastgeolocation')
  require('../segments/lastgeolocationdetail.city')
  require('../segments/lastgeolocationdetail.metro_area')
  require('../segments/lastgeolocationdetail.region')
  require('../segments/lastpageviewdate')
  require('../segments/lastuserwebagent.browser')
  require('../segments/lastuserwebagent.browser_version')
  require('../segments/lastuserwebagent.device_type')
  require('../segments/numconversions')
  require('../segments/pageviews.entrance.referrerdetails.search_keywords')
  require('../segments/pageviews.entrance.referrertype')
  require('../segments/pageviews.entrance.referrerurl.url')
  require('../segments/pageviews.sessionnumber')
  require('../segments/pageviews.url')
  require('../segments/totalconversionvalue.gbp')
  require('../segments/totalconversionvalue')
  require('../segments/totalpagenum')
  require('../segments/custom_javascript')

  function isUV (path) {
    return path.indexOf('pageviews.customvalues.uv') === 0
  }

  var cache = {}

  return function (path) {
    // don't cache UV segments, since it's cheap to look them up and the value
    // depends on the path
    if (isUV(path)) {
      return require('../segments/uv')(path)
    }

    if (!cache[path]) {
      cache[path] = require('../segments/' + path)()
    }

    return cache[path]
  }
})
;
/**
 * Use this module to fetch values for all of the segments. Provide paths of the segments
 * and get back an object with values of those segments.
 */
define('segmenter/fetch_segments',['require','mini_lodash','when_map','./lib/get_segment_value'],function (require) {
  var _ = require('mini_lodash')
  var allKeys = require('when_map')
  var getSegmentValue = require('./lib/get_segment_value')
  return function fetchSegments (paths) {
    var segmentValues = _.reduce(paths, function (memo, path) {
      memo[path] = getSegmentValue(path)
      return memo
    }, {})
    return allKeys(segmentValues)
  }
})
;
define('match_condition',['mini_lodash'],function () {
  var _ = require('mini_lodash')

  function includes (str, substr) {
    return _.isString(str) && str.indexOf(substr) > -1
  }
  function arr (v) {
    return _.isArray(v) ? v.slice(0) : [v]
  }
  function lowerCase (arr) {
    return _.map(arr, function (v) {
      return _.isString(v) ? v.toLowerCase() : v
    })
  }

  return function (condition, value) {
    // clone - don't mutate
    // normalize into array of lowercase strings or other values
    var op = condition.op
    var conditionValues = lowerCase(arr(condition.value))
    var actualValues = lowerCase(arr(value))

    function allPermutations (condition) {
      return _.all(conditionValues, function (cv) {
        return _.all(actualValues, function (av) {
          return condition(cv, av)
        })
      })
    }
    function anyPermutation (condition) {
      return _.any(conditionValues, function (cv) {
        return _.any(actualValues, function (av) {
          return condition(cv, av)
        })
      })
    }

    switch (op) {
      case 'eq':
        return anyPermutation(function (cv, av) { return av === cv })
      case 'neq':
        return allPermutations(function (cv, av) { return av !== cv })
      case 'gt':
        return anyPermutation(function (cv, av) { return av > cv })
      case 'lt':
        return anyPermutation(function (cv, av) { return av < cv })
      case 'in':
        return anyPermutation(function (cv, av) { return includes(av, cv) })
      case 'nin':
        return allPermutations(function (cv, av) { return !includes(av, cv) })
      case 'regex':
        return anyPermutation(function (cv, av) { return (new RegExp(cv).test(av)) })
      default:
        return false
    }
  }
})
;
/**
 * Match a filter {key,type,op,value} against a value. Look at the filter.type and filter.key to
 * decide what matcher to use.
 */
define('segmenter/match_condition',['match_condition'],function () {
  var matchCondition = require('match_condition')

  function evaluateCode (condition) {
    if (condition.value) {
      // IMPORTANT this needs to be evaled with global code in scope
      // because custom segmentation code is referencing things from the global code
      return window.eval('(function () { var fn = ' + condition.value + '; return fn(); })();')
    } else {
      return true
    }
  }

  return function (condition, value) {
    switch (condition.type) {
      case 'string':
      case 'number':
      case 'date':
      case 'boolean':
        return matchCondition(condition, value)
      case 'code':
        return evaluateCode(condition)
    }
  }
})
;
define('segment',['require','mini_lodash','logger','segmenter/fetch_segments','segmenter/match_condition'],function (require) {
  var _ = require('mini_lodash')
  var logger = require('logger')
  var fetchSegments = require('segmenter/fetch_segments')
  var matchCondition = require('segmenter/match_condition')

  return function (experimentId, segmentFilters) {
    function log () {
      logger.logExperiment(experimentId, arguments)
    }
    function logFilter (filter, value, matches) {
      log('segment filter:', JSON.stringify(filter), 'value:', value, 'matches?', matches)
    }

    log('segmenting')
    return fetchSegments(_.pluck(segmentFilters, 'key')).then(function (segmentValues) {
      return _.every(segmentFilters, function (filter) {
        var matches = matchCondition(filter, segmentValues[filter.key])
        logFilter(filter, segmentValues[filter.key], matches)
        return matches
      })
    }).then(function (matches) {
      if (matches) {
        log('user is in the segment')
      } else {
        log('user is not in the segment')
      }
      return matches
    }).otherwise(function (err) {
      log('segmentation errored', err)
    })
  }
})
;
define('evaluate_execution',['require','exports','module'],function (require, exports, module) {module.exports = function evaluateExecution (code, options) {
  try {
    return eval('var fn = ' + code + '; fn(options)') // eslint-disable-line no-eval
  } catch (err) {
    if (window._ss_debug && window.console && window.console.error) {
      window.console.error('Execution failed', err)
    }
    // rethrow so that etc.js catches this failed execeution and pings the error
    throw err
  }
}

});

define('events',['require','mini_lodash'],function (require) {
  var _ = require('mini_lodash')
  var array = []
  var slice = array.slice
  var eventSplitter = /\s+/

  var eventsApi = function (obj, action, name, rest) {
    if (!name) return true
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest))
      }
    } else if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter)
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest))
      }
    } else {
      return true
    }
  }

  var triggerEvents = function (events, args) {
    var ev
    var i = -1
    var l = events.length
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx)
        return
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0])
        return
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0], args[1])
        return
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, args[0], args[1], args[2])
        return
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args)
    }
  }

  var Events = {
    on: function (name, callback, context) {
      if (!(eventsApi(this, 'on', name, [callback, context]) && callback)) return this
      this._events || (this._events = {})
      var list = this._events[name] || (this._events[name] = [])
      list.push({callback: callback, context: context, ctx: context || this})
      return this
    },
    off: function (name, callback, context) {
      var list, ev, events, names, i, l, j, k
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this
      if (!name && !callback && !context) {
        this._events = {}
        return this
      }

      names = name ? [name] : _.keys(this._events)
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i]
        list = this._events[name]
        if (list) {
          events = []
          if (callback || context) {
            for (j = 0, k = list.length; j < k; j++) {
              ev = list[j]
              if ((callback && callback !== ev.callback &&
                callback !== ev.callback._callback) ||
                (context && context !== ev.context)) {
                events.push(ev)
              }
            }
          }
          this._events[name] = events
        }
      }

      return this
    },
    trigger: function (name) {
      if (!this._events) return this
      var args = slice.call(arguments, 1)
      if (!eventsApi(this, 'trigger', name, args)) return this
      var events = this._events[name]
      var allEvents = this._events.all
      if (events) triggerEvents(events, args)
      if (allEvents) triggerEvents(allEvents, arguments)
      return this
    }
  }

  return Events
})
;
define('visitor',['require','cookie_manager'],function (require) {
  var cookieManager = require('cookie_manager')

  // session duration in minutes
  var SESSION_DURATION = 30

  /**
   * We store the following in the ss_opts cookie - global key
   *
   * session_timer - the time the current session started
   * refresh_timer - the time last view happend
   * sc - session count
   * svc - view count within the current session
   */

  var Visitor = {
    update: function () {
      var now = new Date().getTime()
      var firstViewEver = false

      // First of all, initialize all the values if this is the first view ever
      if (get('sc') === 0) {
        set('sc', getQtrackerSessionCount())
      }
      if (get('svc') === 0) {
        set('svc', getQtrackerSessionViewCount())
      }
      if (!get('refresh_timer')) {
        firstViewEver = true
        set('session_timer', now)
        set('refresh_timer', now)
      }

      // If the last view was over half an hour ago, we start a new session timer
      if ((now - get('refresh_timer')) > SESSION_DURATION * 60 * 1000) {
        set('session_timer', now)
        set('sc', Visitor.getSessionCount() + 1)
        set('svc', 1)
      } else {
        if (!firstViewEver) {
          set('svc', Visitor.getSessionViewCount() + 1)
        }
      }

      // update refresh timer every time
      set('refresh_timer', now)
    },
    getSessionCount: function () {
      return get('sc')
    },
    getSessionViewCount: function () {
      return get('svc')
    },
    getTimeInSession: function () {
      var now = (new Date()).getTime()
      var sessionTimer = get('session_timer') || now
      return now - sessionTimer
    }
  }

  function set (keyName, value) {
    cookieManager.writeGlobal(keyName, value)
  }

  function get (keyName) {
    var value = cookieManager.readGlobal(keyName)
    return value !== undefined ? Number(value) : 0
  }

  /**
   * This is used to ease in the transition
   * to this new system where we keep our own
   * session/view counts. In the future, we
   * could remove this code.
   */
  function getQtrackerSessionCount () {
    var countCookie = cookieManager.readCookie('_qst')

    if (!countCookie) {
      return 1
    }

    try {
      countCookie = JSON.parse(countCookie)
      var sc = countCookie[0] >= countCookie[1] ? countCookie[0] : countCookie[1]
      // qtracker hasn't loaded on this page yet, this number of ouf of date
      if (!window.__pageViewId__) {
        if (isNewQtrackerSession()) {
          sc += 1
        }
      }
      return sc
    } catch (e) {
      // something borked
      return 1
    }
  }

  function getQtrackerSessionViewCount () {
    try {
      var trackingId = window._qb_ss[0].trackingId
      var pageViewCount = parseInt(cookieManager.readCookie('_qPageNum_' + trackingId), 10)

      if (!pageViewCount) {
        return 1
      }

      if (window.__pageViewId__) {
        return pageViewCount + 1
      }
      if (isNewQtrackerSession()) {
        return 1
      } else {
        return pageViewCount + 2
      }
    } catch (e) {
      return 1
    }
  }

  function isNewQtrackerSession () {
    var s = cookieManager.readCookie('_qsst')
    var ms = SESSION_DURATION * 60 * 1000
    var isNewSession = !s || (parseInt(s, 10) < (new Date().getTime() - ms))
    return isNewSession
  }

  return Visitor
})
;
define('exit_checker',['require'],function (require) {
  return function (options) {
    var f
    f = {
      defaultConfig: {
        debugMode: false,
        topHeight: 150,
        moveQueueDepth: 2,
        moveDelay: 500,
        moveVel: 500,
        leftGap: 10,
        attachTime: 0.5 * 1000,
        returnTime: 1000,
        eventInterval: 100,
        showProb: 1.0
      },
      start: function () {
        if (f.isBadBrowser(navigator.userAgent, window)) {
          return
        }
        f.startTime = new Date().getTime()
        f.setConfig()
        f.initVars()
        f.waitTillReady()
      },
      isBadBrowser: function (agent, winObj) {
        return (agent.indexOf('iPad') >= 0) ||
        (agent.indexOf('iPhone') >= 0) ||
        (agent.indexOf('android') >= 0) ||
        (agent.indexOf('Android') >= 0) ||
        (agent.indexOf('Mobile') >= 0) ||
        (agent.indexOf('mobile') >= 0) ||
        (agent.indexOf('MSIE 6') >= 0) ||
        (!winObj.sessionStorage)
      },
      waitTillReady: function () {
        if (document.body && document.getElementById) {
          f.onReady()
        } else {
          setTimeout(f.waitTillReady, 100)
        }
      },
      onReady: function () {
        if (f.opts.attachTime) {
          setTimeout(f.attachEvents, f.opts.attachTime)
        } else {
          f.attachEvents()
        }
      },
      setConfig: function () {
        var x
        var config = options || {}
        f.opts = {}
        for (x in f.defaultConfig) {
          if (f.defaultConfig.hasOwnProperty(x)) {
            f.opts[x] = f.defaultConfig[x]
          }
        }
        f.deepMerge(f.opts, config)
      },
      deepMerge: function (target, source) {
        var key, original, next
        for (key in source) {
          if (source.hasOwnProperty(key)) {
            original = target[key]
            next = source[key]
            if (original && next && typeof next === 'object') {
              f.deepMerge(original, next)
            } else {
              target[key] = next
            }
          }
        }
      },
      setDefault: function (key, value) {
        if (f.opts[key] === undefined) {
          f.opts[key] = value
        }
      },
      initVars: function () {
        f.lastMoves = []
      },
      attachEvents: function () {
        // var field = f.createListenField()
        if (f.opts.debugMode && window.console) {
          console.log('Listening to mouse')
        }
        var field = document
        f.attachMouseMove(field)
        f.attachMouseOut(field)
        f.detectField = field
      },
      createListenField: function () {
        var x = document.createElement('div')
        x.style.width = '100%'
        x.style.height = f.opts.topHeight + 'px'
        x.style.top = '0'
        x.style.left = '0'
        x.style.position = 'fixed'
        x.style.marginLeft = f.opts.leftGap + 'px'
        if (window.fb_testing) {
          x.style.backgroundColor = 'green'
          x.style.opacity = '0.2'
        }
        document.body.appendChild(x)
        return x
      },
      attachMouseMove: function (field) {
        if (field.attachEvent) {
          field.attachEvent('onmousemove', f.onMouseMove)
        } else if (field.addEventListener) {
          field.addEventListener('mousemove', f.onMouseMove, false)
        }
      },
      onMouseMove: function (e) {
        f.lastMoves.push({
          t: e.debug_time || new Date().getTime(),
          x: e.clientX,
          y: e.clientY
        })
        while (f.lastMoves.length > f.opts.moveQueueDepth) {
          f.lastMoves.shift()
        }
        if (f.returnTimeout) {
          clearTimeout(f.returnTimeout)
          delete f.returnTimeout
        }
        if (e.clientY > f.opts.topHeight) {
          f.removeEvent(f.detectField, 'mousemove', f.onMouseMove)
          setTimeout(function () {
            f.attachMouseMove(document)
          }, f.opts.eventInterval)
        }
      },
      attachMouseOut: function (field) {
        if (field.attachEvent) {
          field.attachEvent('onmouseout', f.onMouseOut)
        } else if (field.addEventListener) {
          field.addEventListener('mouseout', f.onMouseOut, true)
        }
      },
      onMouseOut: function (e) {
        if (f.returnTimeout) {
          return
        }
        var x, y, t, m_l, m_p, vel
        var now = new Date().getTime()
        m_l = f.lastMoves[1]
        m_p = f.lastMoves[0]
        if (f.opts.debugMode && window.console) {
          console.log(m_l, m_p)
        }
        if (m_l && m_p &&
          (m_l.t >= (now - f.opts.moveDelay)) &&
          (m_p.y <= f.opts.topHeight)) {
          x = m_l.x - m_p.x
          y = m_l.y - m_p.y
          t = m_l.t - m_p.t

          // in px per second
          vel = Math.sqrt(x * x + y * y) / t * 1000
          if (f.opts.debugMode && window.console) {
            console.log('vel: ', vel, ' ', x, ' ', y, ' ', t)
            console.log('lim: ', f.opts.moveVel)
          }
          if (vel >= f.opts.moveVel) {
            if (f.opts.returnTime) {
              f.returnTimeout = setTimeout(f.tryShowFeedback, f.opts.returnTime)
              // In IE, extra events are fired after this, so take off the events
              // very briefly so it doesn't stop the popup from showing
              f.removeEvent(f.detectField, 'mousemove', f.onMouseMove)
              setTimeout(function () {
                f.attachMouseMove(f.detectField)
              }, 50)
            } else {
              f.tryShowFeedback()
            }
          }
        }
      },
      tryShowFeedback: function () {
        f.removeEvents()
        if (Math.random() < f.opts.showProb) {
          f.showFeedback()
        }
      },
      removeEvents: function () {
        f.removeEvent(f.detectField, 'mousemove', f.onMouseMove)
        f.removeEvent(f.detectField, 'mouseout', f.onMouseOut)
      },
      removeEvent: function (field, eventName, method) {
        if (field.detachEvent) {
          field.detachEvent('on' + eventName, method)
        } else if (field.removeEventListener) {
          field.removeEventListener(eventName, method)
        }
      },
      showFeedback: function () {
        f.showTime = new Date().getTime()
        f.doShowFeedback()
      },
      doShowFeedback: function () {
        f.opts.callBack()
      },
      makeDelegate: function (fn) {
        return function (event) {
          fn(f.getAPI(), event)
        }
      },
      delegateEvents: function (node, events) {
        if (!events) {
          return
        }
        var key, fn, eventType, selector
        for (key in events) {
          if (events.hasOwnProperty(key)) {
            if (key.split(' ').length === 2) {
              eventType = key.split(' ')[0]
              selector = key.split(' ')[1]
              fn = events[key]
              node.on(eventType, selector, f.makeDelegate(fn))
            }
          }
        }
        if (events.load) {
          events.load(f.getAPI())
        }
      }
    }

    return f
  }
})
;
define('variation_manager',['require','json','mini_lodash','when','events','logger','cookie_manager','visitor','exit_checker','match_condition'],function (require) {
  require('json')
  var _ = require('mini_lodash')
  var when = require('when')
  var Events = require('events')
  var logger = require('logger')
  var cookieManager = require('cookie_manager')
  var Visitor = require('visitor')
  var exitChecker = require('exit_checker')
  var matchCondition = require('match_condition')

  var on = function (el, event, handler) {
    if (el.attachEvent) {
      el.attachEvent('on' + event, handler)
    } else {
      el.addEventListener(event, handler)
    }
  }

  var off = function (el, event, handler) {
    if (el.detachEvent) {
      el.detachEvent('on' + event, handler)
    } else {
      el.removeEventListener(event, handler)
    }
  }

  var VariationManager = function (id, variation_id, experiment_id, params, allExperimentVariations, componentActivationModuleIds) {
    var vm = {
      activation: function (cb) {
        this.log('trying to activate')
        var log = this.log
        if (this._bypassTests()) {
          log('Bypassing activation due to URL parameter.')
          log('activating')
          cb()
          return true
        } else if (isIE8() && params.dependencies && /^\^?2/.test(params.dependencies['@qubit/layer'])) {
          log('Not activating V3 layer in IE8')
        } else {
          var tests = this._getTests()
          var tier = 0
          var iterator = _.bind(function () {
            var currentTests = _.map(tests[tier], function (f) {
              return f()
            })
            when.all(currentTests).then(function (testResults) {
              var allTestsPassed = _.all(testResults, function (v) { return v })
              if (allTestsPassed) {
                tier += 1
                if (tier === tests.length) {
                  log('firing post-activation')
                  cb()
                } else {
                  iterator()
                }
              }
            })
          }, this)
          iterator()
        }
      },
      _bypassTests: function () {
        return this._getUrl().indexOf('bypass_activation') > -1
      },
      _getProfileTests: function () {
        var tests = []
        tests.push([])
        tests[0].push(this._checkWho)
        tests[0].push(this._checkBody)
        tests[0].push(this._checkCloseTime)
        tests[0].push(this._checkTimesActivated)
        tests[0].push(this._checkTimesActivatedInSession)
        tests[0].push(this._checkUrl)
        tests[0].push(this._checkSessionNumber)
        tests[0].push(this._checkMinPageViews)
        tests[0].push(this._checkMaxPageViews)
        tests[0].push(this._checkMinTimeOnPage)
        tests[0].push(this._checkMinTimeOnSite)
        tests[0].push(this._checkCustomJavascript)
        tests[0].push(this._checkDepthVisibility)
        tests[0].push(this._checkComponentUVs)
        tests[0].push(this._checkUVs)
        tests.push([])
        tests[1].push(this._checkComponentElements)
        tests[1].push(this._checkLeavingPage)
        return tests
      },
      _getTests: function () {
        if (params.validateWho && params.who) {
          return this._getProfileTests()
        }
        var tests = []
        tests.push([])
        tests[0].push(this._checkBody)
        tests[0].push(this._checkCloseTime)
        tests[0].push(this._checkTimesActivated)
        tests[0].push(this._checkTimesActivatedInSession)
        tests[0].push(this._checkUrl)
        tests[0].push(this._checkSessionNumber)
        tests[0].push(this._checkMinPageViews)
        tests[0].push(this._checkMaxPageViews)
        tests[0].push(this._checkMinTimeOnPage)
        tests[0].push(this._checkMinTimeOnSite)
        tests[0].push(this._checkCustomJavascript)
        tests[0].push(this._checkDepthVisibility)
        tests[0].push(this._checkComponentUVs)
        tests[0].push(this._checkUVs)
        tests.push([])
        tests[1].push(this._checkComponentElements)
        tests[1].push(this._checkLeavingPage)
        return tests
      },

      _checkWho: function () {
        if (params.validateWho && params.who) {
          if (params.validateWho(params.who)) {
            return true
          }
          var d = when.defer()
          params.revalidateWho(function () {
            if (params.validateWho(params.who)) {
              d.resolve(true)
              return true
            }
          })
          return d.promise
        }
        return true
      },

      _checkComponentElements: function () {
        var self = this
        var Layer = this.getLayerClass()
        if (Layer === null) {
          return true
        }

        if (!Layer.shouldActivate || !Layer.getSelectorsToPoll) {
          return true
        }

        var selectorsToPoll = {}
        _.each(allExperimentVariations, function (variation) {
          if (variation && variation.params && variation.params.components) {
            _.each(Layer.getSelectorsToPoll(variation.params.components), function (s) {
              selectorsToPoll[s] = true
            })
          }
        })
        selectorsToPoll = _.keys(selectorsToPoll)

        if (!selectorsToPoll.length) {
          return true
        }

        var d = when.defer()
        self.log('activation rule: Layer#shouldActivate. status: checking', selectorsToPoll)

        Layer.shouldActivate({
          meta: params.meta,
          selectorsToPoll: selectorsToPoll,
          componentActivations: this.getComponentActivations()
        }, function (shouldActivate, reason) {
          if (shouldActivate) {
            self.log('activation rule: Layer#shouldActivate. status: passed')
            d.resolve(true)
          } else {
            self.log('activation rule: Layer#shouldActivate. status: failed. ' + reason)
          }
        })

        return d
      },
      _checkComponentUVs: function () {
        var self = this
        var satisfied = true
        _.each(params && params.components, function (component) {
          if (component && component.dependencies && component.dependencies.uv) {
            _.each(component.dependencies.uv, function (path) {
              satisfied = satisfied && self._objHasPath(window.universal_variable || {}, path)
            })
          }
        })
        this.log("activation rule: 'content UVs'.",
          'Will activate?', satisfied)
        return satisfied
      },
      _objHasPath: function (obj, path) {
        var exists = true
        var root = obj
        var paths = path.split('.')
        _.each(paths, function (key, i) {
          if (exists) {
            root = root[paths[i]]
            exists = exists && root !== void 0
          }
        })
        return exists
      },
      _checkCloseTime: function () {
        var duration = cookieManager.readInt(id, 'close_duration')
        var closeTime = cookieManager.readInt(id, 'close_time')
        if (duration && closeTime) {
          var ok = (closeTime + (duration * 1000) < this._getTime())
          this.log("activation rule: 'block_time'.",
            'Closed at:', new Date(closeTime),
            'Staying closed till:', new Date(closeTime + duration * 1000),
            'Will activate?', ok)
          return ok
        }
        return true
      },
      _checkTimesActivated: function () {
        if (params.rules && params.rules.times_activated) {
          var maxTimesActivated = params.rules.times_activated
          var timesActivated =
          cookieManager.readInt(id, 'times_activated')
          var ok = timesActivated < maxTimesActivated
          this.log("activation rule: 'times_activated'.",
            'Can fire count:', maxTimesActivated,
            'Has fired count:', timesActivated,
            'Will activate?', ok)
          return ok
        }
        return true
      },
      _checkTimesActivatedInSession: function () {
        if (params.rules && params.rules.times_activated_session) {
          // If pageviews is 1 then reset the counter
          if (this._getPageViews() === 1) {
            cookieManager.write(id, 'times_activated_session', 0)
          }

          var timesActivatedSession = cookieManager.readInt(id, 'times_activated_session')
          var rule = params.rules.times_activated_session

          var ok = timesActivatedSession < rule.value
          this.log("activation rule: 'times_activated_session'.",
            'Can fire count:', rule.value,
            'Has fired count:', timesActivatedSession,
            'Will activate?', ok)
          return ok
        }
        return true
      },
      _checkUVs: function () {
        if (params.rules) {
          var d = when.defer()
          var rules = params.rules
          var pollFor = _.reduce(rules, function (memo, rule, key) {
            if (key.indexOf('pageviews__customvalues__uv') === 0) {
              memo.push(rule.key.replace('pageviews.customvalues.uv', 'window.universal_variable'))
            }
            return memo
          }, [])
          if (pollFor.length === 0) {
            return true
          }
          this.log("activation rule: 'universal_variable'. Polling for", pollFor)
          var poller = this.getPoller()
          poller(pollFor, _.bind(function () {
            var matches = true
            _.each(rules, function (rule, key) {
              if (key.indexOf('pageviews__customvalues__uv') === 0) {
                var uvKey = rule.key.replace('pageviews.customvalues.uv', 'universal_variable')
                var uvValue = this._getNested(window, uvKey)

                var matched = !!this._testUVOperator(rule.op, uvValue, rule.value)

                this.log("activation rule: 'universal_variable'.",
                  'key:', uvKey,
                  'operator:', rule.op,
                  'value:', uvValue,
                  'expected:', rule.value,
                  'matched?', matched)

                /* If any individual UV fails to match, that's enough to cancel triggering */
                if (!matched) {
                  matches = false
                }
              }
            }, this)
            return d.resolve(matches)
          }, this))
          return d.promise
        } else {
          return true
        }
      },

      // trick requirejs in testing to evaluate lazyly, once poller has been registered
      getPoller: function () {
        var str = '@qubit/poller'
        return require(str)
      },

      _getNested: function (obj, desc) {
        var arr = desc.split('.')
        while (arr.length && (obj = obj[arr.shift()])) {}
        return obj
      },

      _testUVOperator: function (op, actualValue, conditionValue) {
        return matchCondition({
          op: op,
          value: conditionValue
        }, actualValue)
      },
      _checkUrl: function () {
        if (params.rules && params.rules.page_url) {
          this.log(params.rules.page_url)
          return _.any(params.rules.page_url.urls, function (url) {
            var ok, test, rule
            var isNegative = url.match_type[0] === 'n'
            var phrases = url.match_phrase
            // ensure it's an array
            phrases = _.isArray(phrases) ? phrases : [phrases]
            var currentUrl = this._getUrl().toLowerCase()
            switch (url.match_type) {
              case 'contains':
              case 'ncontains':
                test = function (phrase) {
                  phrase = phrase.toLowerCase()
                  return currentUrl.indexOf(phrase) > -1
                }
                rule = 'url contains'
                break
              case 'regex':
              case 'nregex':
                test = function (phrase) {
                  return currentUrl.match(new RegExp(phrase, 'i'))
                }
                rule = 'url matches regex'
                break
              default:
                this.log("Didn't find an appropriate match type")
                test = function () { return false }
            }
            ok = _.some(phrases, test)
            ok = isNegative ? !ok : ok
            this.log("activation rule: '" + rule + "'.",
              'search term:', url.match_phrase,
              'reverse match?', isNegative,
              'Will trigger? ', ok)
            return ok
          }, this)
        }
        return true
      },
      _checkSessionNumber: function () {
        if (params.rules && params.rules.session_number) {
          var rule = params.rules.session_number
          var sessionNumber = this._getSessionNumber()
          var ok
          switch (rule.op) {
            case 'eq':
              ok = rule.value === sessionNumber
              break
            case 'neq':
              ok = rule.value !== sessionNumber
              break
            case 'gt':
              ok = rule.value < sessionNumber
              break
            case 'lt':
              ok = rule.value > sessionNumber
              break
          }
          this.log("activation rule: 'session number'", rule.op, rule.value, '.',
            'session number:', sessionNumber,
            'Will activate?', ok)
          return ok
        }
        return true
      },
      _checkMinPageViews: function () {
        if (params.rules && params.rules.min_page_views) {
          var pageViews = this._getPageViews()
          var ok = !!pageViews && (pageViews >= params.rules.min_page_views)
          this.log("activation rule: 'min page view'.",
            'page views:', pageViews,
            'min page views:', params.rules.min_page_views,
            'Will activate?', ok)
          return ok
        }
        return true
      },
      _checkMaxPageViews: function () {
        if (params.rules && params.rules.max_page_views) {
          var pageViews = this._getPageViews()
          var ok = !!pageViews && (pageViews <= params.rules.max_page_views)
          this.log("activation rule: 'max page view'.",
            'page views:', pageViews,
            'max page views:', params.rules.max_page_views,
            'Will activate?', ok)
          return ok
        }
        return true
      },
      _checkMinTimeOnPage: function () {
        if (params.rules && params.rules.min_time_on_page) {
          var d = when.defer()
          this.log("activation rule: 'min time on page'.",
            'min time on page:', params.rules.min_time_on_page)
          setTimeout(_.bind(function () {
            this.log("activation rule: 'min time on page'.",
              'time on page satisfied')
            d.resolve(true)
          }, this), params.rules.min_time_on_page * 1000)
          return d.promise
        }
        return true
      },
      _checkMinTimeOnSite: function () {
        if (params.rules && params.rules.min_time_in_session) {
          var timeOnSite = Visitor.getTimeInSession()
          /* Convert expected time on site to miliseconds */
          var timeExpected = params.rules.min_time_in_session * 1000
          if (timeOnSite > timeExpected) {
            this.log("activation rule: 'min time on site'.",
              'time on site satisfied')
            return true
          } else {
            var d = when.defer()
            setTimeout(_.bind(function () {
              this.log("activation rule: 'min time on site'.",
                'time on site satisfied')
              d.resolve(true)
            }, this), timeExpected - timeOnSite)
            return d.promise
          }
        }
        return true
      },
      _checkCustomJavascript: function () {
        if (params.rules && params.rules.custom_javascript) {
          var log = this.log

          var f, ret
          var d = when.defer()
            // f = globalEval("(" + params.rules.custom_javascript + ")")

          var src = params.rules.custom_javascript

          log('activation rule: custom_javascript. status: checking')

          /*
           * If the code to be evaluated starts with function, we're likelier
           * than not looking at a function expression. IE doesn't like those
           * inside evals, thinks they're function declarations. So we prepend
           * the source with `0 || ` so that the source turns into
           * `0 || function () {...}`. 0 is falsy, and it forces IE to
           * evaluate the RHS of the OR as an expression.
           */
          src = /^function/.test(src) ? '0 || ' + src : src
          try {
            f = eval('(' + src + ')') // eslint-disable-line no-eval
            if (typeof f !== 'function') {
              /* If the user provided us with something that's not a function,
               * we take it to be a straight up expression, with its truth value
               * determinining whether we should proceed with the activation.
               */
              return !!f
            }

            /* The user-defined activation function might not be able to tell us
             * right away whether we should proceed with the activation, so we
             * take the promise object we defined earlier, and pass it wrapped in
             * a callback to the user function, allowing it to fulfill the promise
             * at a later point in time. The callback optionally accepts an
             * argument, where truthy/falsy values meaning we should/shouldn't
             * proceed with the activation process. Calling the callback with no
             * arguments at all is equivalent to calling it with a truthy value.
             */
            var resolveCallback = function (success) {
              var passed = arguments.length === 0 || success
              log('activation rule: custom_javascript. status:', passed ? 'passed' : 'failed')
              d.resolve(passed)
            }

            /* If the user-defined activation rule returns a bona fide boolean,
             * that means it's signaling activation/non-activation. Not returning
             * anthing (or returning undefined) is taken to implicitly mean that
             * it will use the callback to fulfill the promise at some point in
             * the future. Returning anything else, or throwing an exception, is
             * interpreted as meaning we should not proceed with the activation
             */
            if (f.length === 1) {
              ret = f(resolveCallback)
            } else if (f.length === 2) {
              var options = {meta: params.meta}
              ret = f(options, resolveCallback)
            }
            if (typeof ret === 'boolean') {
              log('activation rule: custom_javascript. status:', ret ? 'passed' : 'failed')
              return ret
            } else if (typeof ret === 'undefined') {
              return d.promise
            } else {
              log('activation rule: custom_javascript. status: invalid_return_type')
              return false
            }
          } catch (e) {
            this.log('Error in custom activation:', e.message)
            return false
          }
        } else {
          return true
        }
      },

      getDocHeight: function () {
        var D = document
        return Math.max(
          Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
          Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
          Math.max(D.body.clientHeight, D.documentElement.clientHeight)
        )
      },

      windowProperties: function () {
        var D = document
        return {
          viewportTop: Math.max(D.body.scrollTop, D.documentElement.scrollTop),
          clientHeight: D.documentElement.clientHeight,
          docHeight: this.getDocHeight()
        }
      },

      _checkDepthVisibility: function (doc) {
        if (params.rules && params.rules.scroll_position) {
          var d = when.defer()
          var type = params.rules.scroll_position.op
          var value = params.rules.scroll_position.value
          var log = this.log
          var self = this

          log("activation rule: 'scroll position required'.",
            'type:', type,
            'expected:', value)

          var handler = function handler () {
            var metrics = self.windowProperties()
            var viewportTop = metrics.viewportTop
            var clientHeight = metrics.clientHeight
            var docHeight = metrics.docHeight
            var viewportBottom = viewportTop + clientHeight
            var targetLine

            switch (type) {
              case 'pct':
                viewportTop = (viewportTop / docHeight) * 100
                viewportBottom = (viewportBottom / docHeight) * 100
              /* fall through on purpose */
              case 'top':
                targetLine = value
                break
              case 'bottom':
                targetLine = docHeight - value
                break
              default:
                /* We should've had a valid type! */
                return
            }

            if (targetLine >= viewportTop && targetLine <= viewportBottom) {
              log("activation rule: 'scroll position satisfied'.",
                'operator:', type,
                'expected:', value,
                'viewport top:', viewportTop,
                'viewport bottom:', viewportBottom)
              d.resolve(true)
              off(window, 'scroll', handler)
            }
          }

          on(window, 'scroll', handler)

          // call the handler right away, in case the scroll position is right
          // from the start
          handler()

          return d.promise
        } else {
          return true
        }
      },
      _checkLeavingPage: function () {
        if (params.rules && params.rules.leaving_page) {
          this.log("activation rule: 'leaving page'.", 'listening')
          var d = when.defer()
          var opts = {
            debugMode: false,
            topHeight: 150,
            moveQueueDepth: 2,
            moveDelay: 500,
            moveVel: 500,
            leftGap: 10,
            attachTime: 1000 * (params.rules.leaving_page || 1),
            returnTime: 300,
            eventInterval: 100,
            showProb: 1,
            callBack: _.bind(function () {
              this.log("activation rule: 'leaving page'.", 'triggered')
              /* Prevent exit feedback from triggering */
              window.q_ef_disable = true
              d.resolve(true)
            }, this)
          }

          try {
            exitChecker(opts).start()
            return d
          } catch (e) {
            return false
          }
        } else {
          return true
        }
      },
      _checkBody: function () {
        if (params.rules && params.rules.wait_for_body && params.rules.wait_for_body.value) {
          var self = this
          this.log("activation rule: 'wait for body'. Waiting...")
          // sync check
          if (document.body) {
            this.log("activation rule: 'wait for body'. Body exists.")
            return true
          }

          var poll = function poll (cb) {
            setTimeout(function () {
              if (document.body) {
                resolve()
              } else {
                poll(cb)
              }
            }, 20)
          }

          var resolve = function resolve () {
            self.log("activation rule: 'wait for body'. Body exists.")
            d.resolve(true)
          }

          // defered check
          var d = when.defer()
          setTimeout(function () {
            if (document.body) {
              resolve()
            } else {
              poll(resolve)
            }
          }, 0)

          return d
        }
        return true
      },
      _getSessionNumber: function () {
        return Visitor.getSessionCount()
      },
      _getPageViews: function () {
        return Visitor.getSessionViewCount()
      },
      _getTime: function () {
        return new Date().getTime()
      },
      _getUrl: function () {
        return document.location.href
      },
      open: function (options) {
        var location = options.target === 'same_tab'
          ? '_self'
          : '_blank'
        window.open(options.url, location)
        this.report('open', options.reason)
      },
      close: function (options) {
        var behaviour = options.behaviour
        cookieManager.write(id, 'close_time', new Date().getTime())
        if (behaviour.type === 'block_time') {
          cookieManager.write(id, 'close_duration', behaviour.duration)
        }
        this.report('close', options.reason)
      },

      getVariationWithLayer: function () {
        return _.find(allExperimentVariations, function (variation) {
          return variation &&
          variation.params &&
          variation.params.dependencies &&
          variation.params.dependencies['@qubit/layer']
        })
      },

      require: function (moduleStr) {
        return require(moduleStr)
      },

      getComponentActivations: function () {
        return _.map(componentActivationModuleIds, function (componentActivationModuleId) {
          return this.require(componentActivationModuleId)
        }, this)
      },

      getLayerClass: function () {
        var variationWithLayer = this.getVariationWithLayer()
        if (!variationWithLayer) {
          return null
        }
        var layerId = '@qubit/layer@' + variationWithLayer.params.dependencies['@qubit/layer']
        return this.require(layerId)
      },

      isV1Layer: function () {
        var variationWithLayer = this.getVariationWithLayer()
        return variationWithLayer && variationWithLayer.params.dependencies['@qubit/layer'] === '^1.0.0'
      },

      isExclusive: function () {
        // v2 experiments
        if (this.isV1Layer()) {
          if (params.container && params.container.type) {
            return params.container.type === '@qubit/slider'
          }
          return false
        }
        // v3 experiments
        var Layer = this.getLayerClass()
        if (!Layer || !Layer.isExclusive) {
          return false
        }
        return !!_.find(allExperimentVariations, function (variation) {
          if (variation && variation.params && variation.params.components) {
            return Layer.isExclusive({components: variation.params.components})
          }
        })
      },

      enableExclusivityLock: function () {
        window.__qubit.smartserve.exclusivityLock = true
      },

      isExclusivityLockEnabled: function () {
        return window.__qubit.smartserve.exclusivityLock
      },

      _incrementTimesShown: function () {
        // Total
        var timesActivated = cookieManager.readInt(id, 'times_activated')
        cookieManager.write(id, 'times_activated', timesActivated + 1)

        // Session
        var timesActivatedSession = cookieManager.readInt(id, 'times_activated_session')
        cookieManager.write(id, 'times_activated_session', timesActivatedSession + 1)
      },
      on: function () {
        this.log('start listening to', arguments[0])
        VariationManager.on.apply(VariationManager, arguments)
      },
      off: function () {
        this.log('stop listening to', arguments[0])
        VariationManager.off.apply(VariationManager, arguments)
      },
      trigger: function () {
        this.log('triggered', arguments[0])
        VariationManager.trigger.apply(VariationManager, arguments)
      },

      /*
       * Reporting Action and Reason
       */
      report: function (action, reason) {
        window._qtd = window._qtd || []
        window._qtd.push({
          data: {
            smart_serve: {
              // experiment id
              e: experiment_id,
              // variation id
              v: variation_id,
              // variation master id
              vm: id,
              // e.g. slider
              m: params.container.type,
              // e.g. image
              f: 'deliver_reloaded',
              // e.g. close, open
              a: action,
              // e.g. image clicked, or clicked outside
              r: reason
            }
          }
        })
      },

      /*
       * Logging when debug is on
       */
      log: function () {
        logger.logVariation(id, params.meta.variationIsControl, arguments)
      },

      logError: function () {
        logger.logVariation(id, params.meta.variationIsControl, arguments, true)
      },

      addCustomStyles: function () {
        if (params.custom_styles) {
          if (params.custom_styles.error) {
            this.logError('LESS error', params.custom_styles.error)
          } else {
            this._customStyleSheet = this._addStyleSheet(params.custom_styles)
          }
        }
      },

      removeCustomStyles: function () {
        if (this._customStyleSheet) {
          try {
            this._customStyleSheet.parentElement.removeChild(this._customStyleSheet)
          } catch (e) {}
        }
        delete this._customStyleSheet
      },

      _addStyleSheet: function (css) {
        var head, styleElement
        head = document.getElementsByTagName('head')[0]
        styleElement = document.createElement('style')
        styleElement.setAttribute('type', 'text/css')
        if (styleElement.styleSheet) {
          styleElement.styleSheet.cssText = css
        } else {
          styleElement.appendChild(document.createTextNode(css))
        }
        head.appendChild(styleElement)
        return styleElement
      }

    }
    _.bindAll(vm)

    function isIE8 () {
      var ua = navigator.userAgent.toLowerCase()
      return (ua.indexOf('msie 8') > -1)
    }

    return vm
  }

  _.extend(VariationManager, Events)

  return VariationManager
})
;
define('post_activation',[],function () {
  /**
   * This allows us to do checks after all activate rules have passed
   * but before the variation execution is going to fire
   */
  function postActivation (options) {
    var layerShouldRun = checkExclusivity(options)
    if (layerShouldRun) {
      options.vm.log('activation rule: post-activation complete. firing execution!')
    } else {
      options.vm.log('activation rule: status: failed. (another exclusive layer is already showing)')
    }
    // other checks to go here...
    return layerShouldRun
  }

  /**
   * Handles exclusive layers on the page
   * and lock as soon as one is showing
   */
  function checkExclusivity (options) {
    var layerShouldRun = true
    if (options.vm.isExclusive()) {
      if (options.vm.isExclusivityLockEnabled()) {
        layerShouldRun = false
      } else {
        options.vm.enableExclusivityLock()
      }
    }
    return layerShouldRun
  }

  return postActivation
})
;
define('run_layer',['require','post_activation'],function (require) {
  var postActivation = require('post_activation')

  function runLayer (options) {
    var layer
    if (postActivation(options)) {
      try {
        layer = createLayer(options)
        layer.run()
      } catch (err) {
        if (window.console && console.error) {
          console.error(err.stack)
        }
        throw err
      }
      return {
        success: true,
        remove: function () {
          if (layer && layer.destroy) {
            layer.destroy()
            // make sure to only call 'destroy' once for this instance
            layer = null
          }
        }
      }
    } else {
      return {
        // preserve v1 layer logic
        success: !!options.vm.isV1Layer()
      }
    }
  }

  function createLayer (options) {
    var deps = options.params.dependencies
    var modules = {}
    for (var dep in deps) {
      if (deps.hasOwnProperty(dep)) {
        modules[dep] = require(dep + '@' + deps[dep])
      }
    }
    options.params.modules = modules

    var layerModuleId = modules['@qubit/layer'] ? '@qubit/layer' : 'layer'
    var Layer = require(layerModuleId + '@' + deps[layerModuleId])
    var layer = new Layer({
      close: function (closeOptions) {
        if (closeOptions.duration) {
          closeOptions.duration = parseInt(closeOptions.duration, 10)
        }
        switch (closeOptions.type) {
          case 'days':
            closeOptions.type = 'block_time'
            closeOptions.duration = closeOptions.duration * 24 * 60 * 60
            break
          case 'minutes':
            closeOptions.type = 'block_time'
            closeOptions.duration = closeOptions.duration * 60
            break
        }
        options.vm.close({ behaviour: closeOptions })
        layer.destroy()
      }
    }, options.params)

    return layer
  }

  return runLayer
})
;
define('control_execution',['require','post_activation'],function (require) {
  var postActivation = require('post_activation')

  return function controlExecution (options) {
    var layerShouldRun = postActivation(options)
    if (layerShouldRun) {
      options.vm._incrementTimesShown()
    }
    return {
      success: layerShouldRun,
      remove: options.cleanup
    }
  }
})
;
define('get_component_activation_module_ids_for_experiment',['require','exports','module'],function (require, exports, module) {function containsSubstring (arr, val) {
  var l = arr.length
  while (l--) {
    if (arr[l].indexOf(val) === 0) {
      return l
    }
  }
  return -1
}

module.exports = function getComponentActivationModuleIdsForExperiment (options) {
  var allExperimentVariations = options.allExperimentVariations
  var activationModuleIds = options.activationModuleIds
  var map = (options.map || {})['*'] || {}

  var i
  var componentActivationModuleIds = []
  for (i = 0; i < allExperimentVariations.length; i++) {
    var variation = allExperimentVariations[i]
    var params = variation.params
    for (var name in params.dependencies) {
      if (params.dependencies.hasOwnProperty(name)) {
        var version = params.dependencies[name]
        var activationModuleIdCheck = map[name + '@' + version]
        if (activationModuleIdCheck) {
          activationModuleIdCheck = activationModuleIdCheck.replace('---', '/')
          var aIndex = containsSubstring(activationModuleIds, activationModuleIdCheck)
          if (aIndex !== -1) {
            componentActivationModuleIds.push(activationModuleIds[aIndex])
          }
        }
      }
    }
  }
  return componentActivationModuleIds
}

});

define('create_etc_config',['require','exports','module','mini_lodash','segment','./evaluate_execution','./variation_manager','./run_layer','./control_execution','./get_component_activation_module_ids_for_experiment'],function (require, exports, module) {/**
 * This takes the config object that
 * SSG generates and converts it to a config object
 * compatible with etc.
 */

var _ = require('mini_lodash')
var segment = require('segment')
var evaluateExecution = require('./evaluate_execution')
var variationManager = require('./variation_manager')
var runLayer = require('./run_layer')
var runControlExecution = require('./control_execution')
var getComponentActivationModuleIdsForExperiment = require('./get_component_activation_module_ids_for_experiment')

function getCreativeRates (targetingCriteria) {
  return _.map(targetingCriteria.creative_rates, function (creativeRate) {
    return {
      id: creativeRate.id,
      p: creativeRate.rate
    }
  })
}

function translateExperiments (experiments) {
  return _.map(experiments, function (experiment) {
    var ej = {
      id: experiment.id,
      goals: experiment.goals
    }
    // convert snake to camel
    if (experiment.paused_at) {
      ej.pausedAt = experiment.paused_at
    }
    if (experiment.iteration_id) {
      ej.iterationId = experiment.iteration_id
    }
    ej.targetingCriteria = _.pluck(experiment.targeting_criteria, 'id')
    return ej
  })
}

function translateTargetingCriteria (experiments) {
  var targetingCriteria = _.flatten(_.pluck(experiments, 'targeting_criteria'))
  return _.reduce(targetingCriteria, function (memo, targetingCriteria) {
    var tcId = Number(targetingCriteria.id)
    memo[tcId] = {
      id: tcId,
      condition: function (cb) {
        segment(tcId, targetingCriteria.segment || []).then(function (matches) {
          if (matches) {
            cb()
          }
        })
      },
      creatives: [getCreativeRates(targetingCriteria)]
    }
    return memo
  }, {})
}

function translateCreatives (config, context) {
  var experiments = config.experiments
  var flags = config.flags
  var profileIndex = config.profileIndex
  var isPreviewMode = config.isPreviewMode
  var propertyMeta = {
    cookieDomain: config.cookieDomain,
    trackingId: config.trackingId
  }

  var creatives = {}
  _.each(experiments, function (experiment) {
    _.each(experiment.targeting_criteria, function (targetingCriteria) {
      _.each(targetingCriteria.creatives, function (creative) {
        var activation, execution, vm
        var cleanupList = []

        // mutate params to dynamically add rules since that's
        // where VariationManager expects them atm
        creative.params.rules = experiment.activation_rules
        creative.params.who = experiment.profile_activations_enabled
          ? (experiment.profile_id || true)
          : false
        if (flags.PROFILES && flags.JOLT && profileIndex && context.membershipEngine) {
          creative.params.validateWho = function validateWho (who) {
            // if no profile is specified, return true
            if (!who || who === true) {
              return true
            }
            return context.membershipEngine.isMemberOf(who)
          }
          creative.params.revalidateWho = function revalidateWho (cb) {
            var disposable
            disposable = context.membershipEngine.onMembershipsChanged(function () {
              cleanupList.push(function () {
                disposable.dispose()
              })
              if (cb()) {
                disposable.dispose()
              }
            })
          }
        }

        function cleanup () {
          while (cleanupList.length) {
            cleanupList.pop()()
          }
        }

        if (experiment.profile_activations_enabled) {
          creative.params.whereSpecification = experiment.where_specification
        } else {
          creative.params.whereSpecification = []
        }
        creative.params.validateWhere = flags.PROFILES
        creative.params.isPreviewMode = isPreviewMode

        creative.params.meta = makeMeta(propertyMeta, experiment, creative)

        var allExperimentVariations = []
        _.each(experiment.targeting_criteria, function (targetingCriteria) {
          _.each(targetingCriteria.creatives, function (c) {
            allExperimentVariations.push(c)
          })
        })

        var componentAcitvationModuleIds = getComponentActivationModuleIdsForExperiment({
          allExperimentVariations: allExperimentVariations,
          activationModuleIds: config.activationModuleIds,
          map: config.amd.map
        })

        vm = variationManager(
          creative.id,
          creative.creative_id,
          experiment.id,
          creative.params,
          allExperimentVariations,
          componentAcitvationModuleIds
        )

        activation = function (cb) {
          vm.activation(cb)
        }

        if (creative.is_control) {
          execution = function controlExecution () {
            return runControlExecution({
              vm: vm,
              cleanup: cleanup
            })
          }
        } else if (creative.advanced_mode) {
          execution = function advancedExecution () {
            vm._incrementTimesShown()
            vm.addCustomStyles()
            var adv = evaluateExecution(creative.params.execution_code, {
              meta: makeMeta(propertyMeta, experiment, creative)
            })
            return {
              remove: function () {
                cleanup()
                if (adv && adv.remove) {
                  vm.removeCustomStyles()
                  return adv.remove()
                }
              }
            }
          }
        } else {
          execution = function simpleExecution () {
            return runLayer({
              vm: vm,
              params: creative.params,
              cleanup: cleanup
            })
          }
        }

        creatives[creative.id] = {
          id: creative.id,
          creative_id: creative.creative_id,
          e_id: experiment.id,
          activation: activation,
          execution: execution,
          control: creative.is_control
        }
      })
    })
  })
  return creatives
}

function makeMeta (propertyMeta, experiment, creative) {
  return {
    trackingId: propertyMeta.trackingId,
    cookieDomain: propertyMeta.cookieDomain,
    experimentId: experiment.id,
    iterationId: experiment.iteration_id,
    variationId: creative.creative_id,
    variationMasterId: creative.id,
    variationIsControl: creative.is_control
  }
}

function createEtcConfig (config, context) {
  var cookieDomain = config.cookieDomain
  var trackingId = config.trackingId
  var experiments = config.experiments
  var ignoreVirtualPageViews = config.ignoreVirtualPageViews
  return {
    domain: cookieDomain,
    trackingId: trackingId,
    ignoreVirtualPageViews: ignoreVirtualPageViews,
    experiments: translateExperiments(experiments),
    targetingCriteria: translateTargetingCriteria(experiments),
    creatives: translateCreatives(config, context)
  }
}

module.exports = createEtcConfig

});

define('preview_loader/lib/get_script',['require','exports','module','mini_lodash'],function (require, exports, module) {var _ = require('mini_lodash')

module.exports = function getScript (pattern) {
  var scripts = document.getElementsByTagName('script')
  return _.find(scripts, function (script) {
    return pattern.test(script.src)
  })
}

});

define('preview_loader/lib/has_script',['require','exports','module','./get_script'],function (require, exports, module) {var getScript = require('./get_script')

module.exports = function hasScript (pattern) {
  return !!getScript(pattern)
}

});

define('preview_loader/lib/has_flag',['require','exports','module'],function (require, exports, module) {module.exports = function hasFlag (href, flag) {
  return new RegExp(flag).test(decodeURIComponent(href))
}

});

define('preview_loader/lib/is_preview_mode',['require','exports','module','./has_flag','cookieman'],function (require, exports, module) {var hasFlag = require('./has_flag')
var cookieman = require('cookieman')
var previewFlag = 'smartserve_preview'

function urlHasPreviewFlag (href) {
  return hasFlag(href, previewFlag)
}

function cookieHasPreviewFlag () {
  var cookies = cookieman.get(previewFlag)
  var i
  var l = cookies.length
  for (i = 0; i < l; i++) {
    if (cookies[i].value === 'true') {
      return true
    }
  }
  return false
}

function isPreviewMode () {
  return urlHasPreviewFlag(window.location.href) || cookieHasPreviewFlag()
}

module.exports = {
  isPreviewMode: isPreviewMode,
  cookieHasPreviewFlag: cookieHasPreviewFlag,
  urlHasPreviewFlag: urlHasPreviewFlag
}

});

define('preview_loader/lib/patterns',['require','exports','module'],function (require, exports, module) {module.exports = {
  production: /smartserve-(\d+)\.js/,
  preview: /smartserve-(\d+)(-\w+)?(-preview)\.js/
}

});

define('preview_loader/lib/should_load_preview',['require','exports','module','./has_script','./is_preview_mode','./patterns'],function (require, exports, module) {var hasScript = require('./has_script')
var isPreviewMode = require('./is_preview_mode').isPreviewMode
var patterns = require('./patterns')

module.exports = function shouldLoadPreview () {
  var previewAlreadyLoaded = window.__qubit && window.__qubit.previewActive
  return isPreviewMode() && !hasScript(patterns.preview) && !previewAlreadyLoaded
}

});

define('preview_loader/lib/check_if_sync',['require','exports','module','./get_script','./patterns'],function (require, exports, module) {var getScript = require('./get_script')
var patterns = require('./patterns')

module.exports = function checkIfSync () {
  var script = getScript(patterns.production)
  if (!script) {
    return false
  }
  return !script.async && !script.defer
}

});

define('preview_loader/lib/load_script',['require','exports','module','./check_if_sync'],function (require, exports, module) {var checkIfSmartserveIsSync = require('./check_if_sync')
var doc = document

function loadSyncDocWrite (url) {
  doc.write(['<scr', "ipt src='", url, "'></scr", 'ipt>'].join(''))
}

function loadAsync (url) {
  var head = doc.getElementsByTagName('head')[0]
  var script = doc.createElement('script')
  script.src = url
  head.appendChild(script)
}

function loadScript (url, trySync) {
  if (trySync && checkIfSmartserveIsSync()) {
    loadSyncDocWrite(url)
  } else {
    loadAsync(url)
  }
}

module.exports = loadScript

});

define('preview_loader/lib/get_preview_url',['require','exports','module','config'],function (require, exports, module) {var config = require('config')
var preview = config.endpoints.preview
module.exports = function getPreviewUrl (propertyId, isProduction, localPreviewId) {
  return [
    isProduction ? preview.production : preview.development,
    '/smartserve-', propertyId, localPreviewId ? '-' + localPreviewId : '', '-preview.js'
  ].join('')
}

});

define('preview_loader/lib/preview_loader',['require','exports','module','mini_lodash','./get_script','./load_script','./has_flag','./get_preview_url','./patterns'],function (require, exports, module) {var _ = require('mini_lodash')
var getScript = require('./get_script')
var loadScript = require('./load_script')
var hasFlag = require('./has_flag')
var getPreviewUrl = require('./get_preview_url')
var patterns = require('./patterns')

var previewLoader = {}

function getFlag (name, href) {
  var matches = href && href.match(new RegExp(name))
  return !!matches && matches[1]
}

function getIsProduction (href) {
  var env = previewLoader.getEnv(href)
  return !/(development|staging)/.test(env)
}

function getSmartserveScript () {
  return getScript(patterns.production)
}

function isForcedPropertyId (href) {
  return /smartserve_p=/.test(href)
}

function getForcedPropertyId (href) {
  return getFlag('smartserve_p=(\\d+)', href)
}

function loadPreview () {
  var script = previewLoader.getSmartserveScript()
  var src = script && script.src
  var isForcedPropertyId = previewLoader.isForcedPropertyId(window.location.href)
  var propertyId = previewLoader.getPropertyId(src)
  if (isForcedPropertyId) {
    propertyId = previewLoader.getForcedPropertyId(window.location.href)
  }
  if (!propertyId) {
    return false
  }
  var isProduction = previewLoader.getIsProduction(window.location.href)
  var localPreviewId = previewLoader.getLocalPreviewId(window.location.href)
  var url = previewLoader.getPreviewUrl(propertyId, isProduction, localPreviewId)

  window.__qubit = window.__qubit || {}
  window.__qubit.previewActive = true

  // always try to load preview synchronously if possible
  var trySync = true
  previewLoader.loadScript(url, trySync)
}

previewLoader = {
  hasFlag: hasFlag,
  loadScript: loadScript,
  getPreviewUrl: getPreviewUrl,
  getEnv: _.bind(getFlag, null, 'smartserve_env=(\\w+)'),
  getLocalPreviewId: _.bind(getFlag, null, 'smartserve_local=(\\w+)'),
  getPropertyId: _.bind(getFlag, null, 'smartserve-(\\d+)\\.js'),
  getIsProduction: getIsProduction,
  isForcedPropertyId: isForcedPropertyId,
  getForcedPropertyId: getForcedPropertyId,
  getSmartserveScript: getSmartserveScript,
  load: loadPreview
}

module.exports = previewLoader

});

define('preview_loader/index',['require','exports','module','./lib/should_load_preview','./lib/preview_loader'],function (require, exports, module) {var shouldLoadPreview = require('./lib/should_load_preview')
var previewLoader = require('./lib/preview_loader')

module.exports = {
  shouldLoadPreview: shouldLoadPreview,
  loadPreview: previewLoader.load
}

});

define('create_jolt',['require','exports','module'],function (require, exports, module) {module.exports = function createJolt (config, context, dynamicModules) {
  // if we don't have UV API - bail
  if (!context.uv || !dynamicModules.jolt) {
    return
  }

  var terribleBrowser = /MSIE [8,9,10]/.test(navigator.userAgent)

  // otherwise - create jolt !!
  var jolt = dynamicModules.jolt({
    trackingId: config.trackingId,
    domain: config.cookieDomain,
    cookieSync: config.flags.ORCA_SYNC,
    useQtracker: !config.flags.PRONG,
    deflate: !terribleBrowser
  })

  return jolt
}

});

define('start_uv_mapper',[],function () {
  return function startUVMapper (config, context, dynamicModules) {
    if (context.uv && dynamicModules.uvMapper) {
      dynamicModules.uvMapper()
    }
  }
})
;
/* globals define */
define('profile_counter',['require'],function (require) {
  return function (stashCount) {
    function validate (event, action) {
      return event && event.profileId && event.changeType
    }
    function countJoinedAndLeft (event) {
      if (validate(event)) {
        return stashCount.incr(event.profileId, event.changeType, 'date')
      }
    }
    return countJoinedAndLeft
  }
})
;
define('start_membership_engine',['require','exports','module','./profile_counter'],function (require, exports, module) {var createProfileCounter = require('./profile_counter')

module.exports = function startMembershipEngine (config, context, dynamicModules) {
  var stashCount, profileCounter, membershipEngine

  if (!config.flags.PROFILES || !context.jolt || !dynamicModules.membershipEngine) {
    return
  }

  if (dynamicModules.stashCount) {
    stashCount = dynamicModules.stashCount({
      domain: config.endpoints.stash
    })
    profileCounter = createProfileCounter(stashCount)
  }

  var options = {
    domain: config.cookieDomain,
    index: config.profileIndex,
    jolt: context.jolt,
    ping: function (type, event) {
      if (!config.isPreviewMode) {
        try {
          context.uv.emit(type, event)
        } catch (err) {
          if (context.errorPinger) {
            context.errorPinger.captureException(err)
          }
        }
        if (config.flags.PROFILE_COUNTS) {
          profileCounter(event).then(null, function (info) {
            if (context.errorPinger && config.flags.SENTRY_STASH_ERRORS) {
              var xhr = info && info.response && info.response.xhr
              return context.errorPinger.captureMessage('Request failed', {
                extra: {
                  xhr: xhr,
                  error: info && info.error
                }
              })
            }
          })
        }
      }
    }
  }

  if (context.errorPinger) {
    options.onError = function captureMembershipEngineError (err) {
      var state
      try {
        state = membershipEngine.storage.compress(membershipEngine.storage.__cachedVisitorHistory)
      } catch (e) {}
      return context.errorPinger.captureException(err, {
        extra: { cookie: state }
      })
    }
  }

  try {
    membershipEngine = dynamicModules.membershipEngine.start(options)
  } catch (originalError) {
    var error = new Error('Membership engine: Start failed')
    error.originalError = originalError
    throw error
  }

  return membershipEngine
}

});

define('export_api',['require','exports','module','etc.widget/lib/compressed_cookie'],function (require, exports, module) {/**
 * Creates the public smartserve API and exposes it to window
 */

var compressedCookieLib = require('etc.widget/lib/compressed_cookie')

module.exports = function (smartserve, context) {
  // create the namespaces
  window.__qubit = window.__qubit || {}
  window.__qubit.deliver = window.__qubit.deliver || {}
  window.__qubit.smartserve = window.__qubit.smartserve || {}

  // expose require/define functions to global scope
  // always overwrite the define/require functions, otherwise the preview
  // will be working with require from the wrong context
  window.__qubit.amd = {
    define: define,
    require: require
  }

  // expose the cookie api
  window.__qubit.deliver.cookie = compressedCookieLib.api()

  // expose the smartserve API
  window.__qubit.smartserve.start = smartserve.start
  window.__qubit.smartserve.stop = smartserve.stop

  if (context.membershipEngine) {
    window.__qubit.membershipEngine = context.membershipEngine
  }

  if (context.jolt) {
    window.__qubit.jolt = context.jolt
  }
}

});

define('match-condition/index',['require','exports','module'],function (require, exports, module) {/**
 * condition
 * @param  {Object} condition, an object like {op, value}
 * @param  {Any} actualValue
 * @return {Boolean}
 */
module.exports = function matchCondition(condition, actualValue) {
  // clone - don't mutate
  // normalize into array of lowercase strings or other values
  var op = condition.op;
  var conditionValues = lowerCase(arr(condition.value));
  var actualValues = lowerCase(arr(actualValue));

  switch (op) {
  case "eq":
    return somePermutation(function (cv, av) { return av === cv; });
  case "neq":
    return everyPermutation(function (cv, av) { return av !== cv; });
  case "gt":
    return somePermutation(function (cv, av) { return av > cv; });
  case "lt":
    return somePermutation(function (cv, av) { return av < cv; });
  case "in":
    return somePermutation(function (cv, av) { return includes(av, cv); });
  case "nin":
    return everyPermutation(function (cv, av) { return !includes(av, cv); });
  case "regex":
    return somePermutation(function (cv, av) {return (new RegExp(cv).test(av)); });
  case "nregex":
    return everyPermutation(function (cv, av) {return !(new RegExp(cv).test(av)); });
  default:
    return false;
  }

  function everyPermutation(condition) {
    return every(conditionValues, function (cv) {
      return every(actualValues, function (av) {
        return condition(cv, av);
      });
    });
  }

  function somePermutation(condition) {
    return some(conditionValues, function (cv) {
      return some(actualValues, function (av) {
        return condition(cv, av);
      });
    });
  }
};

function map(list, it) {
  var mapped = [];
  for (var i = 0; i < list.length; i++) {
    mapped.push(it(list[i]));
  }
  return mapped;
}

function every(list, it) {
  for (var i = 0; i < list.length; i++) {
    if (!it(list[i])) { return false; }
  }
  return true;
}

function some(list, it) {
  for (var i = 0; i < list.length; i++) {
    if (it(list[i])) { return true; }
  }
  return false;
}

function isString(test) {
  return typeof test === "string";
}

function isArray(test) {
  return test.constructor === Array;
}

function includes(str, substr) {
  return isString(str) && str.indexOf(substr) > -1;
}

function arr(v) {
  return isArray(v) ? v.slice(0) : [v];
}

function lowerCase(arr) {
  return map(arr, function (v) {
    return isString(v) ? v.toLowerCase() : v;
  });
}
});

define('match-condition', ['match-condition/index'], function (main) { return main; });

define('etc.widget/etc',['require','exports','module','json','./lib/compressed_cookie','match-condition','./lib/helpers'],function (require, exports, module) {module.exports = function () {
  var JSON = require("json");
  var compressedcookie = require("./lib/compressed_cookie");
  var matchCondition = require("match-condition");
  var helpers = require("./lib/helpers");
  var each = helpers.forEach;
  var debounce = helpers.debounce;

  var undef;

  var SHOWN_FLAG = {
    GOAL: "0",
    SUCCESS: "1",
    ERROR: "9"
  };

  window._qtd = window._qtd || [];

  var etc = {
    statusKey: "qb_ss_status",
    // Created and managed by cookie manager in SS-generator
    optsKey: "ss_opts",
    configKey: "_qb_ss",
    forceCreative: "etcForceCreative",
    deployedExperiments: {},
    excludedExperiments: {},
    activeCreatives: {},
    defaultConfig: {
      domain: "",
      /**
       * This flag is NOT RECOMMENDED.
       *
       * It can be used to ignore virtual page views and activate
       * experiments that were armed in a different virtual page view.
       * Normally, when this is set to false, the experiments only
       * activate if activation(cb) and cb() calls happen on the same
       * page view ID.
       *
       * Note: even when this flag is true, the goals are still getting
       * rechecked on each virtual page view.
       *
       * @type {Boolean}
       */
      ignoreVirtualPageViews: false,
      debug: false
    },
    uvCounter: 0,
    goalCheckers: {
      pageCategory: {
        key: "pageviews.customvalues.uv.page.category",
        val: function () {
          var val = etc.uv("page.category");
          if (typeof val === "string") {
            return val;
          }
        }
      },
      pageSubcategory: {
        key: "pageviews.customvalues.uv.page.subcategory",
        val: function () {
          var val = etc.uv("page.subcategory");
          if (typeof val === "string") {
            return val;
          }
        }
      },
      url: {
        key: "pageviews.url",
        val: function () {
          return window.location.href;
        }
      },
      event: {
        key: "pageviews.customvalues.uv.events.action",
        val: function (event) {
          if (typeof event.action === "string") {
            return event.action;
          }
        }
      },
      conversion: {
        key: "metrics.conversion_rate"
      }
    },

    // oh boy
    goalValueMultiple: 1000000,

    start: function () {
      // check if we can load config
      // is force creatives or cookie enabled before creating any creatives
      if (etc.mergeConfig() && !etc.fireForcedCreatives()) {
        if (etc.isCookieEnabled()) {
          etc.removeDeadCreatives();
          etc.calculateExcludedExperiments();
          etc.activateExistingCreatives();
          etc.process();
        } else {
          etc.pingCookieDisabled();
        }
      }

      etc.whenUVHasTransaction(etc.writeShownFlagsToUV);

      if (etc.opts && etc.opts.experiments) {
        etc.setupGoals();
      }
    },

    // closes all active layers
    // (simple mode layers and advanced ones that implement
    // the remove hook)
    stop: function () {
      var creativeId, creative;
      for (creativeId in etc.activeCreatives) {
        if (etc.activeCreatives.hasOwnProperty(creativeId)) {
          creative = etc.activeCreatives[creativeId];
          if (creative && creative.remove) {
            try {
              creative.remove();
            } catch (e) {
              // TODO, find a way to communicate this info
              // to developers in preview/debug mode
            }
          }
          delete etc.activeCreatives[creativeId];
        }
      }
    },

    setupGoals: function () {
      etc.registerGoals();
      etc.newPageView();
      etc.handleExistingUVGoals();
      if (!etc.alreadyAddedUVListener) {
        window.uv_listener = window.uv_listener || [];
        window.uv_listener.push(["on", "event", etc.handleUVEvent]);
        etc.alreadyAddedUVListener = true;
      }
    },

    getCookieLib: function () {
      return compressedcookie;
    },

    /*
     * Iterate over any existing UV events that have
     * occured prior to the loading of this script
     * and send off the data
     */
    handleExistingUVGoals: function () {
      var uv = (window.universal_variable = window.universal_variable || {});
      var uvEvents = (uv.events = uv.events || []);
      each(uvEvents, etc.handleUVEvent);
    },

    /*
     * Iterate over experiments and hash all goals by
     * key. Exclude conversions goal.
     */
    registerGoals: function () {
      var statusList = etc.getExperimentStatus();
      etc.goals = {};

      each(etc.opts.experiments, function (experiment) {
        if (statusList[experiment.id]) {
          each(experiment.goals, function (goal) {
            if (goal.key !== etc.goalCheckers.conversion.key) {
              goal.send = function (value) {
                var status, creative, ping;
                if (etc.experimentSeen(experiment.id)) {
                  status = statusList[experiment.id];
                  creative = etc.findCreativeByProbability(status.tc,
                    status.ckg, status.c_prob);

                  ping = {
                    i: experiment.iterationId,
                    e: status.e,
                    tc: status.tc,
                    ckg: status.ckg,
                    c: creative.creative_id,
                    cm: creative.id,
                    p: status.c_prob,
                    s: SHOWN_FLAG.GOAL,
                    cnt: !creative.control ? 0 : 1,
                    g: goal.id
                  };

                  if (value && !isNaN(Number(value))) {
                    ping.ga = Math.round(Number(value) * etc.goalValueMultiple);
                  }
                  etc.saveAndSendPing(ping);
                }
              };

              etc.goals[goal.key] = etc.goals[goal.key] || [];
              etc.goals[goal.key].push(goal);
            }
          });
        }
      });
    },

    experimentSeen: function (experimentId) {
      var found;
      each(etc.getShownFlags(), function (flag) {
        if (flag.e === experimentId) {
          found = true;
        }
      });
      return found;
    },

    /*
     * Handle all UV events, pinging any goals that match the action.
     */

    handleUVEvent: function (event) {
      if (event && event.action) {
        if (event.action === "newPageView") {
          etc.newPageView();
        }
        etc.checkGoal("event", event);
      }
    },

    /*
     * Report a new pageView. For now this simply pings any
     * goals that match uv or the current url.
     */

    newPageView: function () {
      etc.checkGoal("pageCategory");
      etc.checkGoal("pageSubcategory");
      etc.checkGoal("url");
    },

    /**
     * given a goal name and optional params,
     * ping the goal if it matches any of the configured
     * goal rules.
     */

    checkGoal: function (name, params) {
      var goalKey = etc.goalCheckers[name].key;
      var goalValue = etc.goalCheckers[name].val(params);
      var goals = etc.goals[goalKey];
      if (goalValue) {
        each(goals, function (goal) {
          if (matchCondition(goal, goalValue)) {
            if (params && params.value) {
              // kind of a special case for uv.event goals,
              // where we want to ping the goal amount.
              // Not sure if this requirement makes checkGoal
              // too complex of a function.
              goal.send(params.value);
            } else {
              goal.send();
            }
          }
        });
      }
    },

    uv: function (key) {
      var value = window.universal_variable;
      if (!value) {
        return value;
      }
      each(key.split("."), function (segment) {
        if (value) {
          value = value[segment] ? value[segment] : false;
        }
      });
      return value;
    },

    getExperimentStatus: function () {
      var status = etc.getStatus(), experiments = {};
      each(status.c, function (creative) {
        experiments[creative.e] = creative;
      });
      return experiments;
    },

    // Returns false if cannot write a test cookie to the browser
    // also pings a special data to indicate the execution exclusion
    isCookieEnabled: function () {
      var cookieName, cookieValue, canWrite;
      cookieName = "etc_test_" + Math.round(Math.random() * 1000);
      cookieValue = "Q";

      etc.getCookieLib().writeCookie(
        cookieName,
        cookieValue,
        null,
        etc.opts.domain
      );

      canWrite = cookieValue === etc.getCookieLib().readCookie(cookieName);

      if (canWrite) {
        etc.getCookieLib().writeCookie(
          cookieName,
          cookieValue,
          -1,
          etc.opts.domain
        );
      }

      return canWrite;
    },

    fireForcedCreatives: function () {
      if (etc.getUrl().indexOf("etcForceCreative") >= 0) {
        return etc.fireForcedCreativeViaQueryParam();
      } else if (etc.getCookieLib().readCookie(etc.forceCreative)) {
        return etc.fireForcedCreativeViaCookie();
      }
    },

    executionWrapper: function (creativeId, execution) {
      return etc.storeCreative(
        creativeId,
        etc.opts.ignoreVirtualPageViews ? execution : etc.ifSamePageView(execution)
      );
    },

    storeCreative: function (creativeId, execution) {
      return function () {
        etc.activeCreatives[creativeId] = execution.apply(null, arguments);
      };
    },

    fireForcedCreativeViaQueryParam: function () {
      var i, ii, url, queryParam, queryParams, creative;
      url = etc.getUrl();
      try {
        queryParams = url.substring(url.indexOf("?") + 1).split("&");
      } catch (e) {
        queryParams = [];
      }
      if (queryParams.length > 0) {
        for (i = 0, ii = queryParams.length; i < ii; i += 1) {
          queryParam = queryParams[i].split("=");
          if (queryParam[0] === etc.forceCreative) {
            creative = etc.opts.creatives[queryParam[1]];
            creative.activation(etc.generateCreativeActivator(null, null, null,
              creative, -1, etc.executionWrapper(creative.id, creative.execution)));
          }
        }
        return true;
      }
      return false;
    },
    fireForcedCreativeViaCookie: function () {
      var i, ii, json, creative;
      json = JSON.parse(etc.getCookieLib().readCookie(etc.forceCreative));
      for (i = 0, ii = json.length; i < ii; i += 1) {
        creative = etc.opts.creatives[json[i]];
        creative.activation(etc.generateCreativeActivator(null, null, null,
              creative, -1, etc.executionWrapper(creative.id, creative.execution)));
      }
      if (i > 0) {
        return true;
      }
    },
    getUrl: function () {
      return document.location.href;
    },

    removeDeadCreatives: function () {
      var i, ii, k, s, e, opts, twoWeeks, now;
      twoWeeks = 1000 * 60 * 60 * 24 * 14;
      now  = (new Date()).getTime();
      s    = etc.getStatus();
      opts = etc.getOptsStatus();
      e = {};
      // get all current live experiment ids
      for (i = 0, ii = etc.opts.experiments.length; i < ii; i += 1) {
        // if paused more than two weeks, treat it as dead creative
        if (etc.opts.experiments[i].pausedAt) {
          if ((now - etc.opts.experiments[i].pausedAt) < twoWeeks) {
            e[etc.opts.experiments[i].id] = true;
          }
        } else {
          e[etc.opts.experiments[i].id] = true;
        }
      }

      // validate qb_ss_status cookie, delete variation/creative id are not exists
      // if an experiment variation is deleted, creative id in cookie may not
      // present in qb_ss config (e.g. when variation is deleted), but luckly
      // experiment id does not change
      for (k in s.c) {
        if (s.c.hasOwnProperty(k)) {
          if (!e[s.c[k].e]) {
            delete s.c[k];
          }
        }
      }

      // validate ss_opts cookie, delete variation/creative id are exists
      for (k in opts) {
        if (opts.hasOwnProperty(k) && k !== "global") {
          if (etc.opts.creatives[k]) {
            // it's in config, but it's not a live experiment
            if (!e[etc.opts.creatives[k].e_id]) {
              delete opts[k];
            }
          } else {
            // the creative is not in config, so delete it
            delete opts[k];
          }
        }
      }
      etc.writeOptsStatus(opts);
      etc.writeStatus(s);
    },

    calculateExcludedExperiments: function () {
      var id, cookies, creatives;
      cookies = etc.getStatus().c;
      creatives = etc.opts.creatives;

      for (id in cookies) {
        if (cookies.hasOwnProperty(id)) {
          // if creative id SET cookie is not set in etc.opts,
          // also the experiment id matches, it means the variation has been
          // removed, we should exclude this visitor from this specific experiment
          if (!creatives[id]) {
            etc.excludedExperiments[cookies[id].e] = true;
          }
        }
      }
    },

    inCreative: function (status) {
      var creative, inCreative;

      inCreative = false;

      for (creative in status.c) {
        if (status.c.hasOwnProperty(creative)) {
          inCreative = true;
        }
      }
      return inCreative;
    },

    generateProbability: function () {
      return Math.round(1000 * Math.random()) / 1000;
    },

    pingCookieDisabled: function () {
      window._qtd.push({
        data: {
          smartserve_cookie_disabled: 1
        }
      });
    },

    getPageViewId: function() {
      return window.__pageViewId__;
    },

    // `mergeConfig` deep merge predefined configuration with defautConfig
    // Returns false if configuration is not defined.
    // otherwise returns true if merged correctly
    mergeConfig: function () {
      if (window[etc.configKey]) {
        var x, config = window[etc.configKey];
        if (!config || !config[0]) {
          return false;
        }
        etc.opts = {};
        for (x in etc.defaultConfig) {
          if (etc.defaultConfig.hasOwnProperty(x)) {
            etc.opts[x] = etc.defaultConfig[x];
          }
        }
        etc.deepMerge(etc.opts, config[0]);
        etc.opts.pageViewId = etc.getPageViewId();
        return true;
      } else {
        return false;
      }
    },


    deepMerge: function (target, source) {
      var key, original, next;
      for (key in source) {
        if (source.hasOwnProperty(key)) {
          original = target[key];
          next = source[key];
          if (original && next && typeof next === "object") {
            etc.deepMerge(original, next);
          } else {
            target[key] = next;
          }
        }
      }
    },

    activateExistingCreatives: function () {
      var id, etcStatus, creative, statusInfo, creatives, pausedIds;
      etcStatus = etc.getStatus();
      pausedIds = etc.getPausedExperimentIds();
      creatives = JSON.parse(JSON.stringify(etcStatus.c));

      for (id in creatives) {
        if (creatives.hasOwnProperty(id)) {
          statusInfo = creatives[id];
          // paused experiment should not be activated
          if (!pausedIds.hasOwnProperty(statusInfo.e) &&
              !etc.excludedExperiments.hasOwnProperty(statusInfo.e)) {
            creative = etc.findCreativeByProbability(statusInfo.tc,
              statusInfo.ckg, statusInfo.c_prob);
            creative.activation(etc.generateCreativeActivator(statusInfo.e,
              statusInfo.tc, statusInfo.ckg, creative, statusInfo.c_prob,
              etc.executionWrapper(creative.id, etc.activateCreative)));
            etc.deployedExperiments[creative.e_id] = true;
            if (id !== creative.id) {
              delete etcStatus.c[id];
              statusInfo.c = creative.id;
              statusInfo.start = new Date().getTime();
              etcStatus.c[creative.id] = statusInfo;
            }
          }
        }
      }
      etc.writeStatus(etcStatus);
    },

    getPausedExperimentIds: function () {
      var i, ii, experiments, ids;
      experiments = etc.opts.experiments;
      ids = {};
      for (i = 0, ii = experiments.length; i < ii;  i += 1) {
        if (experiments[i].pausedAt) {
          ids[experiments[i].id] = true;
        }
      }
      return ids;
    },

    findExperimentById: function (experimentId) {
      var i, ii, experiments, experiment;
      experiments = etc.opts.experiments || [];
      for (i = 0, ii = experiments.length; i < ii; i += 1) {
        if (experiments[i].id === experimentId) {
          experiment = experiments[i];
          break;
        }
      }
      return experiment;
    },

    findCreativeByProbability: function (tcId, ckgIndex, p) {
      var tc, creativeKeyGroup, creativeIndex;
      tc = etc.opts.targetingCriteria[tcId];
      creativeKeyGroup = tc.creatives[ckgIndex];
      creativeIndex = etc.getRandomCreativeIndex(p, creativeKeyGroup);
      return etc.opts.creatives[creativeKeyGroup[creativeIndex].id];
    },

    process: function () {
      var i, ii, experiment, experiments;
      experiments = etc.opts.experiments;
      for (i = 0, ii = experiments.length; i < ii;  i += 1) {
        experiment = experiments[i];
        // ignore paused and deployed experiments
        if (!experiment.pausedAt &&
            !etc.deployedExperiments[experiment.id] &&
            !etc.excludedExperiments[experiment.id]) {
          etc.chooseTargetingCriteria(experiment);
        }
      }
    },

    chooseTargetingCriteria: function (experiment) {
      var tc;

      if (experiment.targetingCriteria.length === 1) {

        etc.fireSingleTargetingCriteria(experiment);

      } else {

        if (experiment.ordered) {
          tc = etc.chooseOrderedTargetingCriteria(experiment);
        } else {
          tc = etc.chooseRandomTargetingCriteria(experiment);
        }
        if (tc) {
          etc.setCreatives(experiment, tc, tc.creatives);
        }
      }
    },

    fireSingleTargetingCriteria: function (experiment) {

      var isSet, tc, doSet;

      isSet = false;
      tc = etc.opts.targetingCriteria[experiment.targetingCriteria[0]];

      doSet = function () {
        if (!isSet) {
          isSet = true;
          if (etc.shouldFireTargetingCriteriaBasedOnRate(tc)) {
            etc.setCreatives(experiment, tc, tc.creatives);
          }
        }
      };

      if (tc.condition(doSet)) {
        doSet();
      }
    },

    chooseOrderedTargetingCriteria: function (experiment) {
      var i, ii, tc;
      for (i = 0, ii = experiment.targetingCriteria.length; i < ii;  i += 1) {
        tc = etc.opts.targetingCriteria[experiment.targetingCriteria[i]];
        if (etc.shouldFireTargetingCriteria(tc)) {
          return tc;
        }
      }
      return null;
    },

    chooseRandomTargetingCriteria: function (experiment) {
      var tc, targetingCriteria;
      targetingCriteria = experiment.targetingCriteria.concat([]);
      while (targetingCriteria.length > 0) {
        tc = targetingCriteria.splice(etc.getRandomIndex(targetingCriteria), 1);
        tc = etc.opts.targetingCriteria[tc[0]];
        if (etc.shouldFireTargetingCriteria(tc)) {
          return tc;
        }
      }
      return null;
    },

    shouldFireTargetingCriteria: function (tc) {
      return tc.condition() && etc.shouldFireTargetingCriteriaBasedOnRate(tc);
    },

    shouldFireTargetingCriteriaBasedOnRate: function (tc) {
      return ((tc.firingRate === undef) || (Math.random() < tc.firingRate));
    },

    getRandomIndex: function (array) {
      return Math.floor(Math.random() * array.length, 10);
    },

    setCreatives: function (experiment, tc, creativeKeyGroups) {
      var i, ii, cProb, creativeKeyGroup, creativeIndex, creativeId;
      for (i = 0, ii = creativeKeyGroups.length; i < ii; i += 1) {
        creativeKeyGroup = creativeKeyGroups[i];
        cProb = etc.generateProbability();
        creativeIndex = etc.getRandomCreativeIndex(cProb, creativeKeyGroup);
        creativeId = creativeKeyGroup[creativeIndex].id;
        etc.setCreative(experiment, tc, i, etc.opts.creatives[creativeId],
          cProb);
      }
    },

    getRandomCreativeIndex: function (r, creativeKeyGroup) {
      var i, ii, total = 0;
      for (i = 0, ii = creativeKeyGroup.length; i < ii; i += 1) {
        total += creativeKeyGroup[i].p;
        if (r < total) {
          return i;
        }
      }
      return -1;
    },

    setCreative: function (experiment, tc, ckgIndex, creative, cProb) {
      etc.saveCreative(experiment, tc, ckgIndex, creative, cProb);
      creative.activation(etc.generateCreativeActivator(experiment.id,
          tc.id, ckgIndex, creative, cProb, etc.executionWrapper(creative.id, etc.activateCreative)));
    },

    saveCreative: function (experiment, tc, ckgIndex, creative, cProb) {
      var etcStatus = etc.getStatus();
      etcStatus.c[creative.id] = {
        e: experiment.id,
        tc: tc.id,
        ckg: ckgIndex,
        c: creative.id,
        c_prob: cProb,
        start: new Date().getTime()
      };
      etc.writeStatus(etcStatus);
    },

    generateCreativeActivator: function (eId, tcId, ckgIndex, creative,
        cProb, cb) {
      var checkReady, lastWait = 1;
      etc.dependencyTimers = [] || etc.dependencyTimers;
      checkReady = function () {
        if (!creative.dependencies ||
            etc.dependenciesExist(creative.dependencies)) {
          cb(eId, tcId, ckgIndex, creative, cProb);
        } else {
          lastWait *= 2;
          if (lastWait > 500) {
            lastWait = 500;
          }
          etc.dependencyTimers.push(setTimeout(checkReady, lastWait));
        }
      };
      return checkReady;
    },

    clearTimers: function () {
      each(etc.dependencyTimers, clearTimeout);
      etc.dependencyTimers = [];
    },

    dependenciesExist: function (dependencies) {
      var i, ii;
      for (i = 0, ii = dependencies.length; i < ii; i += 1) {
        try {
          if (!dependencies[i]()) {
            break;
          }
        } catch (e) {
          break;
        }
      }
      return i === ii;
    },

    activateCreative: function (eId, tcId, ckgIndex, creative, cProb) {
      var ret;
      try {
        ret = creative.execution();
        if (ret && ret.success === false) {
          return ret;
        }
        etc.pingCreativeState(eId, tcId, ckgIndex, creative, cProb, SHOWN_FLAG.SUCCESS);
      } catch (e) {
        etc.pingCreativeState(eId, tcId, ckgIndex, creative, cProb, SHOWN_FLAG.ERROR, e.message);
      }
      return ret;
    },

    isSamePageView: function (pageViewId) {
      return !pageViewId || pageViewId === etc.getPageViewId();
    },

    ifSamePageView: function (cb) {
      // store page view id on initialisation
      var pageViewId = etc.opts.pageViewId;
      return function () {
        // cancel activation if no longer on same virtual pageview
        if (!etc.isSamePageView(pageViewId)) {
          return;
        }
        return cb.apply(etc, arguments);
      };
    },

    extractProbabilty: function (creatives, cid) {
      var i, j, creativeProbabilty;
      creativeProbabilty = null;
      for (i = 0; i < creatives.length; i += 1) {
        for (j = 0; j < creatives[i].length; j += 1) {
          if (creatives[i][j].id === cid) {
            creativeProbabilty = creatives[i][j].p;
          }
        }
      }
      return creativeProbabilty;
    },


    whenUVHasTransaction: function (f) {
      clearTimeout(etc.uvHasTransactionTimeout);
      etc.uvCounter += 1;
      if (window.universal_variable && window.universal_variable.transaction) {
        f();
      } else if (etc.uvCounter < 30) {
        etc.uvHasTransactionTimeout  = setTimeout(function () {
          etc.whenUVHasTransaction(f);
        }, 1000);
      }
    },

    writeShownFlagsToUV: function () {
      if (etc.getCookieLib().readCookie("_qb_se")) {
        window.universal_variable.transaction.shown_creatives =
          etc.getShownFlags();
        window._qtd.push({
          resendUniversalVariables: 1
        });
      }
    },

    getShownFlags: function () {
      var k, a = [], c = etc.getCookieLib().readCookie("_qb_se");
      if (c) {
        try {
          c = JSON.parse(c);
          for (k in c) {
            if (c.hasOwnProperty(k)) {
              a.push({cm: k, e: c[k].e });
            }
          }
        } catch (e) {}
      }
      return a;
    },

    _storeShownFlags: function (e) {
      var c = etc.getCookieLib().readCookie("_qb_se"), i, t;
      if (!c) {
        c = {};
      } else {
        try {
          c = JSON.parse(c);
        } catch (err) {
          c = {};
        }
      }
      c[e.cm] = { e: e.e, t: +new Date() };

      // prune old cookies here (older than 30 days)
      t = +new Date();

      t -= 30 * 24 * 60 * 60 * 1000;

      for (i in c) {
        if (c.hasOwnProperty(i)) {
          if (c[i].t < t) {
            delete c[i];
          }
        }
      }

      etc.getCookieLib().writeCookie(
        "_qb_se",
        JSON.stringify(c),
        365,
        etc.opts.domain
      );
    },

    storeShownFlags: function () {
      var i, e, etcd = window.qb_etc_data;
      for (i = 0; i < etcd.length; i += 1) {
        e = etcd[i];
        if (e.s === SHOWN_FLAG.SUCCESS) {
          etc._storeShownFlags(e);
        }
      }
    },

    pingCreativeState: function (eId, tcId, ckg, creative, cProb, type, errorMessage) {
      var creativeProbabilty, creatives, ping, experiment;
      /* Try and find the creatives list */
      try {
        creatives = etc.opts.targetingCriteria[tcId].creatives;
      } catch (e) {
        creatives = [];
      }

      experiment         = etc.findExperimentById(eId);
      /* From the creatives, look for the correct one and fetch its probability */
      creativeProbabilty = etc.extractProbabilty(creatives, creative.id);


      ping = {
        e: eId,
        tc: tcId,
        ckg: ckg,
        c: creative.creative_id,
        // this is the master id of the creative
        cm: creative.id,
        p: cProb,
        s: type,
        cnt: !creative.control ? 0 : 1
      };

      if (experiment && experiment.iterationId) {
        ping.i = experiment.iterationId;
      }

      if (errorMessage) {
        ping.err_e = errorMessage;
      }

      if (creativeProbabilty !== null) {
        ping.pc = creativeProbabilty;
      }

      etc.saveAndSendPing(ping);
      etc.storeShownFlags();
    },

    uvListenerSupport: function () {
      var qubit = window.__qubit;
      return qubit && qubit.qtracker && qubit.qtracker.options && qubit.qtracker.options.uvLocation;
    },

    onQtrackerReady: function (done) {
      window._qtd = window._qtd || [];
      if (etc.isNative(window._qtd.push)) {
        setTimeout(function () {
          etc.onQtrackerReady(done);
        }, 500);
      } else {
        done();
      }
    },

    isNative: function (fn) {
      return (/\[native code\]/).test(fn.toString());
    },

    saveAndSendPing: function (ping) {
      var varName = "qb_etc_data";
      window[varName] = window[varName] || [];
      window[varName].push(ping);
      etc.onQtrackerReady(function () {
        if (etc.uvListenerSupport()) {
          etc.publishWithUV(varName);
        } else {
          etc.publishWithQtd(varName);
        }
      });
    },

    publishWithQtd: function (varName) {
      var ping = { data: {} };
      ping.data[varName] = window[varName];
      window._qtd.push(ping);
    },

    publishWithUV: function (varName) {
      var uv = (window.universal_variable = window.universal_variable || {});
      uv.qb = uv.qb || {};
      uv.qb[varName] = window[varName];
      etc.resendUVs();
    },

    resendUVs: debounce(function () {
      window._qtd.push({resendUniversalVariables: 1});
    }, 100),

    getStatus: function () {
      return etc.extractStatus(etc.getCookieLib().readCookie(etc.statusKey));
    },

    getOptsStatus: function () {
      var cookie, json;
      cookie = etc.getCookieLib().readCookie(etc.optsKey);

      if (cookie) {
        try {
          json = JSON.parse(cookie);
        } catch (e) {
          json = {};
        }
        return json;
      }

      return {};
    },

    extractStatus: function (s) {
      if (s) {
        return etc.transformToInternalJSON(JSON.parse(s));
      } else {
        return etc.createDefaultStatus();
      }
    },

    // Consume Internal JSON ETC Status JSON format
    // transform it to compact version for cookie storage
    transformToExternalJSON: function (json) {
      var key, state, compactJSON;
      compactJSON = {
        b: {}
      };

      if (json.c) {
        for (key in json.c) {
          if (json.c.hasOwnProperty(key)) {
            state = json.c[key];
            compactJSON.b[key] = [];
            compactJSON.b[key].push(state.c_prob);
            compactJSON.b[key].push(state.e);
            compactJSON.b[key].push(state.tc);
            compactJSON.b[key].push(state.ckg);
          }
        }
      }

      if (json.cg) {
        compactJSON.cg = json.cg;
      }

      return compactJSON;
    },

    // Find out if cookie is new version or old version
    // then transform the new compact version to old json format
    transformToInternalJSON: function (json) {
      var key, states, compatible;
      // Nothing to transform, this is user is in control group
      // Or still using old version of cookie, thus no need to transform
      if (!json.b) {
        return json;
      }

      // New Cookie JSON uses `b` as special bucket key
      compatible = etc.createDefaultStatus();

      // Restore Creative Group probability
      if (json.cg) {
        compatible.cg = json.cg;
      }

      // restore array to object
      for (key in json.b) {
        if (json.b.hasOwnProperty(key)) {
          // states is an array of user creative state
          // i.e. [creative prob, experiment id, targeting criteria id,
          //   creative key group]
          states = json.b[key];

          compatible.c[key] = {
            c_prob: states[0],
            e:      states[1],
            tc:     states[2],
            ckg:    states[3],
            c:      Number(key)
            // do not recreate "start" timestamp as it's not been used
          };
        }
      }

      return compatible;
    },

    createDefaultStatus: function () {
      return {
        c: {}
      };
    },

    // Update Variation State Cookies
    writeStatus: function (json) {
      var compactStatus = etc.transformToExternalJSON(json);
      etc.getCookieLib().writeCookie(
        etc.statusKey,
        JSON.stringify(compactStatus),
        365,
        etc.opts.domain
      );
    },

    // Update Activation State Cookies
    writeOptsStatus: function (json) {
      etc.getCookieLib().writeCookie(
        etc.optsKey,
        JSON.stringify(json),
        365,
        etc.opts.domain
      );
    }
  };

  return etc;
};
});

define('etc',['require','exports','module','etc.widget/etc'],function (require, exports, module) {/**
 * This is a wrapper of etc, which
 * hides a bit of the ugly API.
 */
var etc = require('etc.widget/etc')

module.exports = function (config) {
  // this is the current API for configuring etc...
  window._qb_ss = []
  window._qb_ss.push(config)
  if (window._qb_ss_alt_domain) {
    window._qb_ss[0].domain = window._qb_ss_alt_domain
  }
  return etc()
}

});

define('raven-js',['require'],function (require) {

  /*! Raven.js 1.1.19 (b51bc89) | github.com/getsentry/raven-js */

  /*
   * Includes TraceKit
   * https://github.com/getsentry/TraceKit
   *
   * Copyright 2015 Matt Robenolt and other contributors
   * Released under the BSD license
   * https://github.com/getsentry/raven-js/blob/master/LICENSE
   *
   */

  /*
   TraceKit - Cross brower stack traces - github.com/occ/TraceKit
   MIT license
  */

  var TraceKit = {
      remoteFetching: false,
      collectWindowErrors: true,
      // 3 lines before, the offending line, 3 lines after
      linesOfContext: 7
  };

  // global reference to slice
  var _slice = [].slice;
  var UNKNOWN_FUNCTION = '?';


  /**
   * TraceKit.wrap: Wrap any function in a TraceKit reporter
   * Example: func = TraceKit.wrap(func);
   *
   * @param {Function} func Function to be wrapped
   * @return {Function} The wrapped func
   */
  TraceKit.wrap = function traceKitWrapper(func) {
      function wrapped() {
          try {
              return func.apply(this, arguments);
          } catch (e) {
              TraceKit.report(e);
              throw e;
          }
      }
      return wrapped;
  };

  /**
   * TraceKit.report: cross-browser processing of unhandled exceptions
   *
   * Syntax:
   *   TraceKit.report.subscribe(function(stackInfo) { ... })
   *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
   *   TraceKit.report(exception)
   *   try { ...code... } catch(ex) { TraceKit.report(ex); }
   *
   * Supports:
   *   - Firefox: full stack trace with line numbers, plus column number
   *              on top frame; column number is not guaranteed
   *   - Opera:   full stack trace with line and column numbers
   *   - Chrome:  full stack trace with line and column numbers
   *   - Safari:  line and column number for the top frame only; some frames
   *              may be missing, and column number is not guaranteed
   *   - IE:      line and column number for the top frame only; some frames
   *              may be missing, and column number is not guaranteed
   *
   * In theory, TraceKit should work on all of the following versions:
   *   - IE5.5+ (only 8.0 tested)
   *   - Firefox 0.9+ (only 3.5+ tested)
   *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
   *     Exceptions Have Stacktrace to be enabled in opera:config)
   *   - Safari 3+ (only 4+ tested)
   *   - Chrome 1+ (only 5+ tested)
   *   - Konqueror 3.5+ (untested)
   *
   * Requires TraceKit.computeStackTrace.
   *
   * Tries to catch all unhandled exceptions and report them to the
   * subscribed handlers. Please note that TraceKit.report will rethrow the
   * exception. This is REQUIRED in order to get a useful stack trace in IE.
   * If the exception does not reach the top of the browser, you will only
   * get a stack trace from the point where TraceKit.report was called.
   *
   * Handlers receive a stackInfo object as described in the
   * TraceKit.computeStackTrace docs.
   */
  TraceKit.report = (function reportModuleWrapper() {
      var handlers = [],
          lastArgs = null,
          lastException = null,
          lastExceptionStack = null;

      /**
       * Add a crash handler.
       * @param {Function} handler
       */
      function subscribe(handler) {
          // installGlobalHandler();
          handlers.push(handler);
      }

      /**
       * Remove a crash handler.
       * @param {Function} handler
       */
      function unsubscribe(handler) {
          for (var i = handlers.length - 1; i >= 0; --i) {
              if (handlers[i] === handler) {
                  handlers.splice(i, 1);
              }
          }
      }

      /**
       * Remove all crash handlers.
       */
      function unsubscribeAll() {
          uninstallGlobalHandler();
          handlers = [];
      }

      /**
       * Dispatch stack information to all handlers.
       * @param {Object.<string, *>} stack
       */
      function notifyHandlers(stack, isWindowError) {
          var exception = null;
          if (isWindowError && !TraceKit.collectWindowErrors) {
            return;
          }
          for (var i in handlers) {
              if (hasKey(handlers, i)) {
                  try {
                      handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
                  } catch (inner) {
                      exception = inner;
                  }
              }
          }

          if (exception) {
              throw exception;
          }
      }

      var _oldOnerrorHandler, _onErrorHandlerInstalled;

      /**
       * Ensures all global unhandled exceptions are recorded.
       * Supported by Gecko and IE.
       * @param {string} message Error message.
       * @param {string} url URL of script that generated the exception.
       * @param {(number|string)} lineNo The line number at which the error
       * occurred.
       * @param {?(number|string)} colNo The column number at which the error
       * occurred.
       * @param {?Error} ex The actual Error object.
       */
      function traceKitWindowOnError(message, url, lineNo, colNo, ex) {
          var stack = null;

          if (lastExceptionStack) {
              TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
              processLastException();
          } else if (ex) {
              // New chrome and blink send along a real error object
              // Let's just report that like a normal error.
              // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
              stack = TraceKit.computeStackTrace(ex);
              notifyHandlers(stack, true);
          } else {
              var location = {
                  'url': url,
                  'line': lineNo,
                  'column': colNo
              };
              location.func = TraceKit.computeStackTrace.guessFunctionName(location.url, location.line);
              location.context = TraceKit.computeStackTrace.gatherContext(location.url, location.line);
              stack = {
                  'message': message,
                  'url': document.location.href,
                  'stack': [location]
              };
              notifyHandlers(stack, true);
          }

          if (_oldOnerrorHandler) {
              return _oldOnerrorHandler.apply(this, arguments);
          }

          return false;
      }

      function installGlobalHandler ()
      {
          if (_onErrorHandlerInstalled) {
              return;
          }
          _oldOnerrorHandler = window.onerror;
          window.onerror = traceKitWindowOnError;
          _onErrorHandlerInstalled = true;
      }

      function uninstallGlobalHandler ()
      {
          if (!_onErrorHandlerInstalled) {
              return;
          }
          window.onerror = _oldOnerrorHandler;
          _onErrorHandlerInstalled = false;
          _oldOnerrorHandler = undefined;
      }

      function processLastException() {
          var _lastExceptionStack = lastExceptionStack,
              _lastArgs = lastArgs;
          lastArgs = null;
          lastExceptionStack = null;
          lastException = null;
          notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
      }

      /**
       * Reports an unhandled Error to TraceKit.
       * @param {Error} ex
       * @param {?boolean} rethrow If false, do not re-throw the exception.
       * Only used for window.onerror to not cause an infinite loop of
       * rethrowing.
       */
      function report(ex, rethrow) {
          var args = _slice.call(arguments, 1);
          if (lastExceptionStack) {
              if (lastException === ex) {
                  return; // already caught by an inner catch block, ignore
              } else {
                processLastException();
              }
          }

          var stack = TraceKit.computeStackTrace(ex);
          lastExceptionStack = stack;
          lastException = ex;
          lastArgs = args;

          // If the stack trace is incomplete, wait for 2 seconds for
          // slow slow IE to see if onerror occurs or not before reporting
          // this exception; otherwise, we will end up with an incomplete
          // stack trace
          window.setTimeout(function () {
              if (lastException === ex) {
                  processLastException();
              }
          }, (stack.incomplete ? 2000 : 0));

          if (rethrow !== false) {
              throw ex; // re-throw to propagate to the top level (and cause window.onerror)
          }
      }

      report.subscribe = subscribe;
      report.unsubscribe = unsubscribe;
      report.uninstall = unsubscribeAll;
      return report;
  }());

  /**
   * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
   *
   * Syntax:
   *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
   * Returns:
   *   s.name              - exception name
   *   s.message           - exception message
   *   s.stack[i].url      - JavaScript or HTML file URL
   *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
   *   s.stack[i].args     - arguments passed to the function, if known
   *   s.stack[i].line     - line number, if known
   *   s.stack[i].column   - column number, if known
   *   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#
   *
   * Supports:
   *   - Firefox:  full stack trace with line numbers and unreliable column
   *               number on top frame
   *   - Opera 10: full stack trace with line and column numbers
   *   - Opera 9-: full stack trace with line numbers
   *   - Chrome:   full stack trace with line and column numbers
   *   - Safari:   line and column number for the topmost stacktrace element
   *               only
   *   - IE:       no line numbers whatsoever
   *
   * Tries to guess names of anonymous functions by looking for assignments
   * in the source code. In IE and Safari, we have to guess source file names
   * by searching for function bodies inside all page scripts. This will not
   * work for scripts that are loaded cross-domain.
   * Here be dragons: some function names may be guessed incorrectly, and
   * duplicate functions may be mismatched.
   *
   * TraceKit.computeStackTrace should only be used for tracing purposes.
   * Logging of unhandled exceptions should be done with TraceKit.report,
   * which builds on top of TraceKit.computeStackTrace and provides better
   * IE support by utilizing the window.onerror event to retrieve information
   * about the top of the stack.
   *
   * Note: In IE and Safari, no stack trace is recorded on the Error object,
   * so computeStackTrace instead walks its *own* chain of callers.
   * This means that:
   *  * in Safari, some methods may be missing from the stack trace;
   *  * in IE, the topmost function in the stack trace will always be the
   *    caller of computeStackTrace.
   *
   * This is okay for tracing (because you are likely to be calling
   * computeStackTrace from the function you want to be the topmost element
   * of the stack trace anyway), but not okay for logging unhandled
   * exceptions (because your catch block will likely be far away from the
   * inner function that actually caused the exception).
   *
   */
  TraceKit.computeStackTrace = (function computeStackTraceWrapper() {
      var debug = false,
          sourceCache = {};

      /**
       * Attempts to retrieve source code via XMLHttpRequest, which is used
       * to look up anonymous function names.
       * @param {string} url URL of source code.
       * @return {string} Source contents.
       */
      function loadSource(url) {
          if (!TraceKit.remoteFetching) { //Only attempt request if remoteFetching is on.
              return '';
          }
          try {
              var getXHR = function() {
                  try {
                      return new window.XMLHttpRequest();
                  } catch (e) {
                      // explicitly bubble up the exception if not found
                      return new window.ActiveXObject('Microsoft.XMLHTTP');
                  }
              };

              var request = getXHR();
              request.open('GET', url, false);
              request.send('');
              return request.responseText;
          } catch (e) {
              return '';
          }
      }

      /**
       * Retrieves source code from the source code cache.
       * @param {string} url URL of source code.
       * @return {Array.<string>} Source contents.
       */
      function getSource(url) {
          if (!isString(url)) return [];
          if (!hasKey(sourceCache, url)) {
              // URL needs to be able to fetched within the acceptable domain.  Otherwise,
              // cross-domain errors will be triggered.
              var source = '';
              if (url.indexOf(document.domain) !== -1) {
                  source = loadSource(url);
              }
              sourceCache[url] = source ? source.split('\n') : [];
          }

          return sourceCache[url];
      }

      /**
       * Tries to use an externally loaded copy of source code to determine
       * the name of a function by looking at the name of the variable it was
       * assigned to, if any.
       * @param {string} url URL of source code.
       * @param {(string|number)} lineNo Line number in source code.
       * @return {string} The function name, if discoverable.
       */
      function guessFunctionName(url, lineNo) {
          var reFunctionArgNames = /function ([^(]*)\(([^)]*)\)/,
              reGuessFunction = /['"]?([0-9A-Za-z$_]+)['"]?\s*[:=]\s*(function|eval|new Function)/,
              line = '',
              maxLines = 10,
              source = getSource(url),
              m;

          if (!source.length) {
              return UNKNOWN_FUNCTION;
          }

          // Walk backwards from the first line in the function until we find the line which
          // matches the pattern above, which is the function definition
          for (var i = 0; i < maxLines; ++i) {
              line = source[lineNo - i] + line;

              if (!isUndefined(line)) {
                  if ((m = reGuessFunction.exec(line))) {
                      return m[1];
                  } else if ((m = reFunctionArgNames.exec(line))) {
                      return m[1];
                  }
              }
          }

          return UNKNOWN_FUNCTION;
      }

      /**
       * Retrieves the surrounding lines from where an exception occurred.
       * @param {string} url URL of source code.
       * @param {(string|number)} line Line number in source code to centre
       * around for context.
       * @return {?Array.<string>} Lines of source code.
       */
      function gatherContext(url, line) {
          var source = getSource(url);

          if (!source.length) {
              return null;
          }

          var context = [],
              // linesBefore & linesAfter are inclusive with the offending line.
              // if linesOfContext is even, there will be one extra line
              //   *before* the offending line.
              linesBefore = Math.floor(TraceKit.linesOfContext / 2),
              // Add one extra line if linesOfContext is odd
              linesAfter = linesBefore + (TraceKit.linesOfContext % 2),
              start = Math.max(0, line - linesBefore - 1),
              end = Math.min(source.length, line + linesAfter - 1);

          line -= 1; // convert to 0-based index

          for (var i = start; i < end; ++i) {
              if (!isUndefined(source[i])) {
                  context.push(source[i]);
              }
          }

          return context.length > 0 ? context : null;
      }

      /**
       * Escapes special characters, except for whitespace, in a string to be
       * used inside a regular expression as a string literal.
       * @param {string} text The string.
       * @return {string} The escaped string literal.
       */
      function escapeRegExp(text) {
          return text.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g, '\\$&');
      }

      /**
       * Escapes special characters in a string to be used inside a regular
       * expression as a string literal. Also ensures that HTML entities will
       * be matched the same as their literal friends.
       * @param {string} body The string.
       * @return {string} The escaped string.
       */
      function escapeCodeAsRegExpForMatchingInsideHTML(body) {
          return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('"', '(?:"|&quot;)').replace(/\s+/g, '\\s+');
      }

      /**
       * Determines where a code fragment occurs in the source code.
       * @param {RegExp} re The function definition.
       * @param {Array.<string>} urls A list of URLs to search.
       * @return {?Object.<string, (string|number)>} An object containing
       * the url, line, and column number of the defined function.
       */
      function findSourceInUrls(re, urls) {
          var source, m;
          for (var i = 0, j = urls.length; i < j; ++i) {
              // console.log('searching', urls[i]);
              if ((source = getSource(urls[i])).length) {
                  source = source.join('\n');
                  if ((m = re.exec(source))) {
                      // console.log('Found function in ' + urls[i]);

                      return {
                          'url': urls[i],
                          'line': source.substring(0, m.index).split('\n').length,
                          'column': m.index - source.lastIndexOf('\n', m.index) - 1
                      };
                  }
              }
          }

          // console.log('no match');

          return null;
      }

      /**
       * Determines at which column a code fragment occurs on a line of the
       * source code.
       * @param {string} fragment The code fragment.
       * @param {string} url The URL to search.
       * @param {(string|number)} line The line number to examine.
       * @return {?number} The column number.
       */
      function findSourceInLine(fragment, url, line) {
          var source = getSource(url),
              re = new RegExp('\\b' + escapeRegExp(fragment) + '\\b'),
              m;

          line -= 1;

          if (source && source.length > line && (m = re.exec(source[line]))) {
              return m.index;
          }

          return null;
      }

      /**
       * Determines where a function was defined within the source code.
       * @param {(Function|string)} func A function reference or serialized
       * function definition.
       * @return {?Object.<string, (string|number)>} An object containing
       * the url, line, and column number of the defined function.
       */
      function findSourceByFunctionBody(func) {
          var urls = [window.location.href],
              scripts = document.getElementsByTagName('script'),
              body,
              code = '' + func,
              codeRE = /^function(?:\s+([\w$]+))?\s*\(([\w\s,]*)\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,
              eventRE = /^function on([\w$]+)\s*\(event\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/,
              re,
              parts,
              result;

          for (var i = 0; i < scripts.length; ++i) {
              var script = scripts[i];
              if (script.src) {
                  urls.push(script.src);
              }
          }

          if (!(parts = codeRE.exec(code))) {
              re = new RegExp(escapeRegExp(code).replace(/\s+/g, '\\s+'));
          }

          // not sure if this is really necessary, but I don’t have a test
          // corpus large enough to confirm that and it was in the original.
          else {
              var name = parts[1] ? '\\s+' + parts[1] : '',
                  args = parts[2].split(',').join('\\s*,\\s*');

              body = escapeRegExp(parts[3]).replace(/;$/, ';?'); // semicolon is inserted if the function ends with a comment.replace(/\s+/g, '\\s+');
              re = new RegExp('function' + name + '\\s*\\(\\s*' + args + '\\s*\\)\\s*{\\s*' + body + '\\s*}');
          }

          // look for a normal function definition
          if ((result = findSourceInUrls(re, urls))) {
              return result;
          }

          // look for an old-school event handler function
          if ((parts = eventRE.exec(code))) {
              var event = parts[1];
              body = escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);

              // look for a function defined in HTML as an onXXX handler
              re = new RegExp('on' + event + '=[\\\'"]\\s*' + body + '\\s*[\\\'"]', 'i');

              if ((result = findSourceInUrls(re, urls[0]))) {
                  return result;
              }

              // look for ???
              re = new RegExp(body);

              if ((result = findSourceInUrls(re, urls))) {
                  return result;
              }
          }

          return null;
      }

      // Contents of Exception in various browsers.
      //
      // SAFARI:
      // ex.message = Can't find variable: qq
      // ex.line = 59
      // ex.sourceId = 580238192
      // ex.sourceURL = http://...
      // ex.expressionBeginOffset = 96
      // ex.expressionCaretOffset = 98
      // ex.expressionEndOffset = 98
      // ex.name = ReferenceError
      //
      // FIREFOX:
      // ex.message = qq is not defined
      // ex.fileName = http://...
      // ex.lineNumber = 59
      // ex.columnNumber = 69
      // ex.stack = ...stack trace... (see the example below)
      // ex.name = ReferenceError
      //
      // CHROME:
      // ex.message = qq is not defined
      // ex.name = ReferenceError
      // ex.type = not_defined
      // ex.arguments = ['aa']
      // ex.stack = ...stack trace...
      //
      // INTERNET EXPLORER:
      // ex.message = ...
      // ex.name = ReferenceError
      //
      // OPERA:
      // ex.message = ...message... (see the example below)
      // ex.name = ReferenceError
      // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
      // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

      /**
       * Computes stack trace information from the stack property.
       * Chrome and Gecko use this property.
       * @param {Error} ex
       * @return {?Object.<string, *>} Stack trace information.
       */
      function computeStackTraceFromStackProp(ex) {
          if (!ex.stack) {
              return null;
          }

          var chrome = /^\s*at (.*?) ?\(?((?:file|https?|chrome-extension):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
              gecko = /^\s*(.*?)(?:\((.*?)\))?@((?:file|https?|chrome).*?):(\d+)(?::(\d+))?\s*$/i,
              lines = ex.stack.split('\n'),
              stack = [],
              parts,
              element,
              reference = /^(.*) is undefined$/.exec(ex.message);

          for (var i = 0, j = lines.length; i < j; ++i) {
              if ((parts = gecko.exec(lines[i]))) {
                  element = {
                      'url': parts[3],
                      'func': parts[1] || UNKNOWN_FUNCTION,
                      'args': parts[2] ? parts[2].split(',') : '',
                      'line': +parts[4],
                      'column': parts[5] ? +parts[5] : null
                  };
              } else if ((parts = chrome.exec(lines[i]))) {
                  element = {
                      'url': parts[2],
                      'func': parts[1] || UNKNOWN_FUNCTION,
                      'line': +parts[3],
                      'column': parts[4] ? +parts[4] : null
                  };
              } else {
                  continue;
              }

              if (!element.func && element.line) {
                  element.func = guessFunctionName(element.url, element.line);
              }

              if (element.line) {
                  element.context = gatherContext(element.url, element.line);
              }

              stack.push(element);
          }

          if (!stack.length) {
              return null;
          }

          if (stack[0].line && !stack[0].column && reference) {
              stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);
          } else if (!stack[0].column && !isUndefined(ex.columnNumber)) {
              // FireFox uses this awesome columnNumber property for its top frame
              // Also note, Firefox's column number is 0-based and everything else expects 1-based,
              // so adding 1
              stack[0].column = ex.columnNumber + 1;
          }

          return {
              'name': ex.name,
              'message': ex.message,
              'url': document.location.href,
              'stack': stack
          };
      }

      /**
       * Computes stack trace information from the stacktrace property.
       * Opera 10 uses this property.
       * @param {Error} ex
       * @return {?Object.<string, *>} Stack trace information.
       */
      function computeStackTraceFromStacktraceProp(ex) {
          // Access and store the stacktrace property before doing ANYTHING
          // else to it because Opera is not very good at providing it
          // reliably in other circumstances.
          var stacktrace = ex.stacktrace;

          var testRE = / line (\d+), column (\d+) in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\) in (.*):\s*$/i,
              lines = stacktrace.split('\n'),
              stack = [],
              parts;

          for (var i = 0, j = lines.length; i < j; i += 2) {
              if ((parts = testRE.exec(lines[i]))) {
                  var element = {
                      'line': +parts[1],
                      'column': +parts[2],
                      'func': parts[3] || parts[4],
                      'args': parts[5] ? parts[5].split(',') : [],
                      'url': parts[6]
                  };

                  if (!element.func && element.line) {
                      element.func = guessFunctionName(element.url, element.line);
                  }
                  if (element.line) {
                      try {
                          element.context = gatherContext(element.url, element.line);
                      } catch (exc) {}
                  }

                  if (!element.context) {
                      element.context = [lines[i + 1]];
                  }

                  stack.push(element);
              }
          }

          if (!stack.length) {
              return null;
          }

          return {
              'name': ex.name,
              'message': ex.message,
              'url': document.location.href,
              'stack': stack
          };
      }

      /**
       * NOT TESTED.
       * Computes stack trace information from an error message that includes
       * the stack trace.
       * Opera 9 and earlier use this method if the option to show stack
       * traces is turned on in opera:config.
       * @param {Error} ex
       * @return {?Object.<string, *>} Stack information.
       */
      function computeStackTraceFromOperaMultiLineMessage(ex) {
          // Opera includes a stack trace into the exception message. An example is:
          //
          // Statement on line 3: Undefined variable: undefinedFunc
          // Backtrace:
          //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js: In function zzz
          //         undefinedFunc(a);
          //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function yyy
          //           zzz(x, y, z);
          //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html: In function xxx
          //           yyy(a, a, a);
          //   Line 1 of function script
          //     try { xxx('hi'); return false; } catch(ex) { TraceKit.report(ex); }
          //   ...

          var lines = ex.message.split('\n');
          if (lines.length < 4) {
              return null;
          }

          var lineRE1 = /^\s*Line (\d+) of linked script ((?:file|https?)\S+)(?:: in function (\S+))?\s*$/i,
              lineRE2 = /^\s*Line (\d+) of inline#(\d+) script in ((?:file|https?)\S+)(?:: in function (\S+))?\s*$/i,
              lineRE3 = /^\s*Line (\d+) of function script\s*$/i,
              stack = [],
              scripts = document.getElementsByTagName('script'),
              inlineScriptBlocks = [],
              parts,
              i,
              len,
              source;

          for (i in scripts) {
              if (hasKey(scripts, i) && !scripts[i].src) {
                  inlineScriptBlocks.push(scripts[i]);
              }
          }

          for (i = 2, len = lines.length; i < len; i += 2) {
              var item = null;
              if ((parts = lineRE1.exec(lines[i]))) {
                  item = {
                      'url': parts[2],
                      'func': parts[3],
                      'line': +parts[1]
                  };
              } else if ((parts = lineRE2.exec(lines[i]))) {
                  item = {
                      'url': parts[3],
                      'func': parts[4]
                  };
                  var relativeLine = (+parts[1]); // relative to the start of the <SCRIPT> block
                  var script = inlineScriptBlocks[parts[2] - 1];
                  if (script) {
                      source = getSource(item.url);
                      if (source) {
                          source = source.join('\n');
                          var pos = source.indexOf(script.innerText);
                          if (pos >= 0) {
                              item.line = relativeLine + source.substring(0, pos).split('\n').length;
                          }
                      }
                  }
              } else if ((parts = lineRE3.exec(lines[i]))) {
                  var url = window.location.href.replace(/#.*$/, ''),
                      line = parts[1];
                  var re = new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[i + 1]));
                  source = findSourceInUrls(re, [url]);
                  item = {
                      'url': url,
                      'line': source ? source.line : line,
                      'func': ''
                  };
              }

              if (item) {
                  if (!item.func) {
                      item.func = guessFunctionName(item.url, item.line);
                  }
                  var context = gatherContext(item.url, item.line);
                  var midline = (context ? context[Math.floor(context.length / 2)] : null);
                  if (context && midline.replace(/^\s*/, '') === lines[i + 1].replace(/^\s*/, '')) {
                      item.context = context;
                  } else {
                      // if (context) alert("Context mismatch. Correct midline:\n" + lines[i+1] + "\n\nMidline:\n" + midline + "\n\nContext:\n" + context.join("\n") + "\n\nURL:\n" + item.url);
                      item.context = [lines[i + 1]];
                  }
                  stack.push(item);
              }
          }
          if (!stack.length) {
              return null; // could not parse multiline exception message as Opera stack trace
          }

          return {
              'name': ex.name,
              'message': lines[0],
              'url': document.location.href,
              'stack': stack
          };
      }

      /**
       * Adds information about the first frame to incomplete stack traces.
       * Safari and IE require this to get complete data on the first frame.
       * @param {Object.<string, *>} stackInfo Stack trace information from
       * one of the compute* methods.
       * @param {string} url The URL of the script that caused an error.
       * @param {(number|string)} lineNo The line number of the script that
       * caused an error.
       * @param {string=} message The error generated by the browser, which
       * hopefully contains the name of the object that caused the error.
       * @return {boolean} Whether or not the stack information was
       * augmented.
       */
      function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
          var initial = {
              'url': url,
              'line': lineNo
          };

          if (initial.url && initial.line) {
              stackInfo.incomplete = false;

              if (!initial.func) {
                  initial.func = guessFunctionName(initial.url, initial.line);
              }

              if (!initial.context) {
                  initial.context = gatherContext(initial.url, initial.line);
              }

              var reference = / '([^']+)' /.exec(message);
              if (reference) {
                  initial.column = findSourceInLine(reference[1], initial.url, initial.line);
              }

              if (stackInfo.stack.length > 0) {
                  if (stackInfo.stack[0].url === initial.url) {
                      if (stackInfo.stack[0].line === initial.line) {
                          return false; // already in stack trace
                      } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                          stackInfo.stack[0].line = initial.line;
                          stackInfo.stack[0].context = initial.context;
                          return false;
                      }
                  }
              }

              stackInfo.stack.unshift(initial);
              stackInfo.partial = true;
              return true;
          } else {
              stackInfo.incomplete = true;
          }

          return false;
      }

      /**
       * Computes stack trace information by walking the arguments.caller
       * chain at the time the exception occurred. This will cause earlier
       * frames to be missed but is the only way to get any stack trace in
       * Safari and IE. The top frame is restored by
       * {@link augmentStackTraceWithInitialElement}.
       * @param {Error} ex
       * @return {?Object.<string, *>} Stack trace information.
       */
      function computeStackTraceByWalkingCallerChain(ex, depth) {
          var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
              stack = [],
              funcs = {},
              recursion = false,
              parts,
              item,
              source;

          for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
              if (curr === computeStackTrace || curr === TraceKit.report) {
                  // console.log('skipping internal function');
                  continue;
              }

              item = {
                  'url': null,
                  'func': UNKNOWN_FUNCTION,
                  'line': null,
                  'column': null
              };

              if (curr.name) {
                  item.func = curr.name;
              } else if ((parts = functionName.exec(curr.toString()))) {
                  item.func = parts[1];
              }

              if ((source = findSourceByFunctionBody(curr))) {
                  item.url = source.url;
                  item.line = source.line;

                  if (item.func === UNKNOWN_FUNCTION) {
                      item.func = guessFunctionName(item.url, item.line);
                  }

                  var reference = / '([^']+)' /.exec(ex.message || ex.description);
                  if (reference) {
                      item.column = findSourceInLine(reference[1], source.url, source.line);
                  }
              }

              if (funcs['' + curr]) {
                  recursion = true;
              }else{
                  funcs['' + curr] = true;
              }

              stack.push(item);
          }

          if (depth) {
              // console.log('depth is ' + depth);
              // console.log('stack is ' + stack.length);
              stack.splice(0, depth);
          }

          var result = {
              'name': ex.name,
              'message': ex.message,
              'url': document.location.href,
              'stack': stack
          };
          augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
          return result;
      }

      /**
       * Computes a stack trace for an exception.
       * @param {Error} ex
       * @param {(string|number)=} depth
       */
      function computeStackTrace(ex, depth) {
          var stack = null;
          depth = (depth == null ? 0 : +depth);

          try {
              // This must be tried first because Opera 10 *destroys*
              // its stacktrace property if you try to access the stack
              // property first!!
              stack = computeStackTraceFromStacktraceProp(ex);
              if (stack) {
                  return stack;
              }
          } catch (e) {
              if (debug) {
                  throw e;
              }
          }

          try {
              stack = computeStackTraceFromStackProp(ex);
              if (stack) {
                  return stack;
              }
          } catch (e) {
              if (debug) {
                  throw e;
              }
          }

          try {
              stack = computeStackTraceFromOperaMultiLineMessage(ex);
              if (stack) {
                  return stack;
              }
          } catch (e) {
              if (debug) {
                  throw e;
              }
          }

          try {
              stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
              if (stack) {
                  return stack;
              }
          } catch (e) {
              if (debug) {
                  throw e;
              }
          }

          return {};
      }

      computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
      computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;
      computeStackTrace.guessFunctionName = guessFunctionName;
      computeStackTrace.gatherContext = gatherContext;

      return computeStackTrace;
  }());

  

  // First, check for JSON support
  // If there is no JSON, we no-op the core features of Raven
  // since JSON is required to encode the payload
  var _Raven = window.Raven,
      hasJSON = !!(typeof JSON === 'object' && JSON.stringify),
      lastCapturedException,
      lastEventId,
      globalServer,
      globalUser,
      globalKey,
      globalProject,
      globalOptions = {
          logger: 'javascript',
          ignoreErrors: [],
          ignoreUrls: [],
          whitelistUrls: [],
          includePaths: [],
          collectWindowErrors: true,
          tags: {},
          maxMessageLength: 100,
          extra: {}
      },
      authQueryString,
      isRavenInstalled = false,

      objectPrototype = Object.prototype,
      startTime = now();

  /*
   * The core Raven singleton
   *
   * @this {Raven}
   */
  var Raven = {
      VERSION: '1.1.19',

      debug: true,

      /*
       * Allow multiple versions of Raven to be installed.
       * Strip Raven from the global context and returns the instance.
       *
       * @return {Raven}
       */
      noConflict: function() {
          window.Raven = _Raven;
          return Raven;
      },

      /*
       * Configure Raven with a DSN and extra options
       *
       * @param {string} dsn The public Sentry DSN
       * @param {object} options Optional set of of global options [optional]
       * @return {Raven}
       */
      config: function(dsn, options) {
          if (globalServer) {
              logDebug('error', 'Error: Raven has already been configured');
              return Raven;
          }
          if (!dsn) return Raven;

          var uri = parseDSN(dsn),
              lastSlash = uri.path.lastIndexOf('/'),
              path = uri.path.substr(1, lastSlash);

          // merge in options
          if (options) {
              each(options, function(key, value){
                  globalOptions[key] = value;
              });
          }

          // "Script error." is hard coded into browsers for errors that it can't read.
          // this is the result of a script being pulled in from an external domain and CORS.
          globalOptions.ignoreErrors.push(/^Script error\.?$/);
          globalOptions.ignoreErrors.push(/^Javascript error: Script error\.? on line 0$/);

          // join regexp rules into one big rule
          globalOptions.ignoreErrors = joinRegExp(globalOptions.ignoreErrors);
          globalOptions.ignoreUrls = globalOptions.ignoreUrls.length ? joinRegExp(globalOptions.ignoreUrls) : false;
          globalOptions.whitelistUrls = globalOptions.whitelistUrls.length ? joinRegExp(globalOptions.whitelistUrls) : false;
          globalOptions.includePaths = joinRegExp(globalOptions.includePaths);

          globalKey = uri.user;
          globalProject = uri.path.substr(lastSlash + 1);

          // assemble the endpoint from the uri pieces
          globalServer = '//' + uri.host +
                        (uri.port ? ':' + uri.port : '') +
                        '/' + path + 'api/' + globalProject + '/store/';

          if (uri.protocol) {
              globalServer = uri.protocol + ':' + globalServer;
          }

          if (globalOptions.fetchContext) {
              TraceKit.remoteFetching = true;
          }

          if (globalOptions.linesOfContext) {
              TraceKit.linesOfContext = globalOptions.linesOfContext;
          }

          TraceKit.collectWindowErrors = !!globalOptions.collectWindowErrors;

          setAuthQueryString();

          // return for chaining
          return Raven;
      },

      /*
       * Installs a global window.onerror error handler
       * to capture and report uncaught exceptions.
       * At this point, install() is required to be called due
       * to the way TraceKit is set up.
       *
       * @return {Raven}
       */
      install: function() {
          if (isSetup() && !isRavenInstalled) {
              TraceKit.report.subscribe(handleStackInfo);
              isRavenInstalled = true;
          }

          return Raven;
      },

      /*
       * Wrap code within a context so Raven can capture errors
       * reliably across domains that is executed immediately.
       *
       * @param {object} options A specific set of options for this context [optional]
       * @param {function} func The callback to be immediately executed within the context
       * @param {array} args An array of arguments to be called with the callback [optional]
       */
      context: function(options, func, args) {
          if (isFunction(options)) {
              args = func || [];
              func = options;
              options = undefined;
          }

          return Raven.wrap(options, func).apply(this, args);
      },

      /*
       * Wrap code within a context and returns back a new function to be executed
       *
       * @param {object} options A specific set of options for this context [optional]
       * @param {function} func The function to be wrapped in a new context
       * @return {function} The newly wrapped functions with a context
       */
      wrap: function(options, func) {
          // 1 argument has been passed, and it's not a function
          // so just return it
          if (isUndefined(func) && !isFunction(options)) {
              return options;
          }

          // options is optional
          if (isFunction(options)) {
              func = options;
              options = undefined;
          }

          // At this point, we've passed along 2 arguments, and the second one
          // is not a function either, so we'll just return the second argument.
          if (!isFunction(func)) {
              return func;
          }

          // We don't wanna wrap it twice!
          if (func.__raven__) {
              return func;
          }

          function wrapped() {
              var args = [], i = arguments.length,
                  deep = !options || options && options.deep !== false;
              // Recursively wrap all of a function's arguments that are
              // functions themselves.

              while(i--) args[i] = deep ? Raven.wrap(options, arguments[i]) : arguments[i];

              try {
                  /*jshint -W040*/
                  return func.apply(this, args);
              } catch(e) {
                  Raven.captureException(e, options);
                  throw e;
              }
          }

          // copy over properties of the old function
          for (var property in func) {
              if (hasKey(func, property)) {
                  wrapped[property] = func[property];
              }
          }

          // Signal that this function has been wrapped already
          // for both debugging and to prevent it to being wrapped twice
          wrapped.__raven__ = true;
          wrapped.__inner__ = func;

          return wrapped;
      },

      /*
       * Uninstalls the global error handler.
       *
       * @return {Raven}
       */
      uninstall: function() {
          TraceKit.report.uninstall();
          isRavenInstalled = false;

          return Raven;
      },

      /*
       * Manually capture an exception and send it over to Sentry
       *
       * @param {error} ex An exception to be logged
       * @param {object} options A specific set of options for this error [optional]
       * @return {Raven}
       */
      captureException: function(ex, options) {
          // If not an Error is passed through, recall as a message instead
          if (!isError(ex)) return Raven.captureMessage(ex, options);

          // Store the raw exception object for potential debugging and introspection
          lastCapturedException = ex;

          // TraceKit.report will re-raise any exception passed to it,
          // which means you have to wrap it in try/catch. Instead, we
          // can wrap it here and only re-raise if TraceKit.report
          // raises an exception different from the one we asked to
          // report on.
          try {
              TraceKit.report(ex, options);
          } catch(ex1) {
              if(ex !== ex1) {
                  throw ex1;
              }
          }

          return Raven;
      },

      /*
       * Manually send a message to Sentry
       *
       * @param {string} msg A plain message to be captured in Sentry
       * @param {object} options A specific set of options for this message [optional]
       * @return {Raven}
       */
      captureMessage: function(msg, options) {
          // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an
          // early call; we'll error on the side of logging anything called before configuration since it's
          // probably something you should see:
          if (!!globalOptions.ignoreErrors.test && globalOptions.ignoreErrors.test(msg)) {
              return;
          }

          // Fire away!
          send(
              objectMerge({
                  message: msg + ''  // Make sure it's actually a string
              }, options)
          );

          return Raven;
      },

      /*
       * Set/clear a user to be sent along with the payload.
       *
       * @param {object} user An object representing user data [optional]
       * @return {Raven}
       */
      setUserContext: function(user) {
          globalUser = user;

          return Raven;
      },

      /*
       * Set extra attributes to be sent along with the payload.
       *
       * @param {object} extra An object representing extra data [optional]
       * @return {Raven}
       */
      setExtraContext: function(extra) {
          globalOptions.extra = extra || {};

          return Raven;
      },

      /*
       * Set tags to be sent along with the payload.
       *
       * @param {object} tags An object representing tags [optional]
       * @return {Raven}
       */
      setTagsContext: function(tags) {
          globalOptions.tags = tags || {};

          return Raven;
      },

      /*
       * Set release version of application
       *
       * @param {string} release Typically something like a git SHA to identify version
       * @return {Raven}
       */
      setReleaseContext: function(release) {
          globalOptions.release = release;

          return Raven;
      },

      /*
       * Set the dataCallback option
       *
       * @param {function} callback The callback to run which allows the
       *                            data blob to be mutated before sending
       * @return {Raven}
       */
      setDataCallback: function(callback) {
          globalOptions.dataCallback = callback;

          return Raven;
      },

      /*
       * Set the shouldSendCallback option
       *
       * @param {function} callback The callback to run which allows
       *                            introspecting the blob before sending
       * @return {Raven}
       */
      setShouldSendCallback: function(callback) {
          globalOptions.shouldSendCallback = callback;

          return Raven;
      },

      /*
       * Get the latest raw exception that was captured by Raven.
       *
       * @return {error}
       */
      lastException: function() {
          return lastCapturedException;
      },

      /*
       * Get the last event id
       *
       * @return {string}
       */
      lastEventId: function() {
          return lastEventId;
      },

      /*
       * Determine if Raven is setup and ready to go.
       *
       * @return {boolean}
       */
      isSetup: function() {
          return isSetup();
      }
  };

  Raven.setUser = Raven.setUserContext; // To be deprecated

  function triggerEvent(eventType, options) {
      var event, key;

      options = options || {};

      eventType = 'raven' + eventType.substr(0,1).toUpperCase() + eventType.substr(1);

      if (document.createEvent) {
          event = document.createEvent('HTMLEvents');
          event.initEvent(eventType, true, true);
      } else {
          event = document.createEventObject();
          event.eventType = eventType;
      }

      for (key in options) if (hasKey(options, key)) {
          event[key] = options[key];
      }

      if (document.createEvent) {
          // IE9 if standards
          document.dispatchEvent(event);
      } else {
          // IE8 regardless of Quirks or Standards
          // IE9 if quirks
          try {
              document.fireEvent('on' + event.eventType.toLowerCase(), event);
          } catch(e) {}
      }
  }

  var dsnKeys = 'source protocol user pass host port path'.split(' '),
      dsnPattern = /^(?:(\w+):)?\/\/(\w+)(:\w+)?@([\w\.-]+)(?::(\d+))?(\/.*)/;

  function RavenConfigError(message) {
      this.name = 'RavenConfigError';
      this.message = message;
  }
  RavenConfigError.prototype = new Error();
  RavenConfigError.prototype.constructor = RavenConfigError;

  /**** Private functions ****/
  function parseDSN(str) {
      var m = dsnPattern.exec(str),
          dsn = {},
          i = 7;

      try {
          while (i--) dsn[dsnKeys[i]] = m[i] || '';
      } catch(e) {
          throw new RavenConfigError('Invalid DSN: ' + str);
      }

      if (dsn.pass)
          throw new RavenConfigError('Do not specify your private key in the DSN!');

      return dsn;
  }

  function isUndefined(what) {
      return what === void 0;
  }

  function isFunction(what) {
      return typeof what === 'function';
  }

  function isString(what) {
      return objectPrototype.toString.call(what) === '[object String]';
  }

  function isObject(what) {
      return typeof what === 'object' && what !== null;
  }

  function isEmptyObject(what) {
      for (var k in what) return false;
      return true;
  }

  // Sorta yanked from https://github.com/joyent/node/blob/aa3b4b4/lib/util.js#L560
  // with some tiny modifications
  function isError(what) {
      return isObject(what) &&
          objectPrototype.toString.call(what) === '[object Error]' ||
          what instanceof Error;
  }

  /**
   * hasKey, a better form of hasOwnProperty
   * Example: hasKey(MainHostObject, property) === true/false
   *
   * @param {Object} host object to check property
   * @param {string} key to check
   */
  function hasKey(object, key) {
      return objectPrototype.hasOwnProperty.call(object, key);
  }

  function each(obj, callback) {
      var i, j;

      if (isUndefined(obj.length)) {
          for (i in obj) {
              if (hasKey(obj, i)) {
                  callback.call(null, i, obj[i]);
              }
          }
      } else {
          j = obj.length;
          if (j) {
              for (i = 0; i < j; i++) {
                  callback.call(null, i, obj[i]);
              }
          }
      }
  }


  function setAuthQueryString() {
      authQueryString =
          '?sentry_version=4' +
          '&sentry_client=raven-js/' + Raven.VERSION +
          '&sentry_key=' + globalKey;
  }


  function handleStackInfo(stackInfo, options) {
      var frames = [];

      if (stackInfo.stack && stackInfo.stack.length) {
          each(stackInfo.stack, function(i, stack) {
              var frame = normalizeFrame(stack);
              if (frame) {
                  frames.push(frame);
              }
          });
      }

      triggerEvent('handle', {
          stackInfo: stackInfo,
          options: options
      });

      processException(
          stackInfo.name,
          stackInfo.message,
          stackInfo.url,
          stackInfo.lineno,
          frames,
          options
      );
  }

  function normalizeFrame(frame) {
      if (!frame.url) return;

      // normalize the frames data
      var normalized = {
          filename:   frame.url,
          lineno:     frame.line,
          colno:      frame.column,
          'function': frame.func || '?'
      }, context = extractContextFromFrame(frame), i;

      if (context) {
          var keys = ['pre_context', 'context_line', 'post_context'];
          i = 3;
          while (i--) normalized[keys[i]] = context[i];
      }

      normalized.in_app = !( // determine if an exception came from outside of our app
          // first we check the global includePaths list.
          !globalOptions.includePaths.test(normalized.filename) ||
          // Now we check for fun, if the function name is Raven or TraceKit
          /(Raven|TraceKit)\./.test(normalized['function']) ||
          // finally, we do a last ditch effort and check for raven.min.js
          /raven\.(min\.)?js$/.test(normalized.filename)
      );

      return normalized;
  }

  function extractContextFromFrame(frame) {
      // immediately check if we should even attempt to parse a context
      if (!frame.context || !globalOptions.fetchContext) return;

      var context = frame.context,
          pivot = ~~(context.length / 2),
          i = context.length, isMinified = false;

      while (i--) {
          // We're making a guess to see if the source is minified or not.
          // To do that, we make the assumption if *any* of the lines passed
          // in are greater than 300 characters long, we bail.
          // Sentry will see that there isn't a context
          if (context[i].length > 300) {
              isMinified = true;
              break;
          }
      }

      if (isMinified) {
          // The source is minified and we don't know which column. Fuck it.
          if (isUndefined(frame.column)) return;

          // If the source is minified and has a frame column
          // we take a chunk of the offending line to hopefully shed some light
          return [
              [],  // no pre_context
              context[pivot].substr(frame.column, 50), // grab 50 characters, starting at the offending column
              []   // no post_context
          ];
      }

      return [
          context.slice(0, pivot),    // pre_context
          context[pivot],             // context_line
          context.slice(pivot + 1)    // post_context
      ];
  }

  function processException(type, message, fileurl, lineno, frames, options) {
      var stacktrace, label, i;

      // In some instances message is not actually a string, no idea why,
      // so we want to always coerce it to one.
      message += '';

      // Sometimes an exception is getting logged in Sentry as
      // <no message value>
      // This can only mean that the message was falsey since this value
      // is hardcoded into Sentry itself.
      // At this point, if the message is falsey, we bail since it's useless
      if (type === 'Error' && !message) return;

      if (globalOptions.ignoreErrors.test(message)) return;

      if (frames && frames.length) {
          fileurl = frames[0].filename || fileurl;
          // Sentry expects frames oldest to newest
          // and JS sends them as newest to oldest
          frames.reverse();
          stacktrace = {frames: frames};
      } else if (fileurl) {
          stacktrace = {
              frames: [{
                  filename: fileurl,
                  lineno: lineno,
                  in_app: true
              }]
          };
      }

      // Truncate the message to a max of characters
      message = truncate(message, globalOptions.maxMessageLength);

      if (globalOptions.ignoreUrls && globalOptions.ignoreUrls.test(fileurl)) return;
      if (globalOptions.whitelistUrls && !globalOptions.whitelistUrls.test(fileurl)) return;

      label = lineno ? message + ' at ' + lineno : message;

      // Fire away!
      send(
          objectMerge({
              // sentry.interfaces.Exception
              exception: {
                  type: type,
                  value: message
              },
              // sentry.interfaces.Stacktrace
              stacktrace: stacktrace,
              culprit: fileurl,
              message: label
          }, options)
      );
  }

  function objectMerge(obj1, obj2) {
      if (!obj2) {
          return obj1;
      }
      each(obj2, function(key, value){
          obj1[key] = value;
      });
      return obj1;
  }

  function truncate(str, max) {
      return str.length <= max ? str : str.substr(0, max) + '\u2026';
  }

  function now() {
      return +new Date();
  }

  function getHttpData() {
      var http = {
          url: document.location.href,
          headers: {
              'User-Agent': navigator.userAgent
          }
      };

      if (document.referrer) {
          http.headers.Referer = document.referrer;
      }

      return http;
  }

  function send(data) {
      if (!isSetup()) return;

      data = objectMerge({
          project: globalProject,
          logger: globalOptions.logger,
          platform: 'javascript',
          // sentry.interfaces.Http
          request: getHttpData()
      }, data);

      // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge
      data.tags = objectMerge(objectMerge({}, globalOptions.tags), data.tags);
      data.extra = objectMerge(objectMerge({}, globalOptions.extra), data.extra);

      // Send along our own collected metadata with extra
      data.extra = objectMerge({
          'session:duration': now() - startTime
      }, data.extra);

      // If there are no tags/extra, strip the key from the payload alltogther.
      if (isEmptyObject(data.tags)) delete data.tags;

      if (globalUser) {
          // sentry.interfaces.User
          data.user = globalUser;
      }

      // Include the release iff it's defined in globalOptions
      if (globalOptions.release) data.release = globalOptions.release;

      if (isFunction(globalOptions.dataCallback)) {
          data = globalOptions.dataCallback(data) || data;
      }

      // Why??????????
      if (!data || isEmptyObject(data)) {
          return;
      }

      // Check if the request should be filtered or not
      if (isFunction(globalOptions.shouldSendCallback) && !globalOptions.shouldSendCallback(data)) {
          return;
      }

      // Send along an event_id if not explicitly passed.
      // This event_id can be used to reference the error within Sentry itself.
      // Set lastEventId after we know the error should actually be sent
      lastEventId = data.event_id || (data.event_id = uuid4());

      makeRequest(data);
  }


  function makeRequest(data) {
      var img = newImage(),
          src = globalServer + authQueryString + '&sentry_data=' + encodeURIComponent(JSON.stringify(data));

      img.crossOrigin = 'anonymous';
      img.onload = function success() {
          triggerEvent('success', {
              data: data,
              src: src
          });
      };
      img.onerror = img.onabort = function failure() {
          triggerEvent('failure', {
              data: data,
              src: src
          });
      };
      img.src = src;
  }

  // Note: this is shitty, but I can't figure out how to get
  // sinon to stub document.createElement without breaking everything
  // so this wrapper is just so I can stub it for tests.
  function newImage() {
      return document.createElement('img');
  }

  function isSetup() {
      if (!hasJSON) return false;  // needs JSON support
      if (!globalServer) {
          logDebug('error', 'Error: Raven has not been configured.');
          return false;
      }
      return true;
  }

  function joinRegExp(patterns) {
      // Combine an array of regular expressions and strings into one large regexp
      // Be mad.
      var sources = [],
          i = 0, len = patterns.length,
          pattern;

      for (; i < len; i++) {
          pattern = patterns[i];
          if (isString(pattern)) {
              // If it's a string, we need to escape it
              // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
              sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"));
          } else if (pattern && pattern.source) {
              // If it's a regexp already, we want to extract the source
              sources.push(pattern.source);
          }
          // Intentionally skip other cases
      }
      return new RegExp(sources.join('|'), 'i');
  }

  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
  function uuid4() {
      return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r = Math.random()*16|0,
              v = c == 'x' ? r : (r&0x3|0x8);
          return v.toString(16);
      });
  }

  function logDebug(level, message) {
      if (window.console && console[level] && Raven.debug) {
          console[level](message);
      }
  }

  return Raven

});

define('error_pinger',['require','raven-js'],function (require) {
  var Raven = require('raven-js')

  return function createErrorPinger (config) {
    Raven.config(config.sentryConfig.dsn, {
      release: config.version,
      trackingId: config.trackingId,
      collectWindowErrors: false
    })
    return Raven.install()
  }
})
;
define('polyfill_uv',[],function () {
  return function polyfillUV (config, cb) {
    // bail if there's uv but it's broken/foreign
    var uvConflict = !!(window.uv && !window.uv.emit)
    if (uvConflict) {
      window._qtd = window._qtd || []
      window._qtd.push({
        data: {
          uvConflict: true
        }
      })
      return cb()
    }

    // bail lif there is already a UV API
    var uvApiPresent = !!(window.uv && window.uv.emit)
    if (uvApiPresent) {
      return cb(window.uv)
    }

    // check if we've explicitly to not polyfill
    if (config.UV_API_OFF) {
      return cb()
    }

    // otherwise - create UV API
    require(['@qubit/uv-api@*'], function () {
      cb(window.uv)
    })
  }
})
;
/**
 * This this the top level smartserve.js function.
 * It kicks everything off.
 */
define('smartserve',['./normalize_endpoints','./create_etc_config','./preview_loader/index','preview_loader/lib/is_preview_mode','visitor','./create_jolt','./start_uv_mapper','./start_membership_engine','./export_api','./etc','./error_pinger','./polyfill_uv'],function () {
  var normalizeEndpoints = require('./normalize_endpoints')
  var createEtcConfig = require('./create_etc_config')
  var previewLoader = require('./preview_loader/index')
  var isPreviewMode = require('preview_loader/lib/is_preview_mode').isPreviewMode
  var Visitor = require('visitor')
  var createJolt = require('./create_jolt')
  var startUVMapper = require('./start_uv_mapper')
  var startMembershipEngine = require('./start_membership_engine')
  var exportApi = require('./export_api')
  var createEtc = require('./etc')
  var createErrorPinger = require('./error_pinger')
  var polyfillUV = require('./polyfill_uv')

  return function smartserve (config, requirejs) {
    // ensure Qubit namespace is ready to be used
    window.__qubit = window.__qubit || {}
    window.__qubit.smartserve = window.__qubit.smartserve || {}

    config.isPreviewMode = isPreviewMode()

    // normalize the endpoint protocols depending
    // on the current URL
    normalizeEndpoints(config)

    // early check to see if we should actually
    // be loading a preview instead
    if (previewLoader.shouldLoadPreview()) {
      window._ss_debug = true
      return previewLoader.loadPreview()
    }

    if (document.location.href.indexOf('smartserve_debug') > -1) {
      window._ss_debug = true
    }

    // drop in some globals
    window.__qubit.smartserve.version = config.version
    window.__qubit.feedbackProfileId = config.feedbackProfileId || -1

    // configure the require.js loader
    requirejs.config({
      map: {
        '*': {
          'jquery': '@qubit---jquery@1.8.2'
        }
      }
    })
    requirejs.config({
      paths: {
        'deliver-modules': config.endpoints.deliverModules + '/deliver-modules'
      },
      map: config.amd.map,
      packages: config.amd.packages,
      waitSeconds: 20
    })

    // ok, now we need to do some juggling to load in some modules into
    // require.js context
    polyfillUV(config, function (uv) {
      // dynamic business
      var dynamicModuleIds = []
      for (var key in config.dynamicModuleIds) {
        if (config.dynamicModuleIds.hasOwnProperty(key)) {
          dynamicModuleIds.push(config.dynamicModuleIds[key])
        }
      }

      require(dynamicModuleIds, function () {
        var dynamicModules = {}
        for (var key in config.dynamicModuleIds) {
          if (config.dynamicModuleIds.hasOwnProperty(key)) {
            dynamicModules[key] = require(config.dynamicModuleIds[key])
          }
        }

        // deja vu
        dynamicModules = dynamicModules

        // while dynamic modules, are raw dynamically required modules
        // context stores DI style instantiated modules that we'll be
        // passing around to anyone who needs those
        var context = {
          uv: uv
        }

        if (config.flags.PROFILES && config.sentryConfig) {
          context.errorPinger = createErrorPinger(config)
        }

        context.uvMapper = startUVMapper(config, context, dynamicModules)
        context.jolt = createJolt(config, context, dynamicModules)
        if (context.jolt) {
          context.membershipEngine = startMembershipEngine(config, context, dynamicModules)
          context.jolt.start()
        }

        // create etc, this is the A/B testing framework
        var etc = createEtc(createEtcConfig(config, context))

        // create an api object that we'll
        // return and also expose to the window
        var api = {
          start: function () {
            Visitor.update()
            window.__qubit.smartserve.stop()
            etc.start()
          },
          stop: function () {
            if (etc && etc.stop) {
              etc.stop()
            }
            window.__qubit.smartserve.exclusivityLock = false
          }
        }

        // export the smartserve API to window
        exportApi(api, context)

        // require all dependencies that might be needed for any of the layers
        // (they're already bundled, we just need to require so that they're
        // loaded in context and we can do stuff like require("@qubit/layer")
        // synchronously) (see http://requirejs.org/docs/errors.html#notloaded)
        // TODO Remove this prerequire in the future and instead require dynamically
        // right before activating/executing layers - it's ok to prerequire
        // Layer, but pulling in *all* dependencies should be defered as much as
        // possible for performance (e.g. imagine pulling in Survey component, when
        // we're not gonna fire Survey on this particular page)
        require(config.dependencies, function () {
          api.start()
        })
      })
    })
  }
})
;
define('main',['require','exports','module','./config','./smartserve'],function (require, exports, module) {/* globals requirejs */
/**
 * This is the main entry point of smartserve.js.
 * This file can only be required in during the build process
 * when config.js file is dynamically created in the build directory.
 *
 * It's a glue between the dynamic config and the smartserve lib.
 */
var config = require('./config')
var smartserve = require('./smartserve')
// more magic: pass in the requirejs
// which will be in scope in the built file
// so that we could configure it a bit more
smartserve(config, requirejs)

});

define('underscore@1.5.2/underscore',['require','exports','module'],function (require, exports, module) {//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the 
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from an array.
  // If **n** is not specified, returns a single random element from the array.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (arguments.length < 2 || guard) {
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = new Date();
      var later = function() {
        var last = (new Date()) - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

});

define('underscore@1.5.2', ['underscore@1.5.2/underscore'], function (main) { return main; });

define('@qubit---underscore@1.5.3/underscore',['require','exports','module','underscore'],function (require, exports, module) {module.exports = require("underscore");

});

define('@qubit---underscore@1.5.3', ['@qubit---underscore@1.5.3/underscore'], function (main) { return main; });

/*!
 * jQuery JavaScript Library v1.8.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Thu Sep 20 2012 21:13:05 GMT-0400 (Eastern Daylight Time)
 */
(function( window, undefined ) {
var
  // A central reference to the root jQuery(document)
  rootjQuery,

  // The deferred used on DOM ready
  readyList,

  // Use the correct document accordingly with window argument (sandbox)
  document = window.document,
  location = window.location,
  navigator = window.navigator,

  // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,

  // Map over the $ in case of overwrite
  _$ = window.$,

  // Save a reference to some core methods
  core_push = Array.prototype.push,
  core_slice = Array.prototype.slice,
  core_indexOf = Array.prototype.indexOf,
  core_toString = Object.prototype.toString,
  core_hasOwn = Object.prototype.hasOwnProperty,
  core_trim = String.prototype.trim,

  // Define a local copy of jQuery
  jQuery = function( selector, context ) {
    // The jQuery object is actually just the init constructor 'enhanced'
    return new jQuery.fn.init( selector, context, rootjQuery );
  },

  // Used for matching numbers
  core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

  // Used for detecting and trimming whitespace
  core_rnotwhite = /\S/,
  core_rspace = /\s+/,

  // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

  // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

  // Match a standalone tag
  rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

  // JSON RegExp
  rvalidchars = /^[\],:{}\s]*$/,
  rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
  rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
  rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

  // Matches dashed string for camelizing
  rmsPrefix = /^-ms-/,
  rdashAlpha = /-([\da-z])/gi,

  // Used by jQuery.camelCase as callback to replace()
  fcamelCase = function( all, letter ) {
    return ( letter + "" ).toUpperCase();
  },

  // The ready event handler and self cleanup method
  DOMContentLoaded = function() {
    if ( document.addEventListener ) {
      document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
      jQuery.ready();
    } else if ( document.readyState === "complete" ) {
      // we're here because readyState === "complete" in oldIE
      // which is good enough for us to call the dom ready!
      document.detachEvent( "onreadystatechange", DOMContentLoaded );
      jQuery.ready();
    }
  },

  // [[Class]] -> type pairs
  class2type = {};

jQuery.fn = jQuery.prototype = {
  constructor: jQuery,
  init: function( selector, context, rootjQuery ) {
    var match, elem, ret, doc;

    // Handle $(""), $(null), $(undefined), $(false)
    if ( !selector ) {
      return this;
    }

    // Handle $(DOMElement)
    if ( selector.nodeType ) {
      this.context = this[0] = selector;
      this.length = 1;
      return this;
    }

    // Handle HTML strings
    if ( typeof selector === "string" ) {
      if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [ null, selector, null ];

      } else {
        match = rquickExpr.exec( selector );
      }

      // Match html or make sure no context is specified for #id
      if ( match && (match[1] || !context) ) {

        // HANDLE: $(html) -> $(array)
        if ( match[1] ) {
          context = context instanceof jQuery ? context[0] : context;
          doc = ( context && context.nodeType ? context.ownerDocument || context : document );

          // scripts is true for back-compat
          selector = jQuery.parseHTML( match[1], doc, true );
          if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
            this.attr.call( selector, context, true );
          }

          return jQuery.merge( this, selector );

        // HANDLE: $(#id)
        } else {
          elem = document.getElementById( match[2] );

          // Check parentNode to catch when Blackberry 4.6 returns
          // nodes that are no longer in the document #6963
          if ( elem && elem.parentNode ) {
            // Handle the case where IE and Opera return items
            // by name instead of ID
            if ( elem.id !== match[2] ) {
              return rootjQuery.find( selector );
            }

            // Otherwise, we inject the element directly into the jQuery object
            this.length = 1;
            this[0] = elem;
          }

          this.context = document;
          this.selector = selector;
          return this;
        }

      // HANDLE: $(expr, $(...))
      } else if ( !context || context.jquery ) {
        return ( context || rootjQuery ).find( selector );

      // HANDLE: $(expr, context)
      // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor( context ).find( selector );
      }

    // HANDLE: $(function)
    // Shortcut for document ready
    } else if ( jQuery.isFunction( selector ) ) {
      return rootjQuery.ready( selector );
    }

    if ( selector.selector !== undefined ) {
      this.selector = selector.selector;
      this.context = selector.context;
    }

    return jQuery.makeArray( selector, this );
  },

  // Start with an empty selector
  selector: "",

  // The current version of jQuery being used
  jquery: "1.8.2",

  // The default length of a jQuery object is 0
  length: 0,

  // The number of elements contained in the matched element set
  size: function() {
    return this.length;
  },

  toArray: function() {
    return core_slice.call( this );
  },

  // Get the Nth element in the matched element set OR
  // Get the whole matched element set as a clean array
  get: function( num ) {
    return num == null ?

      // Return a 'clean' array
      this.toArray() :

      // Return just the object
      ( num < 0 ? this[ this.length + num ] : this[ num ] );
  },

  // Take an array of elements and push it onto the stack
  // (returning the new matched element set)
  pushStack: function( elems, name, selector ) {

    // Build a new jQuery matched element set
    var ret = jQuery.merge( this.constructor(), elems );

    // Add the old object onto the stack (as a reference)
    ret.prevObject = this;

    ret.context = this.context;

    if ( name === "find" ) {
      ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
    } else if ( name ) {
      ret.selector = this.selector + "." + name + "(" + selector + ")";
    }

    // Return the newly-formed element set
    return ret;
  },

  // Execute a callback for every element in the matched set.
  // (You can seed the arguments with an array of args, but this is
  // only used internally.)
  each: function( callback, args ) {
    return jQuery.each( this, callback, args );
  },

  ready: function( fn ) {
    // Add the callback
    jQuery.ready.promise().done( fn );

    return this;
  },

  eq: function( i ) {
    i = +i;
    return i === -1 ?
      this.slice( i ) :
      this.slice( i, i + 1 );
  },

  first: function() {
    return this.eq( 0 );
  },

  last: function() {
    return this.eq( -1 );
  },

  slice: function() {
    return this.pushStack( core_slice.apply( this, arguments ),
      "slice", core_slice.call(arguments).join(",") );
  },

  map: function( callback ) {
    return this.pushStack( jQuery.map(this, function( elem, i ) {
      return callback.call( elem, i, elem );
    }));
  },

  end: function() {
    return this.prevObject || this.constructor(null);
  },

  // For internal use only.
  // Behaves like an Array's method, not like a jQuery method.
  push: core_push,
  sort: [].sort,
  splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
  var options, name, src, copy, copyIsArray, clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // Handle a deep copy situation
  if ( typeof target === "boolean" ) {
    deep = target;
    target = arguments[1] || {};
    // skip the boolean and the target
    i = 2;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
    target = {};
  }

  // extend jQuery itself if only one argument is passed
  if ( length === i ) {
    target = this;
    --i;
  }

  for ( ; i < length; i++ ) {
    // Only deal with non-null/undefined values
    if ( (options = arguments[ i ]) != null ) {
      // Extend the base object
      for ( name in options ) {
        src = target[ name ];
        copy = options[ name ];

        // Prevent never-ending loop
        if ( target === copy ) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
          if ( copyIsArray ) {
            copyIsArray = false;
            clone = src && jQuery.isArray(src) ? src : [];

          } else {
            clone = src && jQuery.isPlainObject(src) ? src : {};
          }

          // Never move original objects, clone them
          target[ name ] = jQuery.extend( deep, clone, copy );

        // Don't bring in undefined values
        } else if ( copy !== undefined ) {
          target[ name ] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
};

jQuery.extend({
  noConflict: function( deep ) {
    if ( window.$ === jQuery ) {
      window.$ = _$;
    }

    if ( deep && window.jQuery === jQuery ) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  },

  // Is the DOM ready to be used? Set to true once it occurs.
  isReady: false,

  // A counter to track how many items to wait for before
  // the ready event fires. See #6781
  readyWait: 1,

  // Hold (or release) the ready event
  holdReady: function( hold ) {
    if ( hold ) {
      jQuery.readyWait++;
    } else {
      jQuery.ready( true );
    }
  },

  // Handle when the DOM is ready
  ready: function( wait ) {

    // Abort if there are pending holds or we're already ready
    if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
      return;
    }

    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
    if ( !document.body ) {
      return setTimeout( jQuery.ready, 1 );
    }

    // Remember that the DOM is ready
    jQuery.isReady = true;

    // If a normal DOM Ready event fired, decrement, and wait if need be
    if ( wait !== true && --jQuery.readyWait > 0 ) {
      return;
    }

    // If there are functions bound, to execute
    readyList.resolveWith( document, [ jQuery ] );

    // Trigger any bound ready events
    if ( jQuery.fn.trigger ) {
      jQuery( document ).trigger("ready").off("ready");
    }
  },

  // See test/unit/core.js for details concerning isFunction.
  // Since version 1.3, DOM methods and functions like alert
  // aren't supported. They return false on IE (#2968).
  isFunction: function( obj ) {
    return jQuery.type(obj) === "function";
  },

  isArray: Array.isArray || function( obj ) {
    return jQuery.type(obj) === "array";
  },

  isWindow: function( obj ) {
    return obj != null && obj == obj.window;
  },

  isNumeric: function( obj ) {
    return !isNaN( parseFloat(obj) ) && isFinite( obj );
  },

  type: function( obj ) {
    return obj == null ?
      String( obj ) :
      class2type[ core_toString.call(obj) ] || "object";
  },

  isPlainObject: function( obj ) {
    // Must be an Object.
    // Because of IE, we also have to check the presence of the constructor property.
    // Make sure that DOM nodes and window objects don't pass through, as well
    if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
      return false;
    }

    try {
      // Not own constructor property must be Object
      if ( obj.constructor &&
        !core_hasOwn.call(obj, "constructor") &&
        !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
        return false;
      }
    } catch ( e ) {
      // IE8,9 Will throw exceptions on certain host objects #9897
      return false;
    }

    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.

    var key;
    for ( key in obj ) {}

    return key === undefined || core_hasOwn.call( obj, key );
  },

  isEmptyObject: function( obj ) {
    var name;
    for ( name in obj ) {
      return false;
    }
    return true;
  },

  error: function( msg ) {
    throw new Error( msg );
  },

  // data: string of html
  // context (optional): If specified, the fragment will be created in this context, defaults to document
  // scripts (optional): If true, will include scripts passed in the html string
  parseHTML: function( data, context, scripts ) {
    var parsed;
    if ( !data || typeof data !== "string" ) {
      return null;
    }
    if ( typeof context === "boolean" ) {
      scripts = context;
      context = 0;
    }
    context = context || document;

    // Single tag
    if ( (parsed = rsingleTag.exec( data )) ) {
      return [ context.createElement( parsed[1] ) ];
    }

    parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
    return jQuery.merge( [],
      (parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
  },

  parseJSON: function( data ) {
    if ( !data || typeof data !== "string") {
      return null;
    }

    // Make sure leading/trailing whitespace is removed (IE can't handle it)
    data = jQuery.trim( data );

    // Attempt to parse using the native JSON parser first
    if ( window.JSON && window.JSON.parse ) {
      return window.JSON.parse( data );
    }

    // Make sure the incoming data is actual JSON
    // Logic borrowed from http://json.org/json2.js
    if ( rvalidchars.test( data.replace( rvalidescape, "@" )
      .replace( rvalidtokens, "]" )
      .replace( rvalidbraces, "")) ) {

      return ( new Function( "return " + data ) )();

    }
    jQuery.error( "Invalid JSON: " + data );
  },

  // Cross-browser xml parsing
  parseXML: function( data ) {
    var xml, tmp;
    if ( !data || typeof data !== "string" ) {
      return null;
    }
    try {
      if ( window.DOMParser ) { // Standard
        tmp = new DOMParser();
        xml = tmp.parseFromString( data , "text/xml" );
      } else { // IE
        xml = new ActiveXObject( "Microsoft.XMLDOM" );
        xml.async = "false";
        xml.loadXML( data );
      }
    } catch( e ) {
      xml = undefined;
    }
    if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
      jQuery.error( "Invalid XML: " + data );
    }
    return xml;
  },

  noop: function() {},

  // Evaluates a script in a global context
  // Workarounds based on findings by Jim Driscoll
  // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
  globalEval: function( data ) {
    if ( data && core_rnotwhite.test( data ) ) {
      // We use execScript on Internet Explorer
      // We use an anonymous function so that context is window
      // rather than jQuery in Firefox
      ( window.execScript || function( data ) {
        window[ "eval" ].call( window, data );
      } )( data );
    }
  },

  // Convert dashed to camelCase; used by the css and data modules
  // Microsoft forgot to hump their vendor prefix (#9572)
  camelCase: function( string ) {
    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  },

  nodeName: function( elem, name ) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  },

  // args is for internal usage only
  each: function( obj, callback, args ) {
    var name,
      i = 0,
      length = obj.length,
      isObj = length === undefined || jQuery.isFunction( obj );

    if ( args ) {
      if ( isObj ) {
        for ( name in obj ) {
          if ( callback.apply( obj[ name ], args ) === false ) {
            break;
          }
        }
      } else {
        for ( ; i < length; ) {
          if ( callback.apply( obj[ i++ ], args ) === false ) {
            break;
          }
        }
      }

    // A special, fast, case for the most common use of each
    } else {
      if ( isObj ) {
        for ( name in obj ) {
          if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
            break;
          }
        }
      } else {
        for ( ; i < length; ) {
          if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
            break;
          }
        }
      }
    }

    return obj;
  },

  // Use native String.trim function wherever possible
  trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
    function( text ) {
      return text == null ?
        "" :
        core_trim.call( text );
    } :

    // Otherwise use our own trimming functionality
    function( text ) {
      return text == null ?
        "" :
        ( text + "" ).replace( rtrim, "" );
    },

  // results is for internal usage only
  makeArray: function( arr, results ) {
    var type,
      ret = results || [];

    if ( arr != null ) {
      // The window, strings (and functions) also have 'length'
      // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
      type = jQuery.type( arr );

      if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
        core_push.call( ret, arr );
      } else {
        jQuery.merge( ret, arr );
      }
    }

    return ret;
  },

  inArray: function( elem, arr, i ) {
    var len;

    if ( arr ) {
      if ( core_indexOf ) {
        return core_indexOf.call( arr, elem, i );
      }

      len = arr.length;
      i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

      for ( ; i < len; i++ ) {
        // Skip accessing in sparse arrays
        if ( i in arr && arr[ i ] === elem ) {
          return i;
        }
      }
    }

    return -1;
  },

  merge: function( first, second ) {
    var l = second.length,
      i = first.length,
      j = 0;

    if ( typeof l === "number" ) {
      for ( ; j < l; j++ ) {
        first[ i++ ] = second[ j ];
      }

    } else {
      while ( second[j] !== undefined ) {
        first[ i++ ] = second[ j++ ];
      }
    }

    first.length = i;

    return first;
  },

  grep: function( elems, callback, inv ) {
    var retVal,
      ret = [],
      i = 0,
      length = elems.length;
    inv = !!inv;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( ; i < length; i++ ) {
      retVal = !!callback( elems[ i ], i );
      if ( inv !== retVal ) {
        ret.push( elems[ i ] );
      }
    }

    return ret;
  },

  // arg is for internal usage only
  map: function( elems, callback, arg ) {
    var value, key,
      ret = [],
      i = 0,
      length = elems.length,
      // jquery objects are treated as arrays
      isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

    // Go through the array, translating each of the items to their
    if ( isArray ) {
      for ( ; i < length; i++ ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret[ ret.length ] = value;
        }
      }

    // Go through every key on the object,
    } else {
      for ( key in elems ) {
        value = callback( elems[ key ], key, arg );

        if ( value != null ) {
          ret[ ret.length ] = value;
        }
      }
    }

    // Flatten any nested arrays
    return ret.concat.apply( [], ret );
  },

  // A global GUID counter for objects
  guid: 1,

  // Bind a function to a context, optionally partially applying any
  // arguments.
  proxy: function( fn, context ) {
    var tmp, args, proxy;

    if ( typeof context === "string" ) {
      tmp = fn[ context ];
      context = fn;
      fn = tmp;
    }

    // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.
    if ( !jQuery.isFunction( fn ) ) {
      return undefined;
    }

    // Simulated bind
    args = core_slice.call( arguments, 2 );
    proxy = function() {
      return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
    };

    // Set the guid of unique handler to the same of original handler, so it can be removed
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

    return proxy;
  },

  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
    var exec,
      bulk = key == null,
      i = 0,
      length = elems.length;

    // Sets many values
    if ( key && typeof key === "object" ) {
      for ( i in key ) {
        jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
      }
      chainable = 1;

    // Sets one value
    } else if ( value !== undefined ) {
      // Optionally, function values get executed if exec is true
      exec = pass === undefined && jQuery.isFunction( value );

      if ( bulk ) {
        // Bulk operations only iterate when executing function values
        if ( exec ) {
          exec = fn;
          fn = function( elem, key, value ) {
            return exec.call( jQuery( elem ), value );
          };

        // Otherwise they run against the entire set
        } else {
          fn.call( elems, value );
          fn = null;
        }
      }

      if ( fn ) {
        for (; i < length; i++ ) {
          fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
        }
      }

      chainable = 1;
    }

    return chainable ?
      elems :

      // Gets
      bulk ?
        fn.call( elems ) :
        length ? fn( elems[0], key ) : emptyGet;
  },

  now: function() {
    return ( new Date() ).getTime();
  }
});

jQuery.ready.promise = function( obj ) {
  if ( !readyList ) {

    readyList = jQuery.Deferred();

    // Catch cases where $(document).ready() is called after the browser event has already occurred.
    // we once tried to use readyState "interactive" here, but it caused issues like the one
    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
    if ( document.readyState === "complete" ) {
      // Handle it asynchronously to allow scripts the opportunity to delay ready
      setTimeout( jQuery.ready, 1 );

    // Standards-based browsers support DOMContentLoaded
    } else if ( document.addEventListener ) {
      // Use the handy event callback
      document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

      // A fallback to window.onload, that will always work
      window.addEventListener( "load", jQuery.ready, false );

    // If IE event model is used
    } else {
      // Ensure firing before onload, maybe late but safe also for iframes
      document.attachEvent( "onreadystatechange", DOMContentLoaded );

      // A fallback to window.onload, that will always work
      window.attachEvent( "onload", jQuery.ready );

      // If IE and not a frame
      // continually check to see if the document is ready
      var top = false;

      try {
        top = window.frameElement == null && document.documentElement;
      } catch(e) {}

      if ( top && top.doScroll ) {
        (function doScrollCheck() {
          if ( !jQuery.isReady ) {

            try {
              // Use the trick by Diego Perini
              // http://javascript.nwbox.com/IEContentLoaded/
              top.doScroll("left");
            } catch(e) {
              return setTimeout( doScrollCheck, 50 );
            }

            // and execute any waiting functions
            jQuery.ready();
          }
        })();
      }
    }
  }
  return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
  class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
  var object = optionsCache[ options ] = {};
  jQuery.each( options.split( core_rspace ), function( _, flag ) {
    object[ flag ] = true;
  });
  return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *      the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:     will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:     will keep track of previous values and will call any callback added
 *          after the list has been fired right away with the latest "memorized"
 *          values (like a Deferred)
 *
 *  unique:     will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:  interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

  // Convert options from String-formatted to Object-formatted if needed
  // (we check in cache first)
  options = typeof options === "string" ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );

  var // Last fire value (for non-forgettable lists)
    memory,
    // Flag to know if list was already fired
    fired,
    // Flag to know if list is currently firing
    firing,
    // First callback to fire (used internally by add and fireWith)
    firingStart,
    // End of the loop when firing
    firingLength,
    // Index of currently firing callback (modified by remove if needed)
    firingIndex,
    // Actual callback list
    list = [],
    // Stack of fire calls for repeatable lists
    stack = !options.once && [],
    // Fire callbacks
    fire = function( data ) {
      memory = options.memory && data;
      fired = true;
      firingIndex = firingStart || 0;
      firingStart = 0;
      firingLength = list.length;
      firing = true;
      for ( ; list && firingIndex < firingLength; firingIndex++ ) {
        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
          memory = false; // To prevent further calls using add
          break;
        }
      }
      firing = false;
      if ( list ) {
        if ( stack ) {
          if ( stack.length ) {
            fire( stack.shift() );
          }
        } else if ( memory ) {
          list = [];
        } else {
          self.disable();
        }
      }
    },
    // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function() {
        if ( list ) {
          // First, we save the current length
          var start = list.length;
          (function add( args ) {
            jQuery.each( args, function( _, arg ) {
              var type = jQuery.type( arg );
              if ( type === "function" && ( !options.unique || !self.has( arg ) ) ) {
                list.push( arg );
              } else if ( arg && arg.length && type !== "string" ) {
                // Inspect recursively
                add( arg );
              }
            });
          })( arguments );
          // Do we need to add the callbacks to the
          // current firing batch?
          if ( firing ) {
            firingLength = list.length;
          // With memory, if we're not firing then
          // we should call right away
          } else if ( memory ) {
            firingStart = start;
            fire( memory );
          }
        }
        return this;
      },
      // Remove a callback from the list
      remove: function() {
        if ( list ) {
          jQuery.each( arguments, function( _, arg ) {
            var index;
            while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
              list.splice( index, 1 );
              // Handle firing indexes
              if ( firing ) {
                if ( index <= firingLength ) {
                  firingLength--;
                }
                if ( index <= firingIndex ) {
                  firingIndex--;
                }
              }
            }
          });
        }
        return this;
      },
      // Control if a given callback is in the list
      has: function( fn ) {
        return jQuery.inArray( fn, list ) > -1;
      },
      // Remove all callbacks from the list
      empty: function() {
        list = [];
        return this;
      },
      // Have the list do nothing anymore
      disable: function() {
        list = stack = memory = undefined;
        return this;
      },
      // Is it disabled?
      disabled: function() {
        return !list;
      },
      // Lock the list in its current state
      lock: function() {
        stack = undefined;
        if ( !memory ) {
          self.disable();
        }
        return this;
      },
      // Is it locked?
      locked: function() {
        return !stack;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function( context, args ) {
        args = args || [];
        args = [ context, args.slice ? args.slice() : args ];
        if ( list && ( !fired || stack ) ) {
          if ( firing ) {
            stack.push( args );
          } else {
            fire( args );
          }
        }
        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function() {
        self.fireWith( this, arguments );
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function() {
        return !!fired;
      }
    };

  return self;
};
jQuery.extend({

  Deferred: function( func ) {
    var tuples = [
        // action, add listener, listener list, final state
        [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
        [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
        [ "notify", "progress", jQuery.Callbacks("memory") ]
      ],
      state = "pending",
      promise = {
        state: function() {
          return state;
        },
        always: function() {
          deferred.done( arguments ).fail( arguments );
          return this;
        },
        then: function( /* fnDone, fnFail, fnProgress */ ) {
          var fns = arguments;
          return jQuery.Deferred(function( newDefer ) {
            jQuery.each( tuples, function( i, tuple ) {
              var action = tuple[ 0 ],
                fn = fns[ i ];
              // deferred[ done | fail | progress ] for forwarding actions to newDefer
              deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
                function() {
                  var returned = fn.apply( this, arguments );
                  if ( returned && jQuery.isFunction( returned.promise ) ) {
                    returned.promise()
                      .done( newDefer.resolve )
                      .fail( newDefer.reject )
                      .progress( newDefer.notify );
                  } else {
                    newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
                  }
                } :
                newDefer[ action ]
              );
            });
            fns = null;
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function( obj ) {
          return obj != null ? jQuery.extend( obj, promise ) : promise;
        }
      },
      deferred = {};

    // Keep pipe for back-compat
    promise.pipe = promise.then;

    // Add list-specific methods
    jQuery.each( tuples, function( i, tuple ) {
      var list = tuple[ 2 ],
        stateString = tuple[ 3 ];

      // promise[ done | fail | progress ] = list.add
      promise[ tuple[1] ] = list.add;

      // Handle state
      if ( stateString ) {
        list.add(function() {
          // state = [ resolved | rejected ]
          state = stateString;

        // [ reject_list | resolve_list ].disable; progress_list.lock
        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
      }

      // deferred[ resolve | reject | notify ] = list.fire
      deferred[ tuple[0] ] = list.fire;
      deferred[ tuple[0] + "With" ] = list.fireWith;
    });

    // Make the deferred a promise
    promise.promise( deferred );

    // Call given func if any
    if ( func ) {
      func.call( deferred, deferred );
    }

    // All done!
    return deferred;
  },

  // Deferred helper
  when: function( subordinate /* , ..., subordinateN */ ) {
    var i = 0,
      resolveValues = core_slice.call( arguments ),
      length = resolveValues.length,

      // the count of uncompleted subordinates
      remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

      // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

      // Update function for both resolve and progress values
      updateFunc = function( i, contexts, values ) {
        return function( value ) {
          contexts[ i ] = this;
          values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
          if( values === progressValues ) {
            deferred.notifyWith( contexts, values );
          } else if ( !( --remaining ) ) {
            deferred.resolveWith( contexts, values );
          }
        };
      },

      progressValues, progressContexts, resolveContexts;

    // add listeners to Deferred subordinates; treat others as resolved
    if ( length > 1 ) {
      progressValues = new Array( length );
      progressContexts = new Array( length );
      resolveContexts = new Array( length );
      for ( ; i < length; i++ ) {
        if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
          resolveValues[ i ].promise()
            .done( updateFunc( i, resolveContexts, resolveValues ) )
            .fail( deferred.reject )
            .progress( updateFunc( i, progressContexts, progressValues ) );
        } else {
          --remaining;
        }
      }
    }

    // if we're not waiting on anything, resolve the master
    if ( !remaining ) {
      deferred.resolveWith( resolveContexts, resolveValues );
    }

    return deferred.promise();
  }
});
jQuery.support = (function() {

  var support,
    all,
    a,
    select,
    opt,
    input,
    fragment,
    eventName,
    i,
    isSupported,
    clickFn,
    div = document.createElement("div");

  // Preliminary tests
  div.setAttribute( "className", "t" );
  div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

  all = div.getElementsByTagName("*");
  a = div.getElementsByTagName("a")[ 0 ];
  a.style.cssText = "top:1px;float:left;opacity:.5";

  // Can't get basic test support
  if ( !all || !all.length ) {
    return {};
  }

  // First batch of supports tests
  select = document.createElement("select");
  opt = select.appendChild( document.createElement("option") );
  input = div.getElementsByTagName("input")[ 0 ];

  support = {
    // IE strips leading whitespace when .innerHTML is used
    leadingWhitespace: ( div.firstChild.nodeType === 3 ),

    // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables
    tbody: !div.getElementsByTagName("tbody").length,

    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    htmlSerialize: !!div.getElementsByTagName("link").length,

    // Get the style information from getAttribute
    // (IE uses .cssText instead)
    style: /top/.test( a.getAttribute("style") ),

    // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)
    hrefNormalized: ( a.getAttribute("href") === "/a" ),

    // Make sure that element opacity exists
    // (IE uses filter instead)
    // Use a regex to work around a WebKit issue. See #5145
    opacity: /^0.5/.test( a.style.opacity ),

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    cssFloat: !!a.style.cssFloat,

    // Make sure that if no value is specified for a checkbox
    // that it defaults to "on".
    // (WebKit defaults to "" instead)
    checkOn: ( input.value === "on" ),

    // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    optSelected: opt.selected,

    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    getSetAttribute: div.className !== "t",

    // Tests for enctype support on a form(#6743)
    enctype: !!document.createElement("form").enctype,

    // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works
    html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

    // jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
    boxModel: ( document.compatMode === "CSS1Compat" ),

    // Will be defined later
    submitBubbles: true,
    changeBubbles: true,
    focusinBubbles: false,
    deleteExpando: true,
    noCloneEvent: true,
    inlineBlockNeedsLayout: false,
    shrinkWrapBlocks: false,
    reliableMarginRight: true,
    boxSizingReliable: true,
    pixelPosition: false
  };

  // Make sure checked status is properly cloned
  input.checked = true;
  support.noCloneChecked = input.cloneNode( true ).checked;

  // Make sure that the options inside disabled selects aren't marked as disabled
  // (WebKit marks them as disabled)
  select.disabled = true;
  support.optDisabled = !opt.disabled;

  // Test to see if it's possible to delete an expando from an element
  // Fails in Internet Explorer
  try {
    delete div.test;
  } catch( e ) {
    support.deleteExpando = false;
  }

  if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
    div.attachEvent( "onclick", clickFn = function() {
      // Cloning a node shouldn't copy over any
      // bound event handlers (IE does this)
      support.noCloneEvent = false;
    });
    div.cloneNode( true ).fireEvent("onclick");
    div.detachEvent( "onclick", clickFn );
  }

  // Check if a radio maintains its value
  // after being appended to the DOM
  input = document.createElement("input");
  input.value = "t";
  input.setAttribute( "type", "radio" );
  support.radioValue = input.value === "t";

  input.setAttribute( "checked", "checked" );

  // #11217 - WebKit loses check when the name is after the checked attribute
  input.setAttribute( "name", "t" );

  div.appendChild( input );
  fragment = document.createDocumentFragment();
  fragment.appendChild( div.lastChild );

  // WebKit doesn't clone checked state correctly in fragments
  support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

  // Check if a disconnected checkbox will retain its checked
  // value of true after appended to the DOM (IE6/7)
  support.appendChecked = input.checked;

  fragment.removeChild( input );
  fragment.appendChild( div );

  // Technique from Juriy Zaytsev
  // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
  // We only care about the case where non-standard event systems
  // are used, namely in IE. Short-circuiting here helps us to
  // avoid an eval call (in setAttribute) which can cause CSP
  // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
  if ( div.attachEvent ) {
    for ( i in {
      submit: true,
      change: true,
      focusin: true
    }) {
      eventName = "on" + i;
      isSupported = ( eventName in div );
      if ( !isSupported ) {
        div.setAttribute( eventName, "return;" );
        isSupported = ( typeof div[ eventName ] === "function" );
      }
      support[ i + "Bubbles" ] = isSupported;
    }
  }

  // Run tests that need a body at doc ready
  jQuery(function() {
    var container, div, tds, marginDiv,
      divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
      body = document.getElementsByTagName("body")[0];

    if ( !body ) {
      // Return for frameset docs that don't have a body
      return;
    }

    container = document.createElement("div");
    container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
    body.insertBefore( container, body.firstChild );

    // Construct the test element
    div = document.createElement("div");
    container.appendChild( div );

    // Check if table cells still have offsetWidth/Height when they are set
    // to display:none and there are still other visible table cells in a
    // table row; if so, offsetWidth/Height are not reliable for use when
    // determining if an element has been hidden directly using
    // display:none (it is still safe to use offsets if a parent element is
    // hidden; don safety goggles and see bug #4512 for more information).
    // (only IE 8 fails this test)
    div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
    tds = div.getElementsByTagName("td");
    tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
    isSupported = ( tds[ 0 ].offsetHeight === 0 );

    tds[ 0 ].style.display = "";
    tds[ 1 ].style.display = "none";

    // Check if empty table cells still have offsetWidth/Height
    // (IE <= 8 fail this test)
    support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

    // Check box-sizing and margin behavior
    div.innerHTML = "";
    div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
    support.boxSizing = ( div.offsetWidth === 4 );
    support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

    // NOTE: To any future maintainer, we've window.getComputedStyle
    // because jsdom on node.js will break without it.
    if ( window.getComputedStyle ) {
      support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
      support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

      // Check if div with explicit width and no margin-right incorrectly
      // gets computed margin-right based on width of container. For more
      // info see bug #3333
      // Fails in WebKit before Feb 2011 nightlies
      // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
      marginDiv = document.createElement("div");
      marginDiv.style.cssText = div.style.cssText = divReset;
      marginDiv.style.marginRight = marginDiv.style.width = "0";
      div.style.width = "1px";
      div.appendChild( marginDiv );
      support.reliableMarginRight =
        !parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
    }

    if ( typeof div.style.zoom !== "undefined" ) {
      // Check if natively block-level elements act like inline-block
      // elements when setting their display to 'inline' and giving
      // them layout
      // (IE < 8 does this)
      div.innerHTML = "";
      div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
      support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

      // Check if elements with layout shrink-wrap their children
      // (IE 6 does this)
      div.style.display = "block";
      div.style.overflow = "visible";
      div.innerHTML = "<div></div>";
      div.firstChild.style.width = "5px";
      support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

      container.style.zoom = 1;
    }

    // Null elements to avoid leaks in IE
    body.removeChild( container );
    container = div = tds = marginDiv = null;
  });

  // Null elements to avoid leaks in IE
  fragment.removeChild( div );
  all = a = select = opt = input = fragment = div = null;

  return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
  rmultiDash = /([A-Z])/g;

jQuery.extend({
  cache: {},

  deletedIds: [],

  // Remove at next major release (1.9/2.0)
  uuid: 0,

  // Unique for each copy of jQuery on the page
  // Non-digits removed to match rinlinejQuery
  expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

  // The following elements throw uncatchable exceptions if you
  // attempt to add expando properties to them.
  noData: {
    "embed": true,
    // Ban all objects except for Flash (which handle expandos)
    "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
    "applet": true
  },

  hasData: function( elem ) {
    elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
    return !!elem && !isEmptyDataObject( elem );
  },

  data: function( elem, name, data, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
      return;
    }

    var thisCache, ret,
      internalKey = jQuery.expando,
      getByName = typeof name === "string",

      // We have to handle DOM nodes and JS objects differently because IE6-7
      // can't GC object references properly across the DOM-JS boundary
      isNode = elem.nodeType,

      // Only DOM nodes need the global jQuery cache; JS object data is
      // attached directly to the object so GC can occur automatically
      cache = isNode ? jQuery.cache : elem,

      // Only defining an ID for JS objects if its cache already exists allows
      // the code to shortcut on the same path as a DOM node with no cache
      id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

    // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all
    if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
      return;
    }

    if ( !id ) {
      // Only DOM nodes need a new unique ID for each element since their data
      // ends up in the global cache
      if ( isNode ) {
        elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
      } else {
        id = internalKey;
      }
    }

    if ( !cache[ id ] ) {
      cache[ id ] = {};

      // Avoids exposing jQuery metadata on plain JS objects when the object
      // is serialized using JSON.stringify
      if ( !isNode ) {
        cache[ id ].toJSON = jQuery.noop;
      }
    }

    // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache
    if ( typeof name === "object" || typeof name === "function" ) {
      if ( pvt ) {
        cache[ id ] = jQuery.extend( cache[ id ], name );
      } else {
        cache[ id ].data = jQuery.extend( cache[ id ].data, name );
      }
    }

    thisCache = cache[ id ];

    // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.
    if ( !pvt ) {
      if ( !thisCache.data ) {
        thisCache.data = {};
      }

      thisCache = thisCache.data;
    }

    if ( data !== undefined ) {
      thisCache[ jQuery.camelCase( name ) ] = data;
    }

    // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified
    if ( getByName ) {

      // First Try to find as-is property data
      ret = thisCache[ name ];

      // Test for null|undefined property data
      if ( ret == null ) {

        // Try to find the camelCased property
        ret = thisCache[ jQuery.camelCase( name ) ];
      }
    } else {
      ret = thisCache;
    }

    return ret;
  },

  removeData: function( elem, name, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
      return;
    }

    var thisCache, i, l,

      isNode = elem.nodeType,

      // See jQuery.data for more information
      cache = isNode ? jQuery.cache : elem,
      id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

    // If there is already no cache entry for this object, there is no
    // purpose in continuing
    if ( !cache[ id ] ) {
      return;
    }

    if ( name ) {

      thisCache = pvt ? cache[ id ] : cache[ id ].data;

      if ( thisCache ) {

        // Support array or space separated string names for data keys
        if ( !jQuery.isArray( name ) ) {

          // try the string as a key before any manipulation
          if ( name in thisCache ) {
            name = [ name ];
          } else {

            // split the camel cased version by spaces unless a key with the spaces exists
            name = jQuery.camelCase( name );
            if ( name in thisCache ) {
              name = [ name ];
            } else {
              name = name.split(" ");
            }
          }
        }

        for ( i = 0, l = name.length; i < l; i++ ) {
          delete thisCache[ name[i] ];
        }

        // If there is no data left in the cache, we want to continue
        // and let the cache object itself get destroyed
        if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
          return;
        }
      }
    }

    // See jQuery.data for more information
    if ( !pvt ) {
      delete cache[ id ].data;

      // Don't destroy the parent cache unless the internal data object
      // had been the only thing left in it
      if ( !isEmptyDataObject( cache[ id ] ) ) {
        return;
      }
    }

    // Destroy the cache
    if ( isNode ) {
      jQuery.cleanData( [ elem ], true );

    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
    } else if ( jQuery.support.deleteExpando || cache != cache.window ) {
      delete cache[ id ];

    // When all else fails, null
    } else {
      cache[ id ] = null;
    }
  },

  // For internal use only.
  _data: function( elem, name, data ) {
    return jQuery.data( elem, name, data, true );
  },

  // A method for determining if a DOM node can handle the data expando
  acceptData: function( elem ) {
    var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

    // nodes accept data unless otherwise specified; rejection can be conditional
    return !noData || noData !== true && elem.getAttribute("classid") === noData;
  }
});

jQuery.fn.extend({
  data: function( key, value ) {
    var parts, part, attr, name, l,
      elem = this[0],
      i = 0,
      data = null;

    // Gets all values
    if ( key === undefined ) {
      if ( this.length ) {
        data = jQuery.data( elem );

        if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
          attr = elem.attributes;
          for ( l = attr.length; i < l; i++ ) {
            name = attr[i].name;

            if ( !name.indexOf( "data-" ) ) {
              name = jQuery.camelCase( name.substring(5) );

              dataAttr( elem, name, data[ name ] );
            }
          }
          jQuery._data( elem, "parsedAttrs", true );
        }
      }

      return data;
    }

    // Sets multiple values
    if ( typeof key === "object" ) {
      return this.each(function() {
        jQuery.data( this, key );
      });
    }

    parts = key.split( ".", 2 );
    parts[1] = parts[1] ? "." + parts[1] : "";
    part = parts[1] + "!";

    return jQuery.access( this, function( value ) {

      if ( value === undefined ) {
        data = this.triggerHandler( "getData" + part, [ parts[0] ] );

        // Try to fetch any internally stored data first
        if ( data === undefined && elem ) {
          data = jQuery.data( elem, key );
          data = dataAttr( elem, key, data );
        }

        return data === undefined && parts[1] ?
          this.data( parts[0] ) :
          data;
      }

      parts[1] = value;
      this.each(function() {
        var self = jQuery( this );

        self.triggerHandler( "setData" + part, parts );
        jQuery.data( this, key, value );
        self.triggerHandler( "changeData" + part, parts );
      });
    }, null, value, arguments.length > 1, null, false );
  },

  removeData: function( key ) {
    return this.each(function() {
      jQuery.removeData( this, key );
    });
  }
});

function dataAttr( elem, key, data ) {
  // If nothing was found internally, try to fetch any
  // data from the HTML5 data-* attribute
  if ( data === undefined && elem.nodeType === 1 ) {

    var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

    data = elem.getAttribute( name );

    if ( typeof data === "string" ) {
      try {
        data = data === "true" ? true :
        data === "false" ? false :
        data === "null" ? null :
        // Only convert to a number if it doesn't change the string
        +data + "" === data ? +data :
        rbrace.test( data ) ? jQuery.parseJSON( data ) :
          data;
      } catch( e ) {}

      // Make sure we set the data so it isn't changed later
      jQuery.data( elem, key, data );

    } else {
      data = undefined;
    }
  }

  return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
  var name;
  for ( name in obj ) {

    // if the public data object is empty, the private is still empty
    if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
      continue;
    }
    if ( name !== "toJSON" ) {
      return false;
    }
  }

  return true;
}
jQuery.extend({
  queue: function( elem, type, data ) {
    var queue;

    if ( elem ) {
      type = ( type || "fx" ) + "queue";
      queue = jQuery._data( elem, type );

      // Speed up dequeue by getting out quickly if this is just a lookup
      if ( data ) {
        if ( !queue || jQuery.isArray(data) ) {
          queue = jQuery._data( elem, type, jQuery.makeArray(data) );
        } else {
          queue.push( data );
        }
      }
      return queue || [];
    }
  },

  dequeue: function( elem, type ) {
    type = type || "fx";

    var queue = jQuery.queue( elem, type ),
      startLength = queue.length,
      fn = queue.shift(),
      hooks = jQuery._queueHooks( elem, type ),
      next = function() {
        jQuery.dequeue( elem, type );
      };

    // If the fx queue is dequeued, always remove the progress sentinel
    if ( fn === "inprogress" ) {
      fn = queue.shift();
      startLength--;
    }

    if ( fn ) {

      // Add a progress sentinel to prevent the fx queue from being
      // automatically dequeued
      if ( type === "fx" ) {
        queue.unshift( "inprogress" );
      }

      // clear up the last queue stop function
      delete hooks.stop;
      fn.call( elem, next, hooks );
    }

    if ( !startLength && hooks ) {
      hooks.empty.fire();
    }
  },

  // not intended for public consumption - generates a queueHooks object, or returns the current one
  _queueHooks: function( elem, type ) {
    var key = type + "queueHooks";
    return jQuery._data( elem, key ) || jQuery._data( elem, key, {
      empty: jQuery.Callbacks("once memory").add(function() {
        jQuery.removeData( elem, type + "queue", true );
        jQuery.removeData( elem, key, true );
      })
    });
  }
});

jQuery.fn.extend({
  queue: function( type, data ) {
    var setter = 2;

    if ( typeof type !== "string" ) {
      data = type;
      type = "fx";
      setter--;
    }

    if ( arguments.length < setter ) {
      return jQuery.queue( this[0], type );
    }

    return data === undefined ?
      this :
      this.each(function() {
        var queue = jQuery.queue( this, type, data );

        // ensure a hooks for this queue
        jQuery._queueHooks( this, type );

        if ( type === "fx" && queue[0] !== "inprogress" ) {
          jQuery.dequeue( this, type );
        }
      });
  },
  dequeue: function( type ) {
    return this.each(function() {
      jQuery.dequeue( this, type );
    });
  },
  // Based off of the plugin by Clint Helfers, with permission.
  // http://blindsignals.com/index.php/2009/07/jquery-delay/
  delay: function( time, type ) {
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    type = type || "fx";

    return this.queue( type, function( next, hooks ) {
      var timeout = setTimeout( next, time );
      hooks.stop = function() {
        clearTimeout( timeout );
      };
    });
  },
  clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
  },
  // Get a promise resolved when queues of a certain type
  // are emptied (fx is the type by default)
  promise: function( type, obj ) {
    var tmp,
      count = 1,
      defer = jQuery.Deferred(),
      elements = this,
      i = this.length,
      resolve = function() {
        if ( !( --count ) ) {
          defer.resolveWith( elements, [ elements ] );
        }
      };

    if ( typeof type !== "string" ) {
      obj = type;
      type = undefined;
    }
    type = type || "fx";

    while( i-- ) {
      tmp = jQuery._data( elements[ i ], type + "queueHooks" );
      if ( tmp && tmp.empty ) {
        count++;
        tmp.empty.add( resolve );
      }
    }
    resolve();
    return defer.promise( obj );
  }
});
var nodeHook, boolHook, fixSpecified,
  rclass = /[\t\r\n]/g,
  rreturn = /\r/g,
  rtype = /^(?:button|input)$/i,
  rfocusable = /^(?:button|input|object|select|textarea)$/i,
  rclickable = /^a(?:rea|)$/i,
  rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
  getSetAttribute = jQuery.support.getSetAttribute;

jQuery.fn.extend({
  attr: function( name, value ) {
    return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
  },

  removeAttr: function( name ) {
    return this.each(function() {
      jQuery.removeAttr( this, name );
    });
  },

  prop: function( name, value ) {
    return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
  },

  removeProp: function( name ) {
    name = jQuery.propFix[ name ] || name;
    return this.each(function() {
      // try/catch handles cases where IE balks (such as removing a property on window)
      try {
        this[ name ] = undefined;
        delete this[ name ];
      } catch( e ) {}
    });
  },

  addClass: function( value ) {
    var classNames, i, l, elem,
      setClass, c, cl;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).addClass( value.call(this, j, this.className) );
      });
    }

    if ( value && typeof value === "string" ) {
      classNames = value.split( core_rspace );

      for ( i = 0, l = this.length; i < l; i++ ) {
        elem = this[ i ];

        if ( elem.nodeType === 1 ) {
          if ( !elem.className && classNames.length === 1 ) {
            elem.className = value;

          } else {
            setClass = " " + elem.className + " ";

            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
              if ( setClass.indexOf( " " + classNames[ c ] + " " ) < 0 ) {
                setClass += classNames[ c ] + " ";
              }
            }
            elem.className = jQuery.trim( setClass );
          }
        }
      }
    }

    return this;
  },

  removeClass: function( value ) {
    var removes, className, elem, c, cl, i, l;

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( j ) {
        jQuery( this ).removeClass( value.call(this, j, this.className) );
      });
    }
    if ( (value && typeof value === "string") || value === undefined ) {
      removes = ( value || "" ).split( core_rspace );

      for ( i = 0, l = this.length; i < l; i++ ) {
        elem = this[ i ];
        if ( elem.nodeType === 1 && elem.className ) {

          className = (" " + elem.className + " ").replace( rclass, " " );

          // loop over each item in the removal list
          for ( c = 0, cl = removes.length; c < cl; c++ ) {
            // Remove until there is nothing to remove,
            while ( className.indexOf(" " + removes[ c ] + " ") >= 0 ) {
              className = className.replace( " " + removes[ c ] + " " , " " );
            }
          }
          elem.className = value ? jQuery.trim( className ) : "";
        }
      }
    }

    return this;
  },

  toggleClass: function( value, stateVal ) {
    var type = typeof value,
      isBool = typeof stateVal === "boolean";

    if ( jQuery.isFunction( value ) ) {
      return this.each(function( i ) {
        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
      });
    }

    return this.each(function() {
      if ( type === "string" ) {
        // toggle individual class names
        var className,
          i = 0,
          self = jQuery( this ),
          state = stateVal,
          classNames = value.split( core_rspace );

        while ( (className = classNames[ i++ ]) ) {
          // check each className given, space separated list
          state = isBool ? state : !self.hasClass( className );
          self[ state ? "addClass" : "removeClass" ]( className );
        }

      } else if ( type === "undefined" || type === "boolean" ) {
        if ( this.className ) {
          // store className if set
          jQuery._data( this, "__className__", this.className );
        }

        // toggle whole className
        this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
      }
    });
  },

  hasClass: function( selector ) {
    var className = " " + selector + " ",
      i = 0,
      l = this.length;
    for ( ; i < l; i++ ) {
      if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
        return true;
      }
    }

    return false;
  },

  val: function( value ) {
    var hooks, ret, isFunction,
      elem = this[0];

    if ( !arguments.length ) {
      if ( elem ) {
        hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

        if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
          return ret;
        }

        ret = elem.value;

        return typeof ret === "string" ?
          // handle most common string cases
          ret.replace(rreturn, "") :
          // handle cases where value is null/undef or number
          ret == null ? "" : ret;
      }

      return;
    }

    isFunction = jQuery.isFunction( value );

    return this.each(function( i ) {
      var val,
        self = jQuery(this);

      if ( this.nodeType !== 1 ) {
        return;
      }

      if ( isFunction ) {
        val = value.call( this, i, self.val() );
      } else {
        val = value;
      }

      // Treat null/undefined as ""; convert numbers to string
      if ( val == null ) {
        val = "";
      } else if ( typeof val === "number" ) {
        val += "";
      } else if ( jQuery.isArray( val ) ) {
        val = jQuery.map(val, function ( value ) {
          return value == null ? "" : value + "";
        });
      }

      hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

      // If set returns undefined, fall back to normal setting
      if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
        this.value = val;
      }
    });
  }
});

jQuery.extend({
  valHooks: {
    option: {
      get: function( elem ) {
        // attributes.value is undefined in Blackberry 4.7 but
        // uses .value. See #6932
        var val = elem.attributes.value;
        return !val || val.specified ? elem.value : elem.text;
      }
    },
    select: {
      get: function( elem ) {
        var value, i, max, option,
          index = elem.selectedIndex,
          values = [],
          options = elem.options,
          one = elem.type === "select-one";

        // Nothing was selected
        if ( index < 0 ) {
          return null;
        }

        // Loop through all the selected options
        i = one ? index : 0;
        max = one ? index + 1 : options.length;
        for ( ; i < max; i++ ) {
          option = options[ i ];

          // Don't return options that are disabled or in a disabled optgroup
          if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
              (!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

            // Get the specific value for the option
            value = jQuery( option ).val();

            // We don't need an array for one selects
            if ( one ) {
              return value;
            }

            // Multi-Selects return an array
            values.push( value );
          }
        }

        // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
        if ( one && !values.length && options.length ) {
          return jQuery( options[ index ] ).val();
        }

        return values;
      },

      set: function( elem, value ) {
        var values = jQuery.makeArray( value );

        jQuery(elem).find("option").each(function() {
          this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
        });

        if ( !values.length ) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  },

  // Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
  attrFn: {},

  attr: function( elem, name, value, pass ) {
    var ret, hooks, notxml,
      nType = elem.nodeType;

    // don't get/set attributes on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    if ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {
      return jQuery( elem )[ name ]( value );
    }

    // Fallback to prop when attributes are not supported
    if ( typeof elem.getAttribute === "undefined" ) {
      return jQuery.prop( elem, name, value );
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    // All attributes are lowercase
    // Grab necessary hook if one is defined
    if ( notxml ) {
      name = name.toLowerCase();
      hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
    }

    if ( value !== undefined ) {

      if ( value === null ) {
        jQuery.removeAttr( elem, name );
        return;

      } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
        return ret;

      } else {
        elem.setAttribute( name, value + "" );
        return value;
      }

    } else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
      return ret;

    } else {

      ret = elem.getAttribute( name );

      // Non-existent attributes return null, we normalize to undefined
      return ret === null ?
        undefined :
        ret;
    }
  },

  removeAttr: function( elem, value ) {
    var propName, attrNames, name, isBool,
      i = 0;

    if ( value && elem.nodeType === 1 ) {

      attrNames = value.split( core_rspace );

      for ( ; i < attrNames.length; i++ ) {
        name = attrNames[ i ];

        if ( name ) {
          propName = jQuery.propFix[ name ] || name;
          isBool = rboolean.test( name );

          // See #9699 for explanation of this approach (setting first, then removal)
          // Do not do this for boolean attributes (see #10870)
          if ( !isBool ) {
            jQuery.attr( elem, name, "" );
          }
          elem.removeAttribute( getSetAttribute ? name : propName );

          // Set corresponding property to false for boolean attributes
          if ( isBool && propName in elem ) {
            elem[ propName ] = false;
          }
        }
      }
    }
  },

  attrHooks: {
    type: {
      set: function( elem, value ) {
        // We can't allow the type property to be changed (since it causes problems in IE)
        if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
          jQuery.error( "type property can't be changed" );
        } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
          // Setting the type on a radio button after the value resets the value in IE6-9
          // Reset value to it's default in case type is set after value
          // This is for element creation
          var val = elem.value;
          elem.setAttribute( "type", value );
          if ( val ) {
            elem.value = val;
          }
          return value;
        }
      }
    },
    // Use the value property for back compat
    // Use the nodeHook for button elements in IE6/7 (#1954)
    value: {
      get: function( elem, name ) {
        if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
          return nodeHook.get( elem, name );
        }
        return name in elem ?
          elem.value :
          null;
      },
      set: function( elem, value, name ) {
        if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
          return nodeHook.set( elem, value, name );
        }
        // Does not return so that setAttribute is also used
        elem.value = value;
      }
    }
  },

  propFix: {
    tabindex: "tabIndex",
    readonly: "readOnly",
    "for": "htmlFor",
    "class": "className",
    maxlength: "maxLength",
    cellspacing: "cellSpacing",
    cellpadding: "cellPadding",
    rowspan: "rowSpan",
    colspan: "colSpan",
    usemap: "useMap",
    frameborder: "frameBorder",
    contenteditable: "contentEditable"
  },

  prop: function( elem, name, value ) {
    var ret, hooks, notxml,
      nType = elem.nodeType;

    // don't get/set properties on text, comment and attribute nodes
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    if ( notxml ) {
      // Fix name and attach hooks
      name = jQuery.propFix[ name ] || name;
      hooks = jQuery.propHooks[ name ];
    }

    if ( value !== undefined ) {
      if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
        return ret;

      } else {
        return ( elem[ name ] = value );
      }

    } else {
      if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
        return ret;

      } else {
        return elem[ name ];
      }
    }
  },

  propHooks: {
    tabIndex: {
      get: function( elem ) {
        // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
        // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
        var attributeNode = elem.getAttributeNode("tabindex");

        return attributeNode && attributeNode.specified ?
          parseInt( attributeNode.value, 10 ) :
          rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
            0 :
            undefined;
      }
    }
  }
});

// Hook for boolean attributes
boolHook = {
  get: function( elem, name ) {
    // Align boolean attributes with corresponding properties
    // Fall back to attribute presence where some booleans are not supported
    var attrNode,
      property = jQuery.prop( elem, name );
    return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
      name.toLowerCase() :
      undefined;
  },
  set: function( elem, value, name ) {
    var propName;
    if ( value === false ) {
      // Remove boolean attributes when set to false
      jQuery.removeAttr( elem, name );
    } else {
      // value is true since we know at this point it's type boolean and not false
      // Set boolean attributes to the same name and set the DOM property
      propName = jQuery.propFix[ name ] || name;
      if ( propName in elem ) {
        // Only set the IDL specifically if it already exists on the element
        elem[ propName ] = true;
      }

      elem.setAttribute( name, name.toLowerCase() );
    }
    return name;
  }
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

  fixSpecified = {
    name: true,
    id: true,
    coords: true
  };

  // Use this for any attribute in IE6/7
  // This fixes almost every IE6/7 issue
  nodeHook = jQuery.valHooks.button = {
    get: function( elem, name ) {
      var ret;
      ret = elem.getAttributeNode( name );
      return ret && ( fixSpecified[ name ] ? ret.value !== "" : ret.specified ) ?
        ret.value :
        undefined;
    },
    set: function( elem, value, name ) {
      // Set the existing or create a new attribute node
      var ret = elem.getAttributeNode( name );
      if ( !ret ) {
        ret = document.createAttribute( name );
        elem.setAttributeNode( ret );
      }
      return ( ret.value = value + "" );
    }
  };

  // Set width and height to auto instead of 0 on empty string( Bug #8150 )
  // This is for removals
  jQuery.each([ "width", "height" ], function( i, name ) {
    jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
      set: function( elem, value ) {
        if ( value === "" ) {
          elem.setAttribute( name, "auto" );
          return value;
        }
      }
    });
  });

  // Set contenteditable to false on removals(#10429)
  // Setting to empty string throws an error as an invalid value
  jQuery.attrHooks.contenteditable = {
    get: nodeHook.get,
    set: function( elem, value, name ) {
      if ( value === "" ) {
        value = "false";
      }
      nodeHook.set( elem, value, name );
    }
  };
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
  jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
    jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
      get: function( elem ) {
        var ret = elem.getAttribute( name, 2 );
        return ret === null ? undefined : ret;
      }
    });
  });
}

if ( !jQuery.support.style ) {
  jQuery.attrHooks.style = {
    get: function( elem ) {
      // Return undefined in the case of empty string
      // Normalize to lowercase since IE uppercases css property names
      return elem.style.cssText.toLowerCase() || undefined;
    },
    set: function( elem, value ) {
      return ( elem.style.cssText = value + "" );
    }
  };
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
  jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
    get: function( elem ) {
      var parent = elem.parentNode;

      if ( parent ) {
        parent.selectedIndex;

        // Make sure that it also works with optgroups, see #5701
        if ( parent.parentNode ) {
          parent.parentNode.selectedIndex;
        }
      }
      return null;
    }
  });
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
  jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
  jQuery.each([ "radio", "checkbox" ], function() {
    jQuery.valHooks[ this ] = {
      get: function( elem ) {
        // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
        return elem.getAttribute("value") === null ? "on" : elem.value;
      }
    };
  });
}
jQuery.each([ "radio", "checkbox" ], function() {
  jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
    set: function( elem, value ) {
      if ( jQuery.isArray( value ) ) {
        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
      }
    }
  });
});
var rformElems = /^(?:textarea|input|select)$/i,
  rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
  rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
  rkeyEvent = /^key/,
  rmouseEvent = /^(?:mouse|contextmenu)|click/,
  rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  hoverHack = function( events ) {
    return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
  };

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

  add: function( elem, types, handler, data, selector ) {

    var elemData, eventHandle, events,
      t, tns, type, namespaces, handleObj,
      handleObjIn, handlers, special;

    // Don't attach events to noData or text/comment nodes (allow plain objects tho)
    if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
      return;
    }

    // Caller can pass in an object of custom data in lieu of the handler
    if ( handler.handler ) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
      selector = handleObjIn.selector;
    }

    // Make sure that the handler has a unique ID, used to find/remove it later
    if ( !handler.guid ) {
      handler.guid = jQuery.guid++;
    }

    // Init the element's event structure and main handler, if this is the first
    events = elemData.events;
    if ( !events ) {
      elemData.events = events = {};
    }
    eventHandle = elemData.handle;
    if ( !eventHandle ) {
      elemData.handle = eventHandle = function( e ) {
        // Discard the second event of a jQuery.event.trigger() and
        // when an event is called after a page has unloaded
        return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
          jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
          undefined;
      };
      // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
      eventHandle.elem = elem;
    }

    // Handle multiple events separated by a space
    // jQuery(...).bind("mouseover mouseout", fn);
    types = jQuery.trim( hoverHack(types) ).split( " " );
    for ( t = 0; t < types.length; t++ ) {

      tns = rtypenamespace.exec( types[t] ) || [];
      type = tns[1];
      namespaces = ( tns[2] || "" ).split( "." ).sort();

      // If event changes its type, use the special event handlers for the changed type
      special = jQuery.event.special[ type ] || {};

      // If selector defined, determine special event api type, otherwise given type
      type = ( selector ? special.delegateType : special.bindType ) || type;

      // Update special based on newly reset type
      special = jQuery.event.special[ type ] || {};

      // handleObj is passed to all event handlers
      handleObj = jQuery.extend({
        type: type,
        origType: tns[1],
        data: data,
        handler: handler,
        guid: handler.guid,
        selector: selector,
        needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
        namespace: namespaces.join(".")
      }, handleObjIn );

      // Init the event handler queue if we're the first
      handlers = events[ type ];
      if ( !handlers ) {
        handlers = events[ type ] = [];
        handlers.delegateCount = 0;

        // Only use addEventListener/attachEvent if the special events handler returns false
        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
          // Bind the global event handler to the element
          if ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, false );

          } else if ( elem.attachEvent ) {
            elem.attachEvent( "on" + type, eventHandle );
          }
        }
      }

      if ( special.add ) {
        special.add.call( elem, handleObj );

        if ( !handleObj.handler.guid ) {
          handleObj.handler.guid = handler.guid;
        }
      }

      // Add to the element's handler list, delegates in front
      if ( selector ) {
        handlers.splice( handlers.delegateCount++, 0, handleObj );
      } else {
        handlers.push( handleObj );
      }

      // Keep track of which events have ever been used, for event optimization
      jQuery.event.global[ type ] = true;
    }

    // Nullify elem to prevent memory leaks in IE
    elem = null;
  },

  global: {},

  // Detach an event or set of events from an element
  remove: function( elem, types, handler, selector, mappedTypes ) {

    var t, tns, type, origType, namespaces, origCount,
      j, events, special, eventType, handleObj,
      elemData = jQuery.hasData( elem ) && jQuery._data( elem );

    if ( !elemData || !(events = elemData.events) ) {
      return;
    }

    // Once for each type.namespace in types; type may be omitted
    types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
    for ( t = 0; t < types.length; t++ ) {
      tns = rtypenamespace.exec( types[t] ) || [];
      type = origType = tns[1];
      namespaces = tns[2];

      // Unbind all events (on this namespace, if provided) for the element
      if ( !type ) {
        for ( type in events ) {
          jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
        }
        continue;
      }

      special = jQuery.event.special[ type ] || {};
      type = ( selector? special.delegateType : special.bindType ) || type;
      eventType = events[ type ] || [];
      origCount = eventType.length;
      namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

      // Remove matching events
      for ( j = 0; j < eventType.length; j++ ) {
        handleObj = eventType[ j ];

        if ( ( mappedTypes || origType === handleObj.origType ) &&
           ( !handler || handler.guid === handleObj.guid ) &&
           ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
           ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
          eventType.splice( j--, 1 );

          if ( handleObj.selector ) {
            eventType.delegateCount--;
          }
          if ( special.remove ) {
            special.remove.call( elem, handleObj );
          }
        }
      }

      // Remove generic event handler if we removed something and no more handlers exist
      // (avoids potential for endless recursion during removal of special event handlers)
      if ( eventType.length === 0 && origCount !== eventType.length ) {
        if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
          jQuery.removeEvent( elem, type, elemData.handle );
        }

        delete events[ type ];
      }
    }

    // Remove the expando if it's no longer used
    if ( jQuery.isEmptyObject( events ) ) {
      delete elemData.handle;

      // removeData also checks for emptiness and clears the expando if empty
      // so use it instead of delete
      jQuery.removeData( elem, "events", true );
    }
  },

  // Events that are safe to short-circuit if no handlers are attached.
  // Native DOM events should not be added, they may have inline handlers.
  customEvent: {
    "getData": true,
    "setData": true,
    "changeData": true
  },

  trigger: function( event, data, elem, onlyHandlers ) {
    // Don't do events on text and comment nodes
    if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
      return;
    }

    // Event object or event type
    var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
      type = event.type || event,
      namespaces = [];

    // focus/blur morphs to focusin/out; ensure we're not firing them right now
    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
      return;
    }

    if ( type.indexOf( "!" ) >= 0 ) {
      // Exclusive events trigger only for the exact event (no namespaces)
      type = type.slice(0, -1);
      exclusive = true;
    }

    if ( type.indexOf( "." ) >= 0 ) {
      // Namespaced trigger; create a regexp to match event type in handle()
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }

    if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
      // No jQuery handlers for this event type, and it can't have inline handlers
      return;
    }

    // Caller can pass in an Event, Object, or just an event type string
    event = typeof event === "object" ?
      // jQuery.Event object
      event[ jQuery.expando ] ? event :
      // Object literal
      new jQuery.Event( type, event ) :
      // Just the event type (string)
      new jQuery.Event( type );

    event.type = type;
    event.isTrigger = true;
    event.exclusive = exclusive;
    event.namespace = namespaces.join( "." );
    event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
    ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

    // Handle a global trigger
    if ( !elem ) {

      // TODO: Stop taunting the data cache; remove global events and always attach to document
      cache = jQuery.cache;
      for ( i in cache ) {
        if ( cache[ i ].events && cache[ i ].events[ type ] ) {
          jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
        }
      }
      return;
    }

    // Clean up the event in case it is being reused
    event.result = undefined;
    if ( !event.target ) {
      event.target = elem;
    }

    // Clone any incoming data and prepend the event, creating the handler arg list
    data = data != null ? jQuery.makeArray( data ) : [];
    data.unshift( event );

    // Allow special events to draw outside the lines
    special = jQuery.event.special[ type ] || {};
    if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
      return;
    }

    // Determine event propagation path in advance, per W3C events spec (#9951)
    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    eventPath = [[ elem, special.bindType || type ]];
    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

      bubbleType = special.delegateType || type;
      cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
      for ( old = elem; cur; cur = cur.parentNode ) {
        eventPath.push([ cur, bubbleType ]);
        old = cur;
      }

      // Only add window if we got to document (e.g., not plain obj or detached DOM)
      if ( old === (elem.ownerDocument || document) ) {
        eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
      }
    }

    // Fire handlers on the event path
    for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

      cur = eventPath[i][0];
      event.type = eventPath[i][1];

      handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
      if ( handle ) {
        handle.apply( cur, data );
      }
      // Note that this is a bare JS function and not a jQuery handler
      handle = ontype && cur[ ontype ];
      if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
        event.preventDefault();
      }
    }
    event.type = type;

    // If nobody prevented the default action, do it now
    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

      if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
        !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

        // Call a native DOM method on the target with the same name name as the event.
        // Can't use an .isFunction() check here because IE6/7 fails that test.
        // Don't do default actions on window, that's where global variables be (#6170)
        // IE<9 dies on focus/blur to hidden element (#1486)
        if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

          // Don't re-trigger an onFOO event when we call its FOO() method
          old = elem[ ontype ];

          if ( old ) {
            elem[ ontype ] = null;
          }

          // Prevent re-triggering of the same event, since we already bubbled it above
          jQuery.event.triggered = type;
          elem[ type ]();
          jQuery.event.triggered = undefined;

          if ( old ) {
            elem[ ontype ] = old;
          }
        }
      }
    }

    return event.result;
  },

  dispatch: function( event ) {

    // Make a writable jQuery.Event from the native event object
    event = jQuery.event.fix( event || window.event );

    var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
      handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
      delegateCount = handlers.delegateCount,
      args = core_slice.call( arguments ),
      run_all = !event.exclusive && !event.namespace,
      special = jQuery.event.special[ event.type ] || {},
      handlerQueue = [];

    // Use the fix-ed jQuery.Event rather than the (read-only) native event
    args[0] = event;
    event.delegateTarget = this;

    // Call the preDispatch hook for the mapped type, and let it bail if desired
    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
      return;
    }

    // Determine handlers that should run if there are delegated events
    // Avoid non-left-click bubbling in Firefox (#3861)
    if ( delegateCount && !(event.button && event.type === "click") ) {

      for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

        // Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
        if ( cur.disabled !== true || event.type !== "click" ) {
          selMatch = {};
          matches = [];
          for ( i = 0; i < delegateCount; i++ ) {
            handleObj = handlers[ i ];
            sel = handleObj.selector;

            if ( selMatch[ sel ] === undefined ) {
              selMatch[ sel ] = handleObj.needsContext ?
                jQuery( sel, this ).index( cur ) >= 0 :
                jQuery.find( sel, this, null, [ cur ] ).length;
            }
            if ( selMatch[ sel ] ) {
              matches.push( handleObj );
            }
          }
          if ( matches.length ) {
            handlerQueue.push({ elem: cur, matches: matches });
          }
        }
      }
    }

    // Add the remaining (directly-bound) handlers
    if ( handlers.length > delegateCount ) {
      handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
    }

    // Run delegates first; they may want to stop propagation beneath us
    for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
      matched = handlerQueue[ i ];
      event.currentTarget = matched.elem;

      for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
        handleObj = matched.matches[ j ];

        // Triggered event must either 1) be non-exclusive and have no namespace, or
        // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
        if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

          event.data = handleObj.data;
          event.handleObj = handleObj;

          ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
              .apply( matched.elem, args );

          if ( ret !== undefined ) {
            event.result = ret;
            if ( ret === false ) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }

    // Call the postDispatch hook for the mapped type
    if ( special.postDispatch ) {
      special.postDispatch.call( this, event );
    }

    return event.result;
  },

  // Includes some event props shared by KeyEvent and MouseEvent
  // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
  props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

  fixHooks: {},

  keyHooks: {
    props: "char charCode key keyCode".split(" "),
    filter: function( event, original ) {

      // Add which for key events
      if ( event.which == null ) {
        event.which = original.charCode != null ? original.charCode : original.keyCode;
      }

      return event;
    }
  },

  mouseHooks: {
    props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    filter: function( event, original ) {
      var eventDoc, doc, body,
        button = original.button,
        fromElement = original.fromElement;

      // Calculate pageX/Y if missing and clientX/Y available
      if ( event.pageX == null && original.clientX != null ) {
        eventDoc = event.target.ownerDocument || document;
        doc = eventDoc.documentElement;
        body = eventDoc.body;

        event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
        event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
      }

      // Add relatedTarget, if necessary
      if ( !event.relatedTarget && fromElement ) {
        event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
      }

      // Add which for click: 1 === left; 2 === middle; 3 === right
      // Note: button is not normalized, so don't use it
      if ( !event.which && button !== undefined ) {
        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
      }

      return event;
    }
  },

  fix: function( event ) {
    if ( event[ jQuery.expando ] ) {
      return event;
    }

    // Create a writable copy of the event object and normalize some properties
    var i, prop,
      originalEvent = event,
      fixHook = jQuery.event.fixHooks[ event.type ] || {},
      copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

    event = jQuery.Event( originalEvent );

    for ( i = copy.length; i; ) {
      prop = copy[ --i ];
      event[ prop ] = originalEvent[ prop ];
    }

    // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
    if ( !event.target ) {
      event.target = originalEvent.srcElement || document;
    }

    // Target should not be a text node (#504, Safari)
    if ( event.target.nodeType === 3 ) {
      event.target = event.target.parentNode;
    }

    // For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
    event.metaKey = !!event.metaKey;

    return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
  },

  special: {
    load: {
      // Prevent triggered image.load events from bubbling to window.load
      noBubble: true
    },

    focus: {
      delegateType: "focusin"
    },
    blur: {
      delegateType: "focusout"
    },

    beforeunload: {
      setup: function( data, namespaces, eventHandle ) {
        // We only want to do this special case on windows
        if ( jQuery.isWindow( this ) ) {
          this.onbeforeunload = eventHandle;
        }
      },

      teardown: function( namespaces, eventHandle ) {
        if ( this.onbeforeunload === eventHandle ) {
          this.onbeforeunload = null;
        }
      }
    }
  },

  simulate: function( type, elem, event, bubble ) {
    // Piggyback on a donor event to simulate a different one.
    // Fake originalEvent to avoid donor's stopPropagation, but if the
    // simulated event prevents default then we do the same on the donor.
    var e = jQuery.extend(
      new jQuery.Event(),
      event,
      { type: type,
        isSimulated: true,
        originalEvent: {}
      }
    );
    if ( bubble ) {
      jQuery.event.trigger( e, null, elem );
    } else {
      jQuery.event.dispatch.call( elem, e );
    }
    if ( e.isDefaultPrevented() ) {
      event.preventDefault();
    }
  }
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
  function( elem, type, handle ) {
    if ( elem.removeEventListener ) {
      elem.removeEventListener( type, handle, false );
    }
  } :
  function( elem, type, handle ) {
    var name = "on" + type;

    if ( elem.detachEvent ) {

      // #8545, #7054, preventing memory leaks for custom events in IE6-8 –
      // detachEvent needed property on element, by name of that event, to properly expose it to GC
      if ( typeof elem[ name ] === "undefined" ) {
        elem[ name ] = null;
      }

      elem.detachEvent( name, handle );
    }
  };

jQuery.Event = function( src, props ) {
  // Allow instantiation without the 'new' keyword
  if ( !(this instanceof jQuery.Event) ) {
    return new jQuery.Event( src, props );
  }

  // Event object
  if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
      src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if ( props ) {
    jQuery.extend( this, props );
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || jQuery.now();

  // Mark it as fixed
  this[ jQuery.expando ] = true;
};

function returnFalse() {
  return false;
}
function returnTrue() {
  return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
  preventDefault: function() {
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }

    // if preventDefault exists run it on the original event
    if ( e.preventDefault ) {
      e.preventDefault();

    // otherwise set the returnValue property of the original event to false (IE)
    } else {
      e.returnValue = false;
    }
  },
  stopPropagation: function() {
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }
    // if stopPropagation exists run it on the original event
    if ( e.stopPropagation ) {
      e.stopPropagation();
    }
    // otherwise set the cancelBubble property of the original event to true (IE)
    e.cancelBubble = true;
  },
  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
  mouseenter: "mouseover",
  mouseleave: "mouseout"
}, function( orig, fix ) {
  jQuery.event.special[ orig ] = {
    delegateType: fix,
    bindType: fix,

    handle: function( event ) {
      var ret,
        target = this,
        related = event.relatedTarget,
        handleObj = event.handleObj,
        selector = handleObj.selector;

      // For mousenter/leave call the handler if related is outside the target.
      // NB: No relatedTarget if the mouse left/entered the browser window
      if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply( this, arguments );
        event.type = fix;
      }
      return ret;
    }
  };
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

  jQuery.event.special.submit = {
    setup: function() {
      // Only need this for delegated form submit events
      if ( jQuery.nodeName( this, "form" ) ) {
        return false;
      }

      // Lazy-add a submit handler when a descendant form may potentially be submitted
      jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
        // Node name check avoids a VML-related crash in IE (#9807)
        var elem = e.target,
          form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
        if ( form && !jQuery._data( form, "_submit_attached" ) ) {
          jQuery.event.add( form, "submit._submit", function( event ) {
            event._submit_bubble = true;
          });
          jQuery._data( form, "_submit_attached", true );
        }
      });
      // return undefined since we don't need an event listener
    },

    postDispatch: function( event ) {
      // If form was submitted by the user, bubble the event up the tree
      if ( event._submit_bubble ) {
        delete event._submit_bubble;
        if ( this.parentNode && !event.isTrigger ) {
          jQuery.event.simulate( "submit", this.parentNode, event, true );
        }
      }
    },

    teardown: function() {
      // Only need this for delegated form submit events
      if ( jQuery.nodeName( this, "form" ) ) {
        return false;
      }

      // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
      jQuery.event.remove( this, "._submit" );
    }
  };
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

  jQuery.event.special.change = {

    setup: function() {

      if ( rformElems.test( this.nodeName ) ) {
        // IE doesn't fire change on a check/radio until blur; trigger it on click
        // after a propertychange. Eat the blur-change in special.change.handle.
        // This still fires onchange a second time for check/radio after blur.
        if ( this.type === "checkbox" || this.type === "radio" ) {
          jQuery.event.add( this, "propertychange._change", function( event ) {
            if ( event.originalEvent.propertyName === "checked" ) {
              this._just_changed = true;
            }
          });
          jQuery.event.add( this, "click._change", function( event ) {
            if ( this._just_changed && !event.isTrigger ) {
              this._just_changed = false;
            }
            // Allow triggered, simulated change events (#11500)
            jQuery.event.simulate( "change", this, event, true );
          });
        }
        return false;
      }
      // Delegated event; lazy-add a change handler on descendant inputs
      jQuery.event.add( this, "beforeactivate._change", function( e ) {
        var elem = e.target;

        if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
          jQuery.event.add( elem, "change._change", function( event ) {
            if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
              jQuery.event.simulate( "change", this.parentNode, event, true );
            }
          });
          jQuery._data( elem, "_change_attached", true );
        }
      });
    },

    handle: function( event ) {
      var elem = event.target;

      // Swallow native change events from checkbox/radio, we already triggered them above
      if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
        return event.handleObj.handler.apply( this, arguments );
      }
    },

    teardown: function() {
      jQuery.event.remove( this, "._change" );

      return !rformElems.test( this.nodeName );
    }
  };
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
  jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

    // Attach a single capturing handler while someone wants focusin/focusout
    var attaches = 0,
      handler = function( event ) {
        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
      };

    jQuery.event.special[ fix ] = {
      setup: function() {
        if ( attaches++ === 0 ) {
          document.addEventListener( orig, handler, true );
        }
      },
      teardown: function() {
        if ( --attaches === 0 ) {
          document.removeEventListener( orig, handler, true );
        }
      }
    };
  });
}

jQuery.fn.extend({

  on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
    var origFn, type;

    // Types can be a map of types/handlers
    if ( typeof types === "object" ) {
      // ( types-Object, selector, data )
      if ( typeof selector !== "string" ) { // && selector != null
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }
      for ( type in types ) {
        this.on( type, selector, data, types[ type ], one );
      }
      return this;
    }

    if ( data == null && fn == null ) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if ( fn == null ) {
      if ( typeof selector === "string" ) {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if ( fn === false ) {
      fn = returnFalse;
    } else if ( !fn ) {
      return this;
    }

    if ( one === 1 ) {
      origFn = fn;
      fn = function( event ) {
        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
      };
      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    }
    return this.each( function() {
      jQuery.event.add( this, types, fn, data, selector );
    });
  },
  one: function( types, selector, data, fn ) {
    return this.on( types, selector, data, fn, 1 );
  },
  off: function( types, selector, fn ) {
    var handleObj, type;
    if ( types && types.preventDefault && types.handleObj ) {
      // ( event )  dispatched jQuery.Event
      handleObj = types.handleObj;
      jQuery( types.delegateTarget ).off(
        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
        handleObj.selector,
        handleObj.handler
      );
      return this;
    }
    if ( typeof types === "object" ) {
      // ( types-object [, selector] )
      for ( type in types ) {
        this.off( type, selector, types[ type ] );
      }
      return this;
    }
    if ( selector === false || typeof selector === "function" ) {
      // ( types [, fn] )
      fn = selector;
      selector = undefined;
    }
    if ( fn === false ) {
      fn = returnFalse;
    }
    return this.each(function() {
      jQuery.event.remove( this, types, fn, selector );
    });
  },

  bind: function( types, data, fn ) {
    return this.on( types, null, data, fn );
  },
  unbind: function( types, fn ) {
    return this.off( types, null, fn );
  },

  live: function( types, data, fn ) {
    jQuery( this.context ).on( types, this.selector, data, fn );
    return this;
  },
  die: function( types, fn ) {
    jQuery( this.context ).off( types, this.selector || "**", fn );
    return this;
  },

  delegate: function( selector, types, data, fn ) {
    return this.on( types, selector, data, fn );
  },
  undelegate: function( selector, types, fn ) {
    // ( namespace ) or ( selector, types [, fn] )
    return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
  },

  trigger: function( type, data ) {
    return this.each(function() {
      jQuery.event.trigger( type, data, this );
    });
  },
  triggerHandler: function( type, data ) {
    if ( this[0] ) {
      return jQuery.event.trigger( type, data, this[0], true );
    }
  },

  toggle: function( fn ) {
    // Save reference to arguments for access in closure
    var args = arguments,
      guid = fn.guid || jQuery.guid++,
      i = 0,
      toggler = function( event ) {
        // Figure out which function to execute
        var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
        jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

        // Make sure that clicks stop
        event.preventDefault();

        // and execute the function
        return args[ lastToggle ].apply( this, arguments ) || false;
      };

    // link all the functions, so any of them can unbind this click handler
    toggler.guid = guid;
    while ( i < args.length ) {
      args[ i++ ].guid = guid;
    }

    return this.click( toggler );
  },

  hover: function( fnOver, fnOut ) {
    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  }
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

  // Handle event binding
  jQuery.fn[ name ] = function( data, fn ) {
    if ( fn == null ) {
      fn = data;
      data = null;
    }

    return arguments.length > 0 ?
      this.on( name, null, data, fn ) :
      this.trigger( name );
  };

  if ( rkeyEvent.test( name ) ) {
    jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
  }

  if ( rmouseEvent.test( name ) ) {
    jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
  }
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var cachedruns,
  assertGetIdNotName,
  Expr,
  getText,
  isXML,
  contains,
  compile,
  sortOrder,
  hasDuplicate,
  outermostContext,

  baseHasDuplicate = true,
  strundefined = "undefined",

  expando = ( "sizcache" + Math.random() ).replace( ".", "" ),

  Token = String,
  document = window.document,
  docElem = document.documentElement,
  dirruns = 0,
  done = 0,
  pop = [].pop,
  push = [].push,
  slice = [].slice,
  // Use a stripped-down indexOf if a native one is unavailable
  indexOf = [].indexOf || function( elem ) {
    var i = 0,
      len = this.length;
    for ( ; i < len; i++ ) {
      if ( this[i] === elem ) {
        return i;
      }
    }
    return -1;
  },

  // Augment a function for special use by Sizzle
  markFunction = function( fn, value ) {
    fn[ expando ] = value == null || value;
    return fn;
  },

  createCache = function() {
    var cache = {},
      keys = [];

    return markFunction(function( key, value ) {
      // Only keep the most recent entries
      if ( keys.push( key ) > Expr.cacheLength ) {
        delete cache[ keys.shift() ];
      }

      return (cache[ key ] = value);
    }, cache );
  },

  classCache = createCache(),
  tokenCache = createCache(),
  compilerCache = createCache(),

  // Regex

  // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
  whitespace = "[\\x20\\t\\r\\n\\f]",
  // http://www.w3.org/TR/css3-syntax/#characters
  characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

  // Loosely modeled on CSS identifier characters
  // An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
  // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  identifier = characterEncoding.replace( "w", "w#" ),

  // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
  operators = "([*^$|!~]?=)",
  attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
    "*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

  // Prefer arguments not in parens/brackets,
  //   then attribute selectors and non-pseudos (denoted by :),
  //   then anything else
  // These preferences are here to reduce the number of selectors
  //   needing tokenize in the PSEUDO preFilter
  pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

  // For matchExpr.POS and matchExpr.needsContext
  pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
    "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

  // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

  rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
  rpseudo = new RegExp( pseudos ),

  // Easily-parseable/retrievable ID or TAG or CLASS selectors
  rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

  rnot = /^:not/,
  rsibling = /[\x20\t\r\n\f]*[+~]/,
  rendsWithNot = /:not\($/,

  rheader = /h\d/i,
  rinputs = /input|select|textarea|button/i,

  rbackslash = /\\(?!\\)/g,

  matchExpr = {
    "ID": new RegExp( "^#(" + characterEncoding + ")" ),
    "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
    "NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
    "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
    "ATTR": new RegExp( "^" + attributes ),
    "PSEUDO": new RegExp( "^" + pseudos ),
    "POS": new RegExp( pos, "i" ),
    "CHILD": new RegExp( "^:(only|nth|first|last)-child(?:\\(" + whitespace +
      "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
      "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
    // For use in libraries implementing .is()
    "needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
  },

  // Support

  // Used for testing something on an element
  assert = function( fn ) {
    var div = document.createElement("div");

    try {
      return fn( div );
    } catch (e) {
      return false;
    } finally {
      // release memory in IE
      div = null;
    }
  },

  // Check if getElementsByTagName("*") returns only elements
  assertTagNameNoComments = assert(function( div ) {
    div.appendChild( document.createComment("") );
    return !div.getElementsByTagName("*").length;
  }),

  // Check if getAttribute returns normalized href attributes
  assertHrefNotNormalized = assert(function( div ) {
    div.innerHTML = "<a href='#'></a>";
    return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
      div.firstChild.getAttribute("href") === "#";
  }),

  // Check if attributes should be retrieved by attribute nodes
  assertAttributes = assert(function( div ) {
    div.innerHTML = "<select></select>";
    var type = typeof div.lastChild.getAttribute("multiple");
    // IE8 returns a string for some attributes even when not present
    return type !== "boolean" && type !== "string";
  }),

  // Check if getElementsByClassName can be trusted
  assertUsableClassName = assert(function( div ) {
    // Opera can't find a second classname (in 9.6)
    div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
    if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
      return false;
    }

    // Safari 3.2 caches class attributes and doesn't catch changes
    div.lastChild.className = "e";
    return div.getElementsByClassName("e").length === 2;
  }),

  // Check if getElementById returns elements by name
  // Check if getElementsByName privileges form controls or returns elements by ID
  assertUsableName = assert(function( div ) {
    // Inject content
    div.id = expando + 0;
    div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
    docElem.insertBefore( div, docElem.firstChild );

    // Test
    var pass = document.getElementsByName &&
      // buggy browsers will return fewer than the correct 2
      document.getElementsByName( expando ).length === 2 +
      // buggy browsers will return more than the correct 0
      document.getElementsByName( expando + 0 ).length;
    assertGetIdNotName = !document.getElementById( expando );

    // Cleanup
    docElem.removeChild( div );

    return pass;
  });

// If slice is not available, provide a backup
try {
  slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
  slice = function( i ) {
    var elem,
      results = [];
    for ( ; (elem = this[i]); i++ ) {
      results.push( elem );
    }
    return results;
  };
}

function Sizzle( selector, context, results, seed ) {
  results = results || [];
  context = context || document;
  var match, elem, xml, m,
    nodeType = context.nodeType;

  if ( !selector || typeof selector !== "string" ) {
    return results;
  }

  if ( nodeType !== 1 && nodeType !== 9 ) {
    return [];
  }

  xml = isXML( context );

  if ( !xml && !seed ) {
    if ( (match = rquickExpr.exec( selector )) ) {
      // Speed-up: Sizzle("#ID")
      if ( (m = match[1]) ) {
        if ( nodeType === 9 ) {
          elem = context.getElementById( m );
          // Check parentNode to catch when Blackberry 4.6 returns
          // nodes that are no longer in the document #6963
          if ( elem && elem.parentNode ) {
            // Handle the case where IE, Opera, and Webkit return items
            // by name instead of ID
            if ( elem.id === m ) {
              results.push( elem );
              return results;
            }
          } else {
            return results;
          }
        } else {
          // Context is not a document
          if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
            contains( context, elem ) && elem.id === m ) {
            results.push( elem );
            return results;
          }
        }

      // Speed-up: Sizzle("TAG")
      } else if ( match[2] ) {
        push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
        return results;

      // Speed-up: Sizzle(".CLASS")
      } else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
        push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
        return results;
      }
    }
  }

  // All others
  return select( selector.replace( rtrim, "$1" ), context, results, seed, xml );
}

Sizzle.matches = function( expr, elements ) {
  return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
  return Sizzle( expr, null, null, [ elem ] ).length > 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
  return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return name === "input" && elem.type === type;
  };
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
  return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return (name === "input" || name === "button") && elem.type === type;
  };
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
  return markFunction(function( argument ) {
    argument = +argument;
    return markFunction(function( seed, matches ) {
      var j,
        matchIndexes = fn( [], seed.length, argument ),
        i = matchIndexes.length;

      // Match elements found at the specified indexes
      while ( i-- ) {
        if ( seed[ (j = matchIndexes[i]) ] ) {
          seed[j] = !(matches[j] = seed[j]);
        }
      }
    });
  });
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
  var node,
    ret = "",
    i = 0,
    nodeType = elem.nodeType;

  if ( nodeType ) {
    if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
      // Use textContent for elements
      // innerText usage removed for consistency of new lines (see #11153)
      if ( typeof elem.textContent === "string" ) {
        return elem.textContent;
      } else {
        // Traverse its children
        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
          ret += getText( elem );
        }
      }
    } else if ( nodeType === 3 || nodeType === 4 ) {
      return elem.nodeValue;
    }
    // Do not include comment or processing instruction nodes
  } else {

    // If no nodeType, this is expected to be an array
    for ( ; (node = elem[i]); i++ ) {
      // Do not traverse comment nodes
      ret += getText( node );
    }
  }
  return ret;
};

isXML = Sizzle.isXML = function( elem ) {
  // documentElement is verified for cases where it doesn't yet exist
  // (such as loading iframes in IE - #4833)
  var documentElement = elem && (elem.ownerDocument || elem).documentElement;
  return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Element contains another
contains = Sizzle.contains = docElem.contains ?
  function( a, b ) {
    var adown = a.nodeType === 9 ? a.documentElement : a,
      bup = b && b.parentNode;
    return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
  } :
  docElem.compareDocumentPosition ?
  function( a, b ) {
    return b && !!( a.compareDocumentPosition( b ) & 16 );
  } :
  function( a, b ) {
    while ( (b = b.parentNode) ) {
      if ( b === a ) {
        return true;
      }
    }
    return false;
  };

Sizzle.attr = function( elem, name ) {
  var val,
    xml = isXML( elem );

  if ( !xml ) {
    name = name.toLowerCase();
  }
  if ( (val = Expr.attrHandle[ name ]) ) {
    return val( elem );
  }
  if ( xml || assertAttributes ) {
    return elem.getAttribute( name );
  }
  val = elem.getAttributeNode( name );
  return val ?
    typeof elem[ name ] === "boolean" ?
      elem[ name ] ? name : null :
      val.specified ? val.value : null :
    null;
};

Expr = Sizzle.selectors = {

  // Can be adjusted by the user
  cacheLength: 50,

  createPseudo: markFunction,

  match: matchExpr,

  // IE6/7 return a modified href
  attrHandle: assertHrefNotNormalized ?
    {} :
    {
      "href": function( elem ) {
        return elem.getAttribute( "href", 2 );
      },
      "type": function( elem ) {
        return elem.getAttribute("type");
      }
    },

  find: {
    "ID": assertGetIdNotName ?
      function( id, context, xml ) {
        if ( typeof context.getElementById !== strundefined && !xml ) {
          var m = context.getElementById( id );
          // Check parentNode to catch when Blackberry 4.6 returns
          // nodes that are no longer in the document #6963
          return m && m.parentNode ? [m] : [];
        }
      } :
      function( id, context, xml ) {
        if ( typeof context.getElementById !== strundefined && !xml ) {
          var m = context.getElementById( id );

          return m ?
            m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
              [m] :
              undefined :
            [];
        }
      },

    "TAG": assertTagNameNoComments ?
      function( tag, context ) {
        if ( typeof context.getElementsByTagName !== strundefined ) {
          return context.getElementsByTagName( tag );
        }
      } :
      function( tag, context ) {
        var results = context.getElementsByTagName( tag );

        // Filter out possible comments
        if ( tag === "*" ) {
          var elem,
            tmp = [],
            i = 0;

          for ( ; (elem = results[i]); i++ ) {
            if ( elem.nodeType === 1 ) {
              tmp.push( elem );
            }
          }

          return tmp;
        }
        return results;
      },

    "NAME": assertUsableName && function( tag, context ) {
      if ( typeof context.getElementsByName !== strundefined ) {
        return context.getElementsByName( name );
      }
    },

    "CLASS": assertUsableClassName && function( className, context, xml ) {
      if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
        return context.getElementsByClassName( className );
      }
    }
  },

  relative: {
    ">": { dir: "parentNode", first: true },
    " ": { dir: "parentNode" },
    "+": { dir: "previousSibling", first: true },
    "~": { dir: "previousSibling" }
  },

  preFilter: {
    "ATTR": function( match ) {
      match[1] = match[1].replace( rbackslash, "" );

      // Move the given value to match[3] whether quoted or unquoted
      match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );

      if ( match[2] === "~=" ) {
        match[3] = " " + match[3] + " ";
      }

      return match.slice( 0, 4 );
    },

    "CHILD": function( match ) {
      /* matches from matchExpr["CHILD"]
        1 type (only|nth|...)
        2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
        3 xn-component of xn+y argument ([+-]?\d*n|)
        4 sign of xn-component
        5 x of xn-component
        6 sign of y-component
        7 y of y-component
      */
      match[1] = match[1].toLowerCase();

      if ( match[1] === "nth" ) {
        // nth-child requires argument
        if ( !match[2] ) {
          Sizzle.error( match[0] );
        }

        // numeric x and y parameters for Expr.filter.CHILD
        // remember that false/true cast respectively to 0/1
        match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
        match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

      // other types prohibit arguments
      } else if ( match[2] ) {
        Sizzle.error( match[0] );
      }

      return match;
    },

    "PSEUDO": function( match ) {
      var unquoted, excess;
      if ( matchExpr["CHILD"].test( match[0] ) ) {
        return null;
      }

      if ( match[3] ) {
        match[2] = match[3];
      } else if ( (unquoted = match[4]) ) {
        // Only check arguments that contain a pseudo
        if ( rpseudo.test(unquoted) &&
          // Get excess from tokenize (recursively)
          (excess = tokenize( unquoted, true )) &&
          // advance to the next closing parenthesis
          (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

          // excess is a negative index
          unquoted = unquoted.slice( 0, excess );
          match[0] = match[0].slice( 0, excess );
        }
        match[2] = unquoted;
      }

      // Return only captures needed by the pseudo filter method (type and argument)
      return match.slice( 0, 3 );
    }
  },

  filter: {
    "ID": assertGetIdNotName ?
      function( id ) {
        id = id.replace( rbackslash, "" );
        return function( elem ) {
          return elem.getAttribute("id") === id;
        };
      } :
      function( id ) {
        id = id.replace( rbackslash, "" );
        return function( elem ) {
          var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
          return node && node.value === id;
        };
      },

    "TAG": function( nodeName ) {
      if ( nodeName === "*" ) {
        return function() { return true; };
      }
      nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();

      return function( elem ) {
        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
      };
    },

    "CLASS": function( className ) {
      var pattern = classCache[ expando ][ className ];
      if ( !pattern ) {
        pattern = classCache( className, new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)") );
      }
      return function( elem ) {
        return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
      };
    },

    "ATTR": function( name, operator, check ) {
      return function( elem, context ) {
        var result = Sizzle.attr( elem, name );

        if ( result == null ) {
          return operator === "!=";
        }
        if ( !operator ) {
          return true;
        }

        result += "";

        return operator === "=" ? result === check :
          operator === "!=" ? result !== check :
          operator === "^=" ? check && result.indexOf( check ) === 0 :
          operator === "*=" ? check && result.indexOf( check ) > -1 :
          operator === "$=" ? check && result.substr( result.length - check.length ) === check :
          operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
          operator === "|=" ? result === check || result.substr( 0, check.length + 1 ) === check + "-" :
          false;
      };
    },

    "CHILD": function( type, argument, first, last ) {

      if ( type === "nth" ) {
        return function( elem ) {
          var node, diff,
            parent = elem.parentNode;

          if ( first === 1 && last === 0 ) {
            return true;
          }

          if ( parent ) {
            diff = 0;
            for ( node = parent.firstChild; node; node = node.nextSibling ) {
              if ( node.nodeType === 1 ) {
                diff++;
                if ( elem === node ) {
                  break;
                }
              }
            }
          }

          // Incorporate the offset (or cast to NaN), then check against cycle size
          diff -= last;
          return diff === first || ( diff % first === 0 && diff / first >= 0 );
        };
      }

      return function( elem ) {
        var node = elem;

        switch ( type ) {
          case "only":
          case "first":
            while ( (node = node.previousSibling) ) {
              if ( node.nodeType === 1 ) {
                return false;
              }
            }

            if ( type === "first" ) {
              return true;
            }

            node = elem;

            /* falls through */
          case "last":
            while ( (node = node.nextSibling) ) {
              if ( node.nodeType === 1 ) {
                return false;
              }
            }

            return true;
        }
      };
    },

    "PSEUDO": function( pseudo, argument ) {
      // pseudo-class names are case-insensitive
      // http://www.w3.org/TR/selectors/#pseudo-classes
      // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
      // Remember that setFilters inherits from pseudos
      var args,
        fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
          Sizzle.error( "unsupported pseudo: " + pseudo );

      // The user may use createPseudo to indicate that
      // arguments are needed to create the filter function
      // just as Sizzle does
      if ( fn[ expando ] ) {
        return fn( argument );
      }

      // But maintain support for old signatures
      if ( fn.length > 1 ) {
        args = [ pseudo, pseudo, "", argument ];
        return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
          markFunction(function( seed, matches ) {
            var idx,
              matched = fn( seed, argument ),
              i = matched.length;
            while ( i-- ) {
              idx = indexOf.call( seed, matched[i] );
              seed[ idx ] = !( matches[ idx ] = matched[i] );
            }
          }) :
          function( elem ) {
            return fn( elem, 0, args );
          };
      }

      return fn;
    }
  },

  pseudos: {
    "not": markFunction(function( selector ) {
      // Trim the selector passed to compile
      // to avoid treating leading and trailing
      // spaces as combinators
      var input = [],
        results = [],
        matcher = compile( selector.replace( rtrim, "$1" ) );

      return matcher[ expando ] ?
        markFunction(function( seed, matches, context, xml ) {
          var elem,
            unmatched = matcher( seed, null, xml, [] ),
            i = seed.length;

          // Match elements unmatched by `matcher`
          while ( i-- ) {
            if ( (elem = unmatched[i]) ) {
              seed[i] = !(matches[i] = elem);
            }
          }
        }) :
        function( elem, context, xml ) {
          input[0] = elem;
          matcher( input, null, xml, results );
          return !results.pop();
        };
    }),

    "has": markFunction(function( selector ) {
      return function( elem ) {
        return Sizzle( selector, elem ).length > 0;
      };
    }),

    "contains": markFunction(function( text ) {
      return function( elem ) {
        return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
      };
    }),

    "enabled": function( elem ) {
      return elem.disabled === false;
    },

    "disabled": function( elem ) {
      return elem.disabled === true;
    },

    "checked": function( elem ) {
      // In CSS3, :checked should return both checked and selected elements
      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
      var nodeName = elem.nodeName.toLowerCase();
      return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
    },

    "selected": function( elem ) {
      // Accessing this property makes selected-by-default
      // options in Safari work properly
      if ( elem.parentNode ) {
        elem.parentNode.selectedIndex;
      }

      return elem.selected === true;
    },

    "parent": function( elem ) {
      return !Expr.pseudos["empty"]( elem );
    },

    "empty": function( elem ) {
      // http://www.w3.org/TR/selectors/#empty-pseudo
      // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
      //   not comment, processing instructions, or others
      // Thanks to Diego Perini for the nodeName shortcut
      //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
      var nodeType;
      elem = elem.firstChild;
      while ( elem ) {
        if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
          return false;
        }
        elem = elem.nextSibling;
      }
      return true;
    },

    "header": function( elem ) {
      return rheader.test( elem.nodeName );
    },

    "text": function( elem ) {
      var type, attr;
      // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
      // use getAttribute instead to test this case
      return elem.nodeName.toLowerCase() === "input" &&
        (type = elem.type) === "text" &&
        ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
    },

    // Input types
    "radio": createInputPseudo("radio"),
    "checkbox": createInputPseudo("checkbox"),
    "file": createInputPseudo("file"),
    "password": createInputPseudo("password"),
    "image": createInputPseudo("image"),

    "submit": createButtonPseudo("submit"),
    "reset": createButtonPseudo("reset"),

    "button": function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === "button" || name === "button";
    },

    "input": function( elem ) {
      return rinputs.test( elem.nodeName );
    },

    "focus": function( elem ) {
      var doc = elem.ownerDocument;
      return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href);
    },

    "active": function( elem ) {
      return elem === elem.ownerDocument.activeElement;
    },

    // Positional types
    "first": createPositionalPseudo(function( matchIndexes, length, argument ) {
      return [ 0 ];
    }),

    "last": createPositionalPseudo(function( matchIndexes, length, argument ) {
      return [ length - 1 ];
    }),

    "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
      return [ argument < 0 ? argument + length : argument ];
    }),

    "even": createPositionalPseudo(function( matchIndexes, length, argument ) {
      for ( var i = 0; i < length; i += 2 ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "odd": createPositionalPseudo(function( matchIndexes, length, argument ) {
      for ( var i = 1; i < length; i += 2 ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
      for ( var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    }),

    "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
      for ( var i = argument < 0 ? argument + length : argument; ++i < length; ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    })
  }
};

function siblingCheck( a, b, ret ) {
  if ( a === b ) {
    return ret;
  }

  var cur = a.nextSibling;

  while ( cur ) {
    if ( cur === b ) {
      return -1;
    }

    cur = cur.nextSibling;
  }

  return 1;
}

sortOrder = docElem.compareDocumentPosition ?
  function( a, b ) {
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
      a.compareDocumentPosition :
      a.compareDocumentPosition(b) & 4
    ) ? -1 : 1;
  } :
  function( a, b ) {
    // The nodes are identical, we can exit early
    if ( a === b ) {
      hasDuplicate = true;
      return 0;

    // Fallback to using sourceIndex (in IE) if it's available on both nodes
    } else if ( a.sourceIndex && b.sourceIndex ) {
      return a.sourceIndex - b.sourceIndex;
    }

    var al, bl,
      ap = [],
      bp = [],
      aup = a.parentNode,
      bup = b.parentNode,
      cur = aup;

    // If the nodes are siblings (or identical) we can do a quick check
    if ( aup === bup ) {
      return siblingCheck( a, b );

    // If no parents were found then the nodes are disconnected
    } else if ( !aup ) {
      return -1;

    } else if ( !bup ) {
      return 1;
    }

    // Otherwise they're somewhere else in the tree so we need
    // to build up a full list of the parentNodes for comparison
    while ( cur ) {
      ap.unshift( cur );
      cur = cur.parentNode;
    }

    cur = bup;

    while ( cur ) {
      bp.unshift( cur );
      cur = cur.parentNode;
    }

    al = ap.length;
    bl = bp.length;

    // Start walking down the tree looking for a discrepancy
    for ( var i = 0; i < al && i < bl; i++ ) {
      if ( ap[i] !== bp[i] ) {
        return siblingCheck( ap[i], bp[i] );
      }
    }

    // We ended someplace up the tree so do a sibling check
    return i === al ?
      siblingCheck( a, bp[i], -1 ) :
      siblingCheck( ap[i], b, 1 );
  };

// Always assume the presence of duplicates if sort doesn't
// pass them to our comparison function (as in Google Chrome).
[0, 0].sort( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
  var elem,
    i = 1;

  hasDuplicate = baseHasDuplicate;
  results.sort( sortOrder );

  if ( hasDuplicate ) {
    for ( ; (elem = results[i]); i++ ) {
      if ( elem === results[ i - 1 ] ) {
        results.splice( i--, 1 );
      }
    }
  }

  return results;
};

Sizzle.error = function( msg ) {
  throw new Error( "Syntax error, unrecognized expression: " + msg );
};

function tokenize( selector, parseOnly ) {
  var matched, match, tokens, type, soFar, groups, preFilters,
    cached = tokenCache[ expando ][ selector ];

  if ( cached ) {
    return parseOnly ? 0 : cached.slice( 0 );
  }

  soFar = selector;
  groups = [];
  preFilters = Expr.preFilter;

  while ( soFar ) {

    // Comma and first run
    if ( !matched || (match = rcomma.exec( soFar )) ) {
      if ( match ) {
        soFar = soFar.slice( match[0].length );
      }
      groups.push( tokens = [] );
    }

    matched = false;

    // Combinators
    if ( (match = rcombinators.exec( soFar )) ) {
      tokens.push( matched = new Token( match.shift() ) );
      soFar = soFar.slice( matched.length );

      // Cast descendant combinators to space
      matched.type = match[0].replace( rtrim, " " );
    }

    // Filters
    for ( type in Expr.filter ) {
      if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
        // The last two arguments here are (context, xml) for backCompat
        (match = preFilters[ type ]( match, document, true ))) ) {

        tokens.push( matched = new Token( match.shift() ) );
        soFar = soFar.slice( matched.length );
        matched.type = type;
        matched.matches = match;
      }
    }

    if ( !matched ) {
      break;
    }
  }

  // Return the length of the invalid excess
  // if we're just parsing
  // Otherwise, throw an error or return tokens
  return parseOnly ?
    soFar.length :
    soFar ?
      Sizzle.error( selector ) :
      // Cache the tokens
      tokenCache( selector, groups ).slice( 0 );
}

function addCombinator( matcher, combinator, base ) {
  var dir = combinator.dir,
    checkNonElements = base && combinator.dir === "parentNode",
    doneName = done++;

  return combinator.first ?
    // Check against closest ancestor/preceding element
    function( elem, context, xml ) {
      while ( (elem = elem[ dir ]) ) {
        if ( checkNonElements || elem.nodeType === 1  ) {
          return matcher( elem, context, xml );
        }
      }
    } :

    // Check against all ancestor/preceding elements
    function( elem, context, xml ) {
      // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
      if ( !xml ) {
        var cache,
          dirkey = dirruns + " " + doneName + " ",
          cachedkey = dirkey + cachedruns;
        while ( (elem = elem[ dir ]) ) {
          if ( checkNonElements || elem.nodeType === 1 ) {
            if ( (cache = elem[ expando ]) === cachedkey ) {
              return elem.sizset;
            } else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
              if ( elem.sizset ) {
                return elem;
              }
            } else {
              elem[ expando ] = cachedkey;
              if ( matcher( elem, context, xml ) ) {
                elem.sizset = true;
                return elem;
              }
              elem.sizset = false;
            }
          }
        }
      } else {
        while ( (elem = elem[ dir ]) ) {
          if ( checkNonElements || elem.nodeType === 1 ) {
            if ( matcher( elem, context, xml ) ) {
              return elem;
            }
          }
        }
      }
    };
}

function elementMatcher( matchers ) {
  return matchers.length > 1 ?
    function( elem, context, xml ) {
      var i = matchers.length;
      while ( i-- ) {
        if ( !matchers[i]( elem, context, xml ) ) {
          return false;
        }
      }
      return true;
    } :
    matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
  var elem,
    newUnmatched = [],
    i = 0,
    len = unmatched.length,
    mapped = map != null;

  for ( ; i < len; i++ ) {
    if ( (elem = unmatched[i]) ) {
      if ( !filter || filter( elem, context, xml ) ) {
        newUnmatched.push( elem );
        if ( mapped ) {
          map.push( i );
        }
      }
    }
  }

  return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  if ( postFilter && !postFilter[ expando ] ) {
    postFilter = setMatcher( postFilter );
  }
  if ( postFinder && !postFinder[ expando ] ) {
    postFinder = setMatcher( postFinder, postSelector );
  }
  return markFunction(function( seed, results, context, xml ) {
    // Positional selectors apply to seed elements, so it is invalid to follow them with relative ones
    if ( seed && postFinder ) {
      return;
    }

    var i, elem, postFilterIn,
      preMap = [],
      postMap = [],
      preexisting = results.length,

      // Get initial elements from seed or context
      elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [], seed ),

      // Prefilter to get matcher input, preserving a map for seed-results synchronization
      matcherIn = preFilter && ( seed || !selector ) ?
        condense( elems, preMap, preFilter, context, xml ) :
        elems,

      matcherOut = matcher ?
        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

          // ...intermediate processing is necessary
          [] :

          // ...otherwise use results directly
          results :
        matcherIn;

    // Find primary matches
    if ( matcher ) {
      matcher( matcherIn, matcherOut, context, xml );
    }

    // Apply postFilter
    if ( postFilter ) {
      postFilterIn = condense( matcherOut, postMap );
      postFilter( postFilterIn, [], context, xml );

      // Un-match failing elements by moving them back to matcherIn
      i = postFilterIn.length;
      while ( i-- ) {
        if ( (elem = postFilterIn[i]) ) {
          matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
        }
      }
    }

    // Keep seed and results synchronized
    if ( seed ) {
      // Ignore postFinder because it can't coexist with seed
      i = preFilter && matcherOut.length;
      while ( i-- ) {
        if ( (elem = matcherOut[i]) ) {
          seed[ preMap[i] ] = !(results[ preMap[i] ] = elem);
        }
      }
    } else {
      matcherOut = condense(
        matcherOut === results ?
          matcherOut.splice( preexisting, matcherOut.length ) :
          matcherOut
      );
      if ( postFinder ) {
        postFinder( null, results, matcherOut, xml );
      } else {
        push.apply( results, matcherOut );
      }
    }
  });
}

function matcherFromTokens( tokens ) {
  var checkContext, matcher, j,
    len = tokens.length,
    leadingRelative = Expr.relative[ tokens[0].type ],
    implicitRelative = leadingRelative || Expr.relative[" "],
    i = leadingRelative ? 1 : 0,

    // The foundational matcher ensures that elements are reachable from top-level context(s)
    matchContext = addCombinator( function( elem ) {
      return elem === checkContext;
    }, implicitRelative, true ),
    matchAnyContext = addCombinator( function( elem ) {
      return indexOf.call( checkContext, elem ) > -1;
    }, implicitRelative, true ),
    matchers = [ function( elem, context, xml ) {
      return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
        (checkContext = context).nodeType ?
          matchContext( elem, context, xml ) :
          matchAnyContext( elem, context, xml ) );
    } ];

  for ( ; i < len; i++ ) {
    if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
      matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
    } else {
      // The concatenated values are (context, xml) for backCompat
      matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

      // Return special upon seeing a positional matcher
      if ( matcher[ expando ] ) {
        // Find the next relative operator (if any) for proper handling
        j = ++i;
        for ( ; j < len; j++ ) {
          if ( Expr.relative[ tokens[j].type ] ) {
            break;
          }
        }
        return setMatcher(
          i > 1 && elementMatcher( matchers ),
          i > 1 && tokens.slice( 0, i - 1 ).join("").replace( rtrim, "$1" ),
          matcher,
          i < j && matcherFromTokens( tokens.slice( i, j ) ),
          j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
          j < len && tokens.join("")
        );
      }
      matchers.push( matcher );
    }
  }

  return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  var bySet = setMatchers.length > 0,
    byElement = elementMatchers.length > 0,
    superMatcher = function( seed, context, xml, results, expandContext ) {
      var elem, j, matcher,
        setMatched = [],
        matchedCount = 0,
        i = "0",
        unmatched = seed && [],
        outermost = expandContext != null,
        contextBackup = outermostContext,
        // We must always have either seed elements or context
        elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
        // Nested matchers should use non-integer dirruns
        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

      if ( outermost ) {
        outermostContext = context !== document && context;
        cachedruns = superMatcher.el;
      }

      // Add elements passing elementMatchers directly to results
      for ( ; (elem = elems[i]) != null; i++ ) {
        if ( byElement && elem ) {
          for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
            if ( matcher( elem, context, xml ) ) {
              results.push( elem );
              break;
            }
          }
          if ( outermost ) {
            dirruns = dirrunsUnique;
            cachedruns = ++superMatcher.el;
          }
        }

        // Track unmatched elements for set filters
        if ( bySet ) {
          // They will have gone through all possible matchers
          if ( (elem = !matcher && elem) ) {
            matchedCount--;
          }

          // Lengthen the array for every element, matched or not
          if ( seed ) {
            unmatched.push( elem );
          }
        }
      }

      // Apply set filters to unmatched elements
      matchedCount += i;
      if ( bySet && i !== matchedCount ) {
        for ( j = 0; (matcher = setMatchers[j]); j++ ) {
          matcher( unmatched, setMatched, context, xml );
        }

        if ( seed ) {
          // Reintegrate element matches to eliminate the need for sorting
          if ( matchedCount > 0 ) {
            while ( i-- ) {
              if ( !(unmatched[i] || setMatched[i]) ) {
                setMatched[i] = pop.call( results );
              }
            }
          }

          // Discard index placeholder values to get only actual matches
          setMatched = condense( setMatched );
        }

        // Add matches to results
        push.apply( results, setMatched );

        // Seedless set matches succeeding multiple successful matchers stipulate sorting
        if ( outermost && !seed && setMatched.length > 0 &&
          ( matchedCount + setMatchers.length ) > 1 ) {

          Sizzle.uniqueSort( results );
        }
      }

      // Override manipulation of globals by nested matchers
      if ( outermost ) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }

      return unmatched;
    };

  superMatcher.el = 0;
  return bySet ?
    markFunction( superMatcher ) :
    superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
  var i,
    setMatchers = [],
    elementMatchers = [],
    cached = compilerCache[ expando ][ selector ];

  if ( !cached ) {
    // Generate a function of recursive functions that can be used to check each element
    if ( !group ) {
      group = tokenize( selector );
    }
    i = group.length;
    while ( i-- ) {
      cached = matcherFromTokens( group[i] );
      if ( cached[ expando ] ) {
        setMatchers.push( cached );
      } else {
        elementMatchers.push( cached );
      }
    }

    // Cache the compiled function
    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
  }
  return cached;
};

function multipleContexts( selector, contexts, results, seed ) {
  var i = 0,
    len = contexts.length;
  for ( ; i < len; i++ ) {
    Sizzle( selector, contexts[i], results, seed );
  }
  return results;
}

function select( selector, context, results, seed, xml ) {
  var i, tokens, token, type, find,
    match = tokenize( selector ),
    j = match.length;

  if ( !seed ) {
    // Try to minimize operations if there is only one group
    if ( match.length === 1 ) {

      // Take a shortcut and set the context if the root selector is an ID
      tokens = match[0] = match[0].slice( 0 );
      if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
          context.nodeType === 9 && !xml &&
          Expr.relative[ tokens[1].type ] ) {

        context = Expr.find["ID"]( token.matches[0].replace( rbackslash, "" ), context, xml )[0];
        if ( !context ) {
          return results;
        }

        selector = selector.slice( tokens.shift().length );
      }

      // Fetch a seed set for right-to-left matching
      for ( i = matchExpr["POS"].test( selector ) ? -1 : tokens.length - 1; i >= 0; i-- ) {
        token = tokens[i];

        // Abort if we hit a combinator
        if ( Expr.relative[ (type = token.type) ] ) {
          break;
        }
        if ( (find = Expr.find[ type ]) ) {
          // Search, expanding context for leading sibling combinators
          if ( (seed = find(
            token.matches[0].replace( rbackslash, "" ),
            rsibling.test( tokens[0].type ) && context.parentNode || context,
            xml
          )) ) {

            // If seed is empty or no tokens remain, we can return early
            tokens.splice( i, 1 );
            selector = seed.length && tokens.join("");
            if ( !selector ) {
              push.apply( results, slice.call( seed, 0 ) );
              return results;
            }

            break;
          }
        }
      }
    }
  }

  // Compile and execute a filtering function
  // Provide `match` to avoid retokenization if we modified the selector above
  compile( selector, match )(
    seed,
    context,
    xml,
    results,
    rsibling.test( selector )
  );
  return results;
}

if ( document.querySelectorAll ) {
  (function() {
    var disconnectedMatch,
      oldSelect = select,
      rescape = /'|\\/g,
      rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

      // qSa(:focus) reports false when true (Chrome 21),
      // A support test would require too much code (would include document ready)
      rbuggyQSA = [":focus"],

      // matchesSelector(:focus) reports false when true (Chrome 21),
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
      // A support test would require too much code (would include document ready)
      // just skip matchesSelector for :active
      rbuggyMatches = [ ":active", ":focus" ],
      matches = docElem.matchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.webkitMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector;

    // Build QSA regex
    // Regex strategy adopted from Diego Perini
    assert(function( div ) {
      // Select is set to empty string on purpose
      // This is to test IE's treatment of not explictly
      // setting a boolean content attribute,
      // since its presence should be enough
      // http://bugs.jquery.com/ticket/12359
      div.innerHTML = "<select><option selected=''></option></select>";

      // IE8 - Some boolean attributes are not treated correctly
      if ( !div.querySelectorAll("[selected]").length ) {
        rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
      }

      // Webkit/Opera - :checked should return selected option elements
      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
      // IE8 throws error here (do not put tests after this one)
      if ( !div.querySelectorAll(":checked").length ) {
        rbuggyQSA.push(":checked");
      }
    });

    assert(function( div ) {

      // Opera 10-12/IE9 - ^= $= *= and empty values
      // Should not select anything
      div.innerHTML = "<p test=''></p>";
      if ( div.querySelectorAll("[test^='']").length ) {
        rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
      }

      // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
      // IE8 throws error here (do not put tests after this one)
      div.innerHTML = "<input type='hidden'/>";
      if ( !div.querySelectorAll(":enabled").length ) {
        rbuggyQSA.push(":enabled", ":disabled");
      }
    });

    // rbuggyQSA always contains :focus, so no need for a length check
    rbuggyQSA = /* rbuggyQSA.length && */ new RegExp( rbuggyQSA.join("|") );

    select = function( selector, context, results, seed, xml ) {
      // Only use querySelectorAll when not filtering,
      // when this is not xml,
      // and when no QSA bugs apply
      if ( !seed && !xml && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
        var groups, i,
          old = true,
          nid = expando,
          newContext = context,
          newSelector = context.nodeType === 9 && selector;

        // qSA works strangely on Element-rooted queries
        // We can work around this by specifying an extra ID on the root
        // and working up from there (Thanks to Andrew Dupont for the technique)
        // IE 8 doesn't work on object elements
        if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
          groups = tokenize( selector );

          if ( (old = context.getAttribute("id")) ) {
            nid = old.replace( rescape, "\\$&" );
          } else {
            context.setAttribute( "id", nid );
          }
          nid = "[id='" + nid + "'] ";

          i = groups.length;
          while ( i-- ) {
            groups[i] = nid + groups[i].join("");
          }
          newContext = rsibling.test( selector ) && context.parentNode || context;
          newSelector = groups.join(",");
        }

        if ( newSelector ) {
          try {
            push.apply( results, slice.call( newContext.querySelectorAll(
              newSelector
            ), 0 ) );
            return results;
          } catch(qsaError) {
          } finally {
            if ( !old ) {
              context.removeAttribute("id");
            }
          }
        }
      }

      return oldSelect( selector, context, results, seed, xml );
    };

    if ( matches ) {
      assert(function( div ) {
        // Check to see if it's possible to do matchesSelector
        // on a disconnected node (IE 9)
        disconnectedMatch = matches.call( div, "div" );

        // This should fail with an exception
        // Gecko does not error, returns false instead
        try {
          matches.call( div, "[test!='']:sizzle" );
          rbuggyMatches.push( "!=", pseudos );
        } catch ( e ) {}
      });

      // rbuggyMatches always contains :active and :focus, so no need for a length check
      rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );

      Sizzle.matchesSelector = function( elem, expr ) {
        // Make sure that attribute selectors are quoted
        expr = expr.replace( rattributeQuotes, "='$1']" );

        // rbuggyMatches always contains :active, so no need for an existence check
        if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && (!rbuggyQSA || !rbuggyQSA.test( expr )) ) {
          try {
            var ret = matches.call( elem, expr );

            // IE 9's matchesSelector returns false on disconnected nodes
            if ( ret || disconnectedMatch ||
                // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11 ) {
              return ret;
            }
          } catch(e) {}
        }

        return Sizzle( expr, null, null, [ elem ] ).length > 0;
      };
    }
  })();
}

// Deprecated
Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Back-compat
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
  rparentsprev = /^(?:parents|prev(?:Until|All))/,
  isSimple = /^.[^:#\[\.,]*$/,
  rneedsContext = jQuery.expr.match.needsContext,
  // methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };

jQuery.fn.extend({
  find: function( selector ) {
    var i, l, length, n, r, ret,
      self = this;

    if ( typeof selector !== "string" ) {
      return jQuery( selector ).filter(function() {
        for ( i = 0, l = self.length; i < l; i++ ) {
          if ( jQuery.contains( self[ i ], this ) ) {
            return true;
          }
        }
      });
    }

    ret = this.pushStack( "", "find", selector );

    for ( i = 0, l = this.length; i < l; i++ ) {
      length = ret.length;
      jQuery.find( selector, this[i], ret );

      if ( i > 0 ) {
        // Make sure that the results are unique
        for ( n = length; n < ret.length; n++ ) {
          for ( r = 0; r < length; r++ ) {
            if ( ret[r] === ret[n] ) {
              ret.splice(n--, 1);
              break;
            }
          }
        }
      }
    }

    return ret;
  },

  has: function( target ) {
    var i,
      targets = jQuery( target, this ),
      len = targets.length;

    return this.filter(function() {
      for ( i = 0; i < len; i++ ) {
        if ( jQuery.contains( this, targets[i] ) ) {
          return true;
        }
      }
    });
  },

  not: function( selector ) {
    return this.pushStack( winnow(this, selector, false), "not", selector);
  },

  filter: function( selector ) {
    return this.pushStack( winnow(this, selector, true), "filter", selector );
  },

  is: function( selector ) {
    return !!selector && (
      typeof selector === "string" ?
        // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        rneedsContext.test( selector ) ?
          jQuery( selector, this.context ).index( this[0] ) >= 0 :
          jQuery.filter( selector, this ).length > 0 :
        this.filter( selector ).length > 0 );
  },

  closest: function( selectors, context ) {
    var cur,
      i = 0,
      l = this.length,
      ret = [],
      pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
        jQuery( selectors, context || this.context ) :
        0;

    for ( ; i < l; i++ ) {
      cur = this[i];

      while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
        if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
          ret.push( cur );
          break;
        }
        cur = cur.parentNode;
      }
    }

    ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

    return this.pushStack( ret, "closest", selectors );
  },

  // Determine the position of an element within
  // the matched set of elements
  index: function( elem ) {

    // No argument, return index in parent
    if ( !elem ) {
      return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
    }

    // index in selector
    if ( typeof elem === "string" ) {
      return jQuery.inArray( this[0], jQuery( elem ) );
    }

    // Locate the position of the desired element
    return jQuery.inArray(
      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem, this );
  },

  add: function( selector, context ) {
    var set = typeof selector === "string" ?
        jQuery( selector, context ) :
        jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
      all = jQuery.merge( this.get(), set );

    return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
      all :
      jQuery.unique( all ) );
  },

  addBack: function( selector ) {
    return this.add( selector == null ?
      this.prevObject : this.prevObject.filter(selector)
    );
  }
});

jQuery.fn.andSelf = jQuery.fn.addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
  return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

function sibling( cur, dir ) {
  do {
    cur = cur[ dir ];
  } while ( cur && cur.nodeType !== 1 );

  return cur;
}

jQuery.each({
  parent: function( elem ) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },
  parents: function( elem ) {
    return jQuery.dir( elem, "parentNode" );
  },
  parentsUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "parentNode", until );
  },
  next: function( elem ) {
    return sibling( elem, "nextSibling" );
  },
  prev: function( elem ) {
    return sibling( elem, "previousSibling" );
  },
  nextAll: function( elem ) {
    return jQuery.dir( elem, "nextSibling" );
  },
  prevAll: function( elem ) {
    return jQuery.dir( elem, "previousSibling" );
  },
  nextUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "nextSibling", until );
  },
  prevUntil: function( elem, i, until ) {
    return jQuery.dir( elem, "previousSibling", until );
  },
  siblings: function( elem ) {
    return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
  },
  children: function( elem ) {
    return jQuery.sibling( elem.firstChild );
  },
  contents: function( elem ) {
    return jQuery.nodeName( elem, "iframe" ) ?
      elem.contentDocument || elem.contentWindow.document :
      jQuery.merge( [], elem.childNodes );
  }
}, function( name, fn ) {
  jQuery.fn[ name ] = function( until, selector ) {
    var ret = jQuery.map( this, fn, until );

    if ( !runtil.test( name ) ) {
      selector = until;
    }

    if ( selector && typeof selector === "string" ) {
      ret = jQuery.filter( selector, ret );
    }

    ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

    if ( this.length > 1 && rparentsprev.test( name ) ) {
      ret = ret.reverse();
    }

    return this.pushStack( ret, name, core_slice.call( arguments ).join(",") );
  };
});

jQuery.extend({
  filter: function( expr, elems, not ) {
    if ( not ) {
      expr = ":not(" + expr + ")";
    }

    return elems.length === 1 ?
      jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
      jQuery.find.matches(expr, elems);
  },

  dir: function( elem, dir, until ) {
    var matched = [],
      cur = elem[ dir ];

    while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
      if ( cur.nodeType === 1 ) {
        matched.push( cur );
      }
      cur = cur[dir];
    }
    return matched;
  },

  sibling: function( n, elem ) {
    var r = [];

    for ( ; n; n = n.nextSibling ) {
      if ( n.nodeType === 1 && n !== elem ) {
        r.push( n );
      }
    }

    return r;
  }
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

  // Can't pass null or undefined to indexOf in Firefox 4
  // Set to 0 to skip string check
  qualifier = qualifier || 0;

  if ( jQuery.isFunction( qualifier ) ) {
    return jQuery.grep(elements, function( elem, i ) {
      var retVal = !!qualifier.call( elem, i, elem );
      return retVal === keep;
    });

  } else if ( qualifier.nodeType ) {
    return jQuery.grep(elements, function( elem, i ) {
      return ( elem === qualifier ) === keep;
    });

  } else if ( typeof qualifier === "string" ) {
    var filtered = jQuery.grep(elements, function( elem ) {
      return elem.nodeType === 1;
    });

    if ( isSimple.test( qualifier ) ) {
      return jQuery.filter(qualifier, filtered, !keep);
    } else {
      qualifier = jQuery.filter( qualifier, filtered );
    }
  }

  return jQuery.grep(elements, function( elem, i ) {
    return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
  });
}
function createSafeFragment( document ) {
  var list = nodeNames.split( "|" ),
  safeFrag = document.createDocumentFragment();

  if ( safeFrag.createElement ) {
    while ( list.length ) {
      safeFrag.createElement(
        list.pop()
      );
    }
  }
  return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
    "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
  rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
  rleadingWhitespace = /^\s+/,
  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
  rtagName = /<([\w:]+)/,
  rtbody = /<tbody/i,
  rhtml = /<|&#?\w+;/,
  rnoInnerhtml = /<(?:script|style|link)/i,
  rnocache = /<(?:script|object|embed|option|style)/i,
  rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
  rcheckableType = /^(?:checkbox|radio)$/,
  // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  rscriptType = /\/(java|ecma)script/i,
  rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
  wrapMap = {
    option: [ 1, "<select multiple='multiple'>", "</select>" ],
    legend: [ 1, "<fieldset>", "</fieldset>" ],
    thead: [ 1, "<table>", "</table>" ],
    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
    col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
    area: [ 1, "<map>", "</map>" ],
    _default: [ 0, "", "" ]
  },
  safeFragment = createSafeFragment( document ),
  fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
  wrapMap._default = [ 1, "X<div>", "</div>" ];
}

jQuery.fn.extend({
  text: function( value ) {
    return jQuery.access( this, function( value ) {
      return value === undefined ?
        jQuery.text( this ) :
        this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
    }, null, value, arguments.length );
  },

  wrapAll: function( html ) {
    if ( jQuery.isFunction( html ) ) {
      return this.each(function(i) {
        jQuery(this).wrapAll( html.call(this, i) );
      });
    }

    if ( this[0] ) {
      // The elements to wrap the target around
      var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

      if ( this[0].parentNode ) {
        wrap.insertBefore( this[0] );
      }

      wrap.map(function() {
        var elem = this;

        while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
          elem = elem.firstChild;
        }

        return elem;
      }).append( this );
    }

    return this;
  },

  wrapInner: function( html ) {
    if ( jQuery.isFunction( html ) ) {
      return this.each(function(i) {
        jQuery(this).wrapInner( html.call(this, i) );
      });
    }

    return this.each(function() {
      var self = jQuery( this ),
        contents = self.contents();

      if ( contents.length ) {
        contents.wrapAll( html );

      } else {
        self.append( html );
      }
    });
  },

  wrap: function( html ) {
    var isFunction = jQuery.isFunction( html );

    return this.each(function(i) {
      jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
    });
  },

  unwrap: function() {
    return this.parent().each(function() {
      if ( !jQuery.nodeName( this, "body" ) ) {
        jQuery( this ).replaceWith( this.childNodes );
      }
    }).end();
  },

  append: function() {
    return this.domManip(arguments, true, function( elem ) {
      if ( this.nodeType === 1 || this.nodeType === 11 ) {
        this.appendChild( elem );
      }
    });
  },

  prepend: function() {
    return this.domManip(arguments, true, function( elem ) {
      if ( this.nodeType === 1 || this.nodeType === 11 ) {
        this.insertBefore( elem, this.firstChild );
      }
    });
  },

  before: function() {
    if ( !isDisconnected( this[0] ) ) {
      return this.domManip(arguments, false, function( elem ) {
        this.parentNode.insertBefore( elem, this );
      });
    }

    if ( arguments.length ) {
      var set = jQuery.clean( arguments );
      return this.pushStack( jQuery.merge( set, this ), "before", this.selector );
    }
  },

  after: function() {
    if ( !isDisconnected( this[0] ) ) {
      return this.domManip(arguments, false, function( elem ) {
        this.parentNode.insertBefore( elem, this.nextSibling );
      });
    }

    if ( arguments.length ) {
      var set = jQuery.clean( arguments );
      return this.pushStack( jQuery.merge( this, set ), "after", this.selector );
    }
  },

  // keepData is for internal use only--do not document
  remove: function( selector, keepData ) {
    var elem,
      i = 0;

    for ( ; (elem = this[i]) != null; i++ ) {
      if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
        if ( !keepData && elem.nodeType === 1 ) {
          jQuery.cleanData( elem.getElementsByTagName("*") );
          jQuery.cleanData( [ elem ] );
        }

        if ( elem.parentNode ) {
          elem.parentNode.removeChild( elem );
        }
      }
    }

    return this;
  },

  empty: function() {
    var elem,
      i = 0;

    for ( ; (elem = this[i]) != null; i++ ) {
      // Remove element nodes and prevent memory leaks
      if ( elem.nodeType === 1 ) {
        jQuery.cleanData( elem.getElementsByTagName("*") );
      }

      // Remove any remaining nodes
      while ( elem.firstChild ) {
        elem.removeChild( elem.firstChild );
      }
    }

    return this;
  },

  clone: function( dataAndEvents, deepDataAndEvents ) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    return this.map( function () {
      return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    });
  },

  html: function( value ) {
    return jQuery.access( this, function( value ) {
      var elem = this[0] || {},
        i = 0,
        l = this.length;

      if ( value === undefined ) {
        return elem.nodeType === 1 ?
          elem.innerHTML.replace( rinlinejQuery, "" ) :
          undefined;
      }

      // See if we can take a shortcut and just use innerHTML
      if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
        ( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
        ( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
        !wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

        value = value.replace( rxhtmlTag, "<$1></$2>" );

        try {
          for (; i < l; i++ ) {
            // Remove element nodes and prevent memory leaks
            elem = this[i] || {};
            if ( elem.nodeType === 1 ) {
              jQuery.cleanData( elem.getElementsByTagName( "*" ) );
              elem.innerHTML = value;
            }
          }

          elem = 0;

        // If using innerHTML throws an exception, use the fallback method
        } catch(e) {}
      }

      if ( elem ) {
        this.empty().append( value );
      }
    }, null, value, arguments.length );
  },

  replaceWith: function( value ) {
    if ( !isDisconnected( this[0] ) ) {
      // Make sure that the elements are removed from the DOM before they are inserted
      // this can help fix replacing a parent with child elements
      if ( jQuery.isFunction( value ) ) {
        return this.each(function(i) {
          var self = jQuery(this), old = self.html();
          self.replaceWith( value.call( this, i, old ) );
        });
      }

      if ( typeof value !== "string" ) {
        value = jQuery( value ).detach();
      }

      return this.each(function() {
        var next = this.nextSibling,
          parent = this.parentNode;

        jQuery( this ).remove();

        if ( next ) {
          jQuery(next).before( value );
        } else {
          jQuery(parent).append( value );
        }
      });
    }

    return this.length ?
      this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
      this;
  },

  detach: function( selector ) {
    return this.remove( selector, true );
  },

  domManip: function( args, table, callback ) {

    // Flatten any nested arrays
    args = [].concat.apply( [], args );

    var results, first, fragment, iNoClone,
      i = 0,
      value = args[0],
      scripts = [],
      l = this.length;

    // We can't cloneNode fragments that contain checked, in WebKit
    if ( !jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test( value ) ) {
      return this.each(function() {
        jQuery(this).domManip( args, table, callback );
      });
    }

    if ( jQuery.isFunction(value) ) {
      return this.each(function(i) {
        var self = jQuery(this);
        args[0] = value.call( this, i, table ? self.html() : undefined );
        self.domManip( args, table, callback );
      });
    }

    if ( this[0] ) {
      results = jQuery.buildFragment( args, this, scripts );
      fragment = results.fragment;
      first = fragment.firstChild;

      if ( fragment.childNodes.length === 1 ) {
        fragment = first;
      }

      if ( first ) {
        table = table && jQuery.nodeName( first, "tr" );

        // Use the original fragment for the last item instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).
        // Fragments from the fragment cache must always be cloned and never used in place.
        for ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {
          callback.call(
            table && jQuery.nodeName( this[i], "table" ) ?
              findOrAppend( this[i], "tbody" ) :
              this[i],
            i === iNoClone ?
              fragment :
              jQuery.clone( fragment, true, true )
          );
        }
      }

      // Fix #11809: Avoid leaking memory
      fragment = first = null;

      if ( scripts.length ) {
        jQuery.each( scripts, function( i, elem ) {
          if ( elem.src ) {
            if ( jQuery.ajax ) {
              jQuery.ajax({
                url: elem.src,
                type: "GET",
                dataType: "script",
                async: false,
                global: false,
                "throws": true
              });
            } else {
              jQuery.error("no ajax");
            }
          } else {
            jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
          }

          if ( elem.parentNode ) {
            elem.parentNode.removeChild( elem );
          }
        });
      }
    }

    return this;
  }
});

function findOrAppend( elem, tag ) {
  return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

function cloneCopyEvent( src, dest ) {

  if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
    return;
  }

  var type, i, l,
    oldData = jQuery._data( src ),
    curData = jQuery._data( dest, oldData ),
    events = oldData.events;

  if ( events ) {
    delete curData.handle;
    curData.events = {};

    for ( type in events ) {
      for ( i = 0, l = events[ type ].length; i < l; i++ ) {
        jQuery.event.add( dest, type, events[ type ][ i ] );
      }
    }
  }

  // make the cloned public data object a copy from the original
  if ( curData.data ) {
    curData.data = jQuery.extend( {}, curData.data );
  }
}

function cloneFixAttributes( src, dest ) {
  var nodeName;

  // We do not need to do anything for non-Elements
  if ( dest.nodeType !== 1 ) {
    return;
  }

  // clearAttributes removes the attributes, which we don't want,
  // but also removes the attachEvent events, which we *do* want
  if ( dest.clearAttributes ) {
    dest.clearAttributes();
  }

  // mergeAttributes, in contrast, only merges back on the
  // original attributes, not the events
  if ( dest.mergeAttributes ) {
    dest.mergeAttributes( src );
  }

  nodeName = dest.nodeName.toLowerCase();

  if ( nodeName === "object" ) {
    // IE6-10 improperly clones children of object elements using classid.
    // IE10 throws NoModificationAllowedError if parent is null, #12132.
    if ( dest.parentNode ) {
      dest.outerHTML = src.outerHTML;
    }

    // This path appears unavoidable for IE9. When cloning an object
    // element in IE9, the outerHTML strategy above is not sufficient.
    // If the src has innerHTML and the destination does not,
    // copy the src.innerHTML into the dest.innerHTML. #10324
    if ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {
      dest.innerHTML = src.innerHTML;
    }

  } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
    // IE6-8 fails to persist the checked state of a cloned checkbox
    // or radio button. Worse, IE6-7 fail to give the cloned element
    // a checked appearance if the defaultChecked value isn't also set

    dest.defaultChecked = dest.checked = src.checked;

    // IE6-7 get confused and end up setting the value of a cloned
    // checkbox/radio button to an empty string instead of "on"
    if ( dest.value !== src.value ) {
      dest.value = src.value;
    }

  // IE6-8 fails to return the selected option to the default selected
  // state when cloning options
  } else if ( nodeName === "option" ) {
    dest.selected = src.defaultSelected;

  // IE6-8 fails to set the defaultValue to the correct value when
  // cloning other types of input fields
  } else if ( nodeName === "input" || nodeName === "textarea" ) {
    dest.defaultValue = src.defaultValue;

  // IE blanks contents when cloning scripts
  } else if ( nodeName === "script" && dest.text !== src.text ) {
    dest.text = src.text;
  }

  // Event data gets referenced instead of copied if the expando
  // gets copied too
  dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, context, scripts ) {
  var fragment, cacheable, cachehit,
    first = args[ 0 ];

  // Set context from what may come in as undefined or a jQuery collection or a node
  // Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
  // also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
  context = context || document;
  context = !context.nodeType && context[0] || context;
  context = context.ownerDocument || context;

  // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
  // Cloning options loses the selected state, so don't cache them
  // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
  // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
  // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
  if ( args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
    first.charAt(0) === "<" && !rnocache.test( first ) &&
    (jQuery.support.checkClone || !rchecked.test( first )) &&
    (jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

    // Mark cacheable and look for a hit
    cacheable = true;
    fragment = jQuery.fragments[ first ];
    cachehit = fragment !== undefined;
  }

  if ( !fragment ) {
    fragment = context.createDocumentFragment();
    jQuery.clean( args, context, fragment, scripts );

    // Update the cache, but only store false
    // unless this is a second parsing of the same content
    if ( cacheable ) {
      jQuery.fragments[ first ] = cachehit && fragment;
    }
  }

  return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
  appendTo: "append",
  prependTo: "prepend",
  insertBefore: "before",
  insertAfter: "after",
  replaceAll: "replaceWith"
}, function( name, original ) {
  jQuery.fn[ name ] = function( selector ) {
    var elems,
      i = 0,
      ret = [],
      insert = jQuery( selector ),
      l = insert.length,
      parent = this.length === 1 && this[0].parentNode;

    if ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {
      insert[ original ]( this[0] );
      return this;
    } else {
      for ( ; i < l; i++ ) {
        elems = ( i > 0 ? this.clone(true) : this ).get();
        jQuery( insert[i] )[ original ]( elems );
        ret = ret.concat( elems );
      }

      return this.pushStack( ret, name, insert.selector );
    }
  };
});

function getAll( elem ) {
  if ( typeof elem.getElementsByTagName !== "undefined" ) {
    return elem.getElementsByTagName( "*" );

  } else if ( typeof elem.querySelectorAll !== "undefined" ) {
    return elem.querySelectorAll( "*" );

  } else {
    return [];
  }
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
  if ( rcheckableType.test( elem.type ) ) {
    elem.defaultChecked = elem.checked;
  }
}

jQuery.extend({
  clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    var srcElements,
      destElements,
      i,
      clone;

    if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
      clone = elem.cloneNode( true );

    // IE<=8 does not properly clone detached, unknown element nodes
    } else {
      fragmentDiv.innerHTML = elem.outerHTML;
      fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
    }

    if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
        (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
      // IE copies events bound via attachEvent when using cloneNode.
      // Calling detachEvent on the clone will also remove the events
      // from the original. In order to get around this, we use some
      // proprietary methods to clear the events. Thanks to MooTools
      // guys for this hotness.

      cloneFixAttributes( elem, clone );

      // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
      srcElements = getAll( elem );
      destElements = getAll( clone );

      // Weird iteration because IE will replace the length property
      // with an element if you are cloning the body and one of the
      // elements on the page has a name or id of "length"
      for ( i = 0; srcElements[i]; ++i ) {
        // Ensure that the destination node is not null; Fixes #9587
        if ( destElements[i] ) {
          cloneFixAttributes( srcElements[i], destElements[i] );
        }
      }
    }

    // Copy the events from the original to the clone
    if ( dataAndEvents ) {
      cloneCopyEvent( elem, clone );

      if ( deepDataAndEvents ) {
        srcElements = getAll( elem );
        destElements = getAll( clone );

        for ( i = 0; srcElements[i]; ++i ) {
          cloneCopyEvent( srcElements[i], destElements[i] );
        }
      }
    }

    srcElements = destElements = null;

    // Return the cloned set
    return clone;
  },

  clean: function( elems, context, fragment, scripts ) {
    var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
      safe = context === document && safeFragment,
      ret = [];

    // Ensure that context is a document
    if ( !context || typeof context.createDocumentFragment === "undefined" ) {
      context = document;
    }

    // Use the already-created safe fragment if context permits
    for ( i = 0; (elem = elems[i]) != null; i++ ) {
      if ( typeof elem === "number" ) {
        elem += "";
      }

      if ( !elem ) {
        continue;
      }

      // Convert html string into DOM nodes
      if ( typeof elem === "string" ) {
        if ( !rhtml.test( elem ) ) {
          elem = context.createTextNode( elem );
        } else {
          // Ensure a safe container in which to render the html
          safe = safe || createSafeFragment( context );
          div = context.createElement("div");
          safe.appendChild( div );

          // Fix "XHTML"-style tags in all browsers
          elem = elem.replace(rxhtmlTag, "<$1></$2>");

          // Go to html and back, then peel off extra wrappers
          tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
          wrap = wrapMap[ tag ] || wrapMap._default;
          depth = wrap[0];
          div.innerHTML = wrap[1] + elem + wrap[2];

          // Move to the right depth
          while ( depth-- ) {
            div = div.lastChild;
          }

          // Remove IE's autoinserted <tbody> from table fragments
          if ( !jQuery.support.tbody ) {

            // String was a <table>, *may* have spurious <tbody>
            hasBody = rtbody.test(elem);
              tbody = tag === "table" && !hasBody ?
                div.firstChild && div.firstChild.childNodes :

                // String was a bare <thead> or <tfoot>
                wrap[1] === "<table>" && !hasBody ?
                  div.childNodes :
                  [];

            for ( j = tbody.length - 1; j >= 0 ; --j ) {
              if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
                tbody[ j ].parentNode.removeChild( tbody[ j ] );
              }
            }
          }

          // IE completely kills leading whitespace when innerHTML is used
          if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
            div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
          }

          elem = div.childNodes;

          // Take out of fragment container (we need a fresh div each time)
          div.parentNode.removeChild( div );
        }
      }

      if ( elem.nodeType ) {
        ret.push( elem );
      } else {
        jQuery.merge( ret, elem );
      }
    }

    // Fix #11356: Clear elements from safeFragment
    if ( div ) {
      elem = div = safe = null;
    }

    // Reset defaultChecked for any radios and checkboxes
    // about to be appended to the DOM in IE 6/7 (#8060)
    if ( !jQuery.support.appendChecked ) {
      for ( i = 0; (elem = ret[i]) != null; i++ ) {
        if ( jQuery.nodeName( elem, "input" ) ) {
          fixDefaultChecked( elem );
        } else if ( typeof elem.getElementsByTagName !== "undefined" ) {
          jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
        }
      }
    }

    // Append elements to a provided document fragment
    if ( fragment ) {
      // Special handling of each script element
      handleScript = function( elem ) {
        // Check if we consider it executable
        if ( !elem.type || rscriptType.test( elem.type ) ) {
          // Detach the script and store it in the scripts array (if provided) or the fragment
          // Return truthy to indicate that it has been handled
          return scripts ?
            scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
            fragment.appendChild( elem );
        }
      };

      for ( i = 0; (elem = ret[i]) != null; i++ ) {
        // Check if we're done after handling an executable script
        if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
          // Append to fragment and handle embedded scripts
          fragment.appendChild( elem );
          if ( typeof elem.getElementsByTagName !== "undefined" ) {
            // handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
            jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

            // Splice the scripts into ret after their former ancestor and advance our index beyond them
            ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
            i += jsTags.length;
          }
        }
      }
    }

    return ret;
  },

  cleanData: function( elems, /* internal */ acceptData ) {
    var data, id, elem, type,
      i = 0,
      internalKey = jQuery.expando,
      cache = jQuery.cache,
      deleteExpando = jQuery.support.deleteExpando,
      special = jQuery.event.special;

    for ( ; (elem = elems[i]) != null; i++ ) {

      if ( acceptData || jQuery.acceptData( elem ) ) {

        id = elem[ internalKey ];
        data = id && cache[ id ];

        if ( data ) {
          if ( data.events ) {
            for ( type in data.events ) {
              if ( special[ type ] ) {
                jQuery.event.remove( elem, type );

              // This is a shortcut to avoid jQuery.event.remove's overhead
              } else {
                jQuery.removeEvent( elem, type, data.handle );
              }
            }
          }

          // Remove cache only if it was not already removed by jQuery.event.remove
          if ( cache[ id ] ) {

            delete cache[ id ];

            // IE does not allow us to delete expando properties from nodes,
            // nor does it have a removeAttribute function on Document nodes;
            // we must handle all of these cases
            if ( deleteExpando ) {
              delete elem[ internalKey ];

            } else if ( elem.removeAttribute ) {
              elem.removeAttribute( internalKey );

            } else {
              elem[ internalKey ] = null;
            }

            jQuery.deletedIds.push( id );
          }
        }
      }
    }
  }
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
  ua = ua.toLowerCase();

  var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
    /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
    /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
    /(msie) ([\w.]+)/.exec( ua ) ||
    ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
    [];

  return {
    browser: match[ 1 ] || "",
    version: match[ 2 ] || "0"
  };
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
  browser[ matched.browser ] = true;
  browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
  browser.webkit = true;
} else if ( browser.webkit ) {
  browser.safari = true;
}

jQuery.browser = browser;

jQuery.sub = function() {
  function jQuerySub( selector, context ) {
    return new jQuerySub.fn.init( selector, context );
  }
  jQuery.extend( true, jQuerySub, this );
  jQuerySub.superclass = this;
  jQuerySub.fn = jQuerySub.prototype = this();
  jQuerySub.fn.constructor = jQuerySub;
  jQuerySub.sub = this.sub;
  jQuerySub.fn.init = function init( selector, context ) {
    if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
      context = jQuerySub( context );
    }

    return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
  };
  jQuerySub.fn.init.prototype = jQuerySub.fn;
  var rootjQuerySub = jQuerySub(document);
  return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
  ralpha = /alpha\([^)]*\)/i,
  ropacity = /opacity=([^)]*)/,
  rposition = /^(top|right|bottom|left)$/,
  // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
  // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  rmargin = /^margin/,
  rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
  rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
  rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
  elemdisplay = {},

  cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  cssNormalTransform = {
    letterSpacing: 0,
    fontWeight: 400
  },

  cssExpand = [ "Top", "Right", "Bottom", "Left" ],
  cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],

  eventsToggle = jQuery.fn.toggle;

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

  // shortcut for names that are not vendor prefixed
  if ( name in style ) {
    return name;
  }

  // check for vendor prefixed names
  var capName = name.charAt(0).toUpperCase() + name.slice(1),
    origName = name,
    i = cssPrefixes.length;

  while ( i-- ) {
    name = cssPrefixes[ i ] + capName;
    if ( name in style ) {
      return name;
    }
  }

  return origName;
}

function isHidden( elem, el ) {
  elem = el || elem;
  return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
  var elem, display,
    values = [],
    index = 0,
    length = elements.length;

  for ( ; index < length; index++ ) {
    elem = elements[ index ];
    if ( !elem.style ) {
      continue;
    }
    values[ index ] = jQuery._data( elem, "olddisplay" );
    if ( show ) {
      // Reset the inline display of this element to learn if it is
      // being hidden by cascaded rules or not
      if ( !values[ index ] && elem.style.display === "none" ) {
        elem.style.display = "";
      }

      // Set elements which have been overridden with display: none
      // in a stylesheet to whatever the default browser style is
      // for such an element
      if ( elem.style.display === "" && isHidden( elem ) ) {
        values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
      }
    } else {
      display = curCSS( elem, "display" );

      if ( !values[ index ] && display !== "none" ) {
        jQuery._data( elem, "olddisplay", display );
      }
    }
  }

  // Set the display of most of the elements in a second loop
  // to avoid the constant reflow
  for ( index = 0; index < length; index++ ) {
    elem = elements[ index ];
    if ( !elem.style ) {
      continue;
    }
    if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
      elem.style.display = show ? values[ index ] || "" : "none";
    }
  }

  return elements;
}

jQuery.fn.extend({
  css: function( name, value ) {
    return jQuery.access( this, function( elem, name, value ) {
      return value !== undefined ?
        jQuery.style( elem, name, value ) :
        jQuery.css( elem, name );
    }, name, value, arguments.length > 1 );
  },
  show: function() {
    return showHide( this, true );
  },
  hide: function() {
    return showHide( this );
  },
  toggle: function( state, fn2 ) {
    var bool = typeof state === "boolean";

    if ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {
      return eventsToggle.apply( this, arguments );
    }

    return this.each(function() {
      if ( bool ? state : isHidden( this ) ) {
        jQuery( this ).show();
      } else {
        jQuery( this ).hide();
      }
    });
  }
});

jQuery.extend({
  // Add in style property hooks for overriding the default
  // behavior of getting and setting a style property
  cssHooks: {
    opacity: {
      get: function( elem, computed ) {
        if ( computed ) {
          // We should always get a number back from opacity
          var ret = curCSS( elem, "opacity" );
          return ret === "" ? "1" : ret;

        }
      }
    }
  },

  // Exclude the following css properties to add px
  cssNumber: {
    "fillOpacity": true,
    "fontWeight": true,
    "lineHeight": true,
    "opacity": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
  },

  // Add in properties whose names you wish to fix before
  // setting or getting the value
  cssProps: {
    // normalize float css property
    "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
  },

  // Get and set the style property on a DOM Node
  style: function( elem, name, value, extra ) {
    // Don't set styles on text and comment nodes
    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
      return;
    }

    // Make sure that we're working with the right name
    var ret, type, hooks,
      origName = jQuery.camelCase( name ),
      style = elem.style;

    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

    // gets hook for the prefixed version
    // followed by the unprefixed version
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // Check if we're setting a value
    if ( value !== undefined ) {
      type = typeof value;

      // convert relative number strings (+= or -=) to relative numbers. #7345
      if ( type === "string" && (ret = rrelNum.exec( value )) ) {
        value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
        // Fixes bug #9237
        type = "number";
      }

      // Make sure that NaN and null values aren't set. See: #7116
      if ( value == null || type === "number" && isNaN( value ) ) {
        return;
      }

      // If a number was passed in, add 'px' to the (except for certain CSS properties)
      if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
        value += "px";
      }

      // If a hook was provided, use that value, otherwise just set the specified value
      if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
        // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
        // Fixes bug #5509
        try {
          style[ name ] = value;
        } catch(e) {}
      }

    } else {
      // If a hook was provided get the non-computed value from there
      if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
        return ret;
      }

      // Otherwise just get the value from the style object
      return style[ name ];
    }
  },

  css: function( elem, name, numeric, extra ) {
    var val, num, hooks,
      origName = jQuery.camelCase( name );

    // Make sure that we're working with the right name
    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

    // gets hook for the prefixed version
    // followed by the unprefixed version
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // If a hook was provided get the computed value from there
    if ( hooks && "get" in hooks ) {
      val = hooks.get( elem, true, extra );
    }

    // Otherwise, if a way to get the computed value exists, use that
    if ( val === undefined ) {
      val = curCSS( elem, name );
    }

    //convert "normal" to computed value
    if ( val === "normal" && name in cssNormalTransform ) {
      val = cssNormalTransform[ name ];
    }

    // Return, converting to number if forced or a qualifier was provided and val looks numeric
    if ( numeric || extra !== undefined ) {
      num = parseFloat( val );
      return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
    }
    return val;
  },

  // A method for quickly swapping in/out CSS properties to get correct calculations
  swap: function( elem, options, callback ) {
    var ret, name,
      old = {};

    // Remember the old values, and insert the new ones
    for ( name in options ) {
      old[ name ] = elem.style[ name ];
      elem.style[ name ] = options[ name ];
    }

    ret = callback.call( elem );

    // Revert the old values
    for ( name in options ) {
      elem.style[ name ] = old[ name ];
    }

    return ret;
  }
});

// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
  curCSS = function( elem, name ) {
    var ret, width, minWidth, maxWidth,
      computed = window.getComputedStyle( elem, null ),
      style = elem.style;

    if ( computed ) {

      ret = computed[ name ];
      if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
        ret = jQuery.style( elem, name );
      }

      // A tribute to the "awesome hack by Dean Edwards"
      // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
      // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
      // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
      if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret;
  };
} else if ( document.documentElement.currentStyle ) {
  curCSS = function( elem, name ) {
    var left, rsLeft,
      ret = elem.currentStyle && elem.currentStyle[ name ],
      style = elem.style;

    // Avoid setting ret to empty string here
    // so we don't default to auto
    if ( ret == null && style && style[ name ] ) {
      ret = style[ name ];
    }

    // From the awesome hack by Dean Edwards
    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

    // If we're not dealing with a regular pixel number
    // but a number that has a weird ending, we need to convert it to pixels
    // but not position css attributes, as those are proportional to the parent element instead
    // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
    if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

      // Remember the original values
      left = style.left;
      rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

      // Put in the new values to get a computed value out
      if ( rsLeft ) {
        elem.runtimeStyle.left = elem.currentStyle.left;
      }
      style.left = name === "fontSize" ? "1em" : ret;
      ret = style.pixelLeft + "px";

      // Revert the changed values
      style.left = left;
      if ( rsLeft ) {
        elem.runtimeStyle.left = rsLeft;
      }
    }

    return ret === "" ? "auto" : ret;
  };
}

function setPositiveNumber( elem, value, subtract ) {
  var matches = rnumsplit.exec( value );
  return matches ?
      Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
      value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
  var i = extra === ( isBorderBox ? "border" : "content" ) ?
    // If we already have the right measurement, avoid augmentation
    4 :
    // Otherwise initialize for horizontal or vertical properties
    name === "width" ? 1 : 0,

    val = 0;

  for ( ; i < 4; i += 2 ) {
    // both box models exclude margin, so add it if we want it
    if ( extra === "margin" ) {
      // we use jQuery.css instead of curCSS here
      // because of the reliableMarginRight CSS hook!
      val += jQuery.css( elem, extra + cssExpand[ i ], true );
    }

    // From this point on we use curCSS for maximum performance (relevant in animations)
    if ( isBorderBox ) {
      // border-box includes padding, so remove it if we want content
      if ( extra === "content" ) {
        val -= parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
      }

      // at this point, extra isn't border nor margin, so remove border
      if ( extra !== "margin" ) {
        val -= parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
      }
    } else {
      // at this point, extra isn't content, so add padding
      val += parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;

      // at this point, extra isn't content nor padding, so add border
      if ( extra !== "padding" ) {
        val += parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
      }
    }
  }

  return val;
}

function getWidthOrHeight( elem, name, extra ) {

  // Start with offset property, which is equivalent to the border-box value
  var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
    valueIsBorderBox = true,
    isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box";

  // some non-html elements return undefined for offsetWidth, so check for null/undefined
  // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
  // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
  if ( val <= 0 || val == null ) {
    // Fall back to computed then uncomputed css if necessary
    val = curCSS( elem, name );
    if ( val < 0 || val == null ) {
      val = elem.style[ name ];
    }

    // Computed unit is not pixels. Stop here and return.
    if ( rnumnonpx.test(val) ) {
      return val;
    }

    // we need the check for style in case a browser which returns unreliable values
    // for getComputedStyle silently falls back to the reliable elem.style
    valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

    // Normalize "", auto, and prepare for extra
    val = parseFloat( val ) || 0;
  }

  // use the active box-sizing model to add/subtract irrelevant styles
  return ( val +
    augmentWidthOrHeight(
      elem,
      name,
      extra || ( isBorderBox ? "border" : "content" ),
      valueIsBorderBox
    )
  ) + "px";
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
  if ( elemdisplay[ nodeName ] ) {
    return elemdisplay[ nodeName ];
  }

  var elem = jQuery( "<" + nodeName + ">" ).appendTo( document.body ),
    display = elem.css("display");
  elem.remove();

  // If the simple way fails,
  // get element's real default display by attaching it to a temp iframe
  if ( display === "none" || display === "" ) {
    // Use the already-created iframe if possible
    iframe = document.body.appendChild(
      iframe || jQuery.extend( document.createElement("iframe"), {
        frameBorder: 0,
        width: 0,
        height: 0
      })
    );

    // Create a cacheable copy of the iframe document on first call.
    // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
    // document to it; WebKit & Firefox won't allow reusing the iframe document.
    if ( !iframeDoc || !iframe.createElement ) {
      iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
      iframeDoc.write("<!doctype html><html><body>");
      iframeDoc.close();
    }

    elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );

    display = curCSS( elem, "display" );
    document.body.removeChild( iframe );
  }

  // Store the correct default display
  elemdisplay[ nodeName ] = display;

  return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
  jQuery.cssHooks[ name ] = {
    get: function( elem, computed, extra ) {
      if ( computed ) {
        // certain elements can have dimension info if we invisibly show them
        // however, it must have a current display style that would benefit from this
        if ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, "display" ) ) ) {
          return jQuery.swap( elem, cssShow, function() {
            return getWidthOrHeight( elem, name, extra );
          });
        } else {
          return getWidthOrHeight( elem, name, extra );
        }
      }
    },

    set: function( elem, value, extra ) {
      return setPositiveNumber( elem, value, extra ?
        augmentWidthOrHeight(
          elem,
          name,
          extra,
          jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box"
        ) : 0
      );
    }
  };
});

if ( !jQuery.support.opacity ) {
  jQuery.cssHooks.opacity = {
    get: function( elem, computed ) {
      // IE uses filters for opacity
      return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
        ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
        computed ? "1" : "";
    },

    set: function( elem, value ) {
      var style = elem.style,
        currentStyle = elem.currentStyle,
        opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
        filter = currentStyle && currentStyle.filter || style.filter || "";

      // IE has trouble with opacity if it does not have layout
      // Force it by setting the zoom level
      style.zoom = 1;

      // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
      if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
        style.removeAttribute ) {

        // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
        // if "filter:" is present at all, clearType is disabled, we want to avoid this
        // style.removeAttribute is IE Only, but so apparently is this code path...
        style.removeAttribute( "filter" );

        // if there there is no filter style applied in a css rule, we are done
        if ( currentStyle && !currentStyle.filter ) {
          return;
        }
      }

      // otherwise, set new filter values
      style.filter = ralpha.test( filter ) ?
        filter.replace( ralpha, opacity ) :
        filter + " " + opacity;
    }
  };
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
  if ( !jQuery.support.reliableMarginRight ) {
    jQuery.cssHooks.marginRight = {
      get: function( elem, computed ) {
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        // Work around by temporarily setting element display to inline-block
        return jQuery.swap( elem, { "display": "inline-block" }, function() {
          if ( computed ) {
            return curCSS( elem, "marginRight" );
          }
        });
      }
    };
  }

  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // getComputedStyle returns percent when specified for top/left/bottom/right
  // rather than make the css module depend on the offset module, we just check for it here
  if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
    jQuery.each( [ "top", "left" ], function( i, prop ) {
      jQuery.cssHooks[ prop ] = {
        get: function( elem, computed ) {
          if ( computed ) {
            var ret = curCSS( elem, prop );
            // if curCSS returns percentage, fallback to offset
            return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + "px" : ret;
          }
        }
      };
    });
  }

});

if ( jQuery.expr && jQuery.expr.filters ) {
  jQuery.expr.filters.hidden = function( elem ) {
    return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, "display" )) === "none");
  };

  jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
  };
}

// These hooks are used by animate to expand properties
jQuery.each({
  margin: "",
  padding: "",
  border: "Width"
}, function( prefix, suffix ) {
  jQuery.cssHooks[ prefix + suffix ] = {
    expand: function( value ) {
      var i,

        // assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [ value ],
        expanded = {};

      for ( i = 0; i < 4; i++ ) {
        expanded[ prefix + cssExpand[ i ] + suffix ] =
          parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
      }

      return expanded;
    }
  };

  if ( !rmargin.test( prefix ) ) {
    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  }
});
var r20 = /%20/g,
  rbracket = /\[\]$/,
  rCRLF = /\r?\n/g,
  rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
  rselectTextarea = /^(?:select|textarea)/i;

jQuery.fn.extend({
  serialize: function() {
    return jQuery.param( this.serializeArray() );
  },
  serializeArray: function() {
    return this.map(function(){
      return this.elements ? jQuery.makeArray( this.elements ) : this;
    })
    .filter(function(){
      return this.name && !this.disabled &&
        ( this.checked || rselectTextarea.test( this.nodeName ) ||
          rinput.test( this.type ) );
    })
    .map(function( i, elem ){
      var val = jQuery( this ).val();

      return val == null ?
        null :
        jQuery.isArray( val ) ?
          jQuery.map( val, function( val, i ){
            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
          }) :
          { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    }).get();
  }
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
  var prefix,
    s = [],
    add = function( key, value ) {
      // If value is a function, invoke it and return its value
      value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
      s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
    };

  // Set traditional to true for jQuery <= 1.3.2 behavior.
  if ( traditional === undefined ) {
    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
  }

  // If an array was passed in, assume that it is an array of form elements.
  if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
    // Serialize the form elements
    jQuery.each( a, function() {
      add( this.name, this.value );
    });

  } else {
    // If traditional, encode the "old" way (the way 1.3.2 or older
    // did it), otherwise encode params recursively.
    for ( prefix in a ) {
      buildParams( prefix, a[ prefix ], traditional, add );
    }
  }

  // Return the resulting serialization
  return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
  var name;

  if ( jQuery.isArray( obj ) ) {
    // Serialize array item.
    jQuery.each( obj, function( i, v ) {
      if ( traditional || rbracket.test( prefix ) ) {
        // Treat each array item as a scalar.
        add( prefix, v );

      } else {
        // If array item is non-scalar (array or object), encode its
        // numeric index to resolve deserialization ambiguity issues.
        // Note that rack (as of 1.0.0) can't currently deserialize
        // nested arrays properly, and attempting to do so may cause
        // a server error. Possible fixes are to modify rack's
        // deserialization algorithm or to provide an option or flag
        // to force array serialization to be shallow.
        buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
      }
    });

  } else if ( !traditional && jQuery.type( obj ) === "object" ) {
    // Serialize object item.
    for ( name in obj ) {
      buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    }

  } else {
    // Serialize scalar item.
    add( prefix, obj );
  }
}
var
  // Document location
  ajaxLocParts,
  ajaxLocation,

  rhash = /#.*$/,
  rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
  // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
  rnoContent = /^(?:GET|HEAD)$/,
  rprotocol = /^\/\//,
  rquery = /\?/,
  rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
  rts = /([?&])_=[^&]*/,
  rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

  // Keep a copy of the old load method
  _load = jQuery.fn.load,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},

  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
  ajaxLocation = location.href;
} catch( e ) {
  // Use the href attribute of an A element
  // since IE will modify it given document.location
  ajaxLocation = document.createElement( "a" );
  ajaxLocation.href = "";
  ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

  // dataTypeExpression is optional and defaults to "*"
  return function( dataTypeExpression, func ) {

    if ( typeof dataTypeExpression !== "string" ) {
      func = dataTypeExpression;
      dataTypeExpression = "*";
    }

    var dataType, list, placeBefore,
      dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
      i = 0,
      length = dataTypes.length;

    if ( jQuery.isFunction( func ) ) {
      // For each dataType in the dataTypeExpression
      for ( ; i < length; i++ ) {
        dataType = dataTypes[ i ];
        // We control if we're asked to add before
        // any existing element
        placeBefore = /^\+/.test( dataType );
        if ( placeBefore ) {
          dataType = dataType.substr( 1 ) || "*";
        }
        list = structure[ dataType ] = structure[ dataType ] || [];
        // then we add to the structure accordingly
        list[ placeBefore ? "unshift" : "push" ]( func );
      }
    }
  };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
    dataType /* internal */, inspected /* internal */ ) {

  dataType = dataType || options.dataTypes[ 0 ];
  inspected = inspected || {};

  inspected[ dataType ] = true;

  var selection,
    list = structure[ dataType ],
    i = 0,
    length = list ? list.length : 0,
    executeOnly = ( structure === prefilters );

  for ( ; i < length && ( executeOnly || !selection ); i++ ) {
    selection = list[ i ]( options, originalOptions, jqXHR );
    // If we got redirected to another dataType
    // we try there if executing only and not done already
    if ( typeof selection === "string" ) {
      if ( !executeOnly || inspected[ selection ] ) {
        selection = undefined;
      } else {
        options.dataTypes.unshift( selection );
        selection = inspectPrefiltersOrTransports(
            structure, options, originalOptions, jqXHR, selection, inspected );
      }
    }
  }
  // If we're only executing or nothing was selected
  // we try the catchall dataType if not done already
  if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
    selection = inspectPrefiltersOrTransports(
        structure, options, originalOptions, jqXHR, "*", inspected );
  }
  // unnecessary when only executing (prefilters)
  // but it'll be ignored by the caller in that case
  return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
  var key, deep,
    flatOptions = jQuery.ajaxSettings.flatOptions || {};
  for ( key in src ) {
    if ( src[ key ] !== undefined ) {
      ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
    }
  }
  if ( deep ) {
    jQuery.extend( true, target, deep );
  }
}

jQuery.fn.load = function( url, params, callback ) {
  if ( typeof url !== "string" && _load ) {
    return _load.apply( this, arguments );
  }

  // Don't do a request if no elements are being requested
  if ( !this.length ) {
    return this;
  }

  var selector, type, response,
    self = this,
    off = url.indexOf(" ");

  if ( off >= 0 ) {
    selector = url.slice( off, url.length );
    url = url.slice( 0, off );
  }

  // If it's a function
  if ( jQuery.isFunction( params ) ) {

    // We assume that it's the callback
    callback = params;
    params = undefined;

  // Otherwise, build a param string
  } else if ( params && typeof params === "object" ) {
    type = "POST";
  }

  // Request the remote document
  jQuery.ajax({
    url: url,

    // if "type" variable is undefined, then "GET" method will be used
    type: type,
    dataType: "html",
    data: params,
    complete: function( jqXHR, status ) {
      if ( callback ) {
        self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
      }
    }
  }).done(function( responseText ) {

    // Save response for use in complete callback
    response = arguments;

    // See if a selector was specified
    self.html( selector ?

      // Create a dummy div to hold the results
      jQuery("<div>")

        // inject the contents of the document in, removing the scripts
        // to avoid any 'Permission Denied' errors in IE
        .append( responseText.replace( rscript, "" ) )

        // Locate the specified elements
        .find( selector ) :

      // If not, just inject the full result
      responseText );

  });

  return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
  jQuery.fn[ o ] = function( f ){
    return this.on( o, f );
  };
});

jQuery.each( [ "get", "post" ], function( i, method ) {
  jQuery[ method ] = function( url, data, callback, type ) {
    // shift arguments if data argument was omitted
    if ( jQuery.isFunction( data ) ) {
      type = type || callback;
      callback = data;
      data = undefined;
    }

    return jQuery.ajax({
      type: method,
      url: url,
      data: data,
      success: callback,
      dataType: type
    });
  };
});

jQuery.extend({

  getScript: function( url, callback ) {
    return jQuery.get( url, undefined, callback, "script" );
  },

  getJSON: function( url, data, callback ) {
    return jQuery.get( url, data, callback, "json" );
  },

  // Creates a full fledged settings object into target
  // with both ajaxSettings and settings fields.
  // If target is omitted, writes into ajaxSettings.
  ajaxSetup: function( target, settings ) {
    if ( settings ) {
      // Building a settings object
      ajaxExtend( target, jQuery.ajaxSettings );
    } else {
      // Extending ajaxSettings
      settings = target;
      target = jQuery.ajaxSettings;
    }
    ajaxExtend( target, settings );
    return target;
  },

  ajaxSettings: {
    url: ajaxLocation,
    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
    global: true,
    type: "GET",
    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
    processData: true,
    async: true,
    /*
    timeout: 0,
    data: null,
    dataType: null,
    username: null,
    password: null,
    cache: null,
    throws: false,
    traditional: false,
    headers: {},
    */

    accepts: {
      xml: "application/xml, text/xml",
      html: "text/html",
      text: "text/plain",
      json: "application/json, text/javascript",
      "*": allTypes
    },

    contents: {
      xml: /xml/,
      html: /html/,
      json: /json/
    },

    responseFields: {
      xml: "responseXML",
      text: "responseText"
    },

    // List of data converters
    // 1) key format is "source_type destination_type" (a single space in-between)
    // 2) the catchall symbol "*" can be used for source_type
    converters: {

      // Convert anything to text
      "* text": window.String,

      // Text to html (true = no transformation)
      "text html": true,

      // Evaluate text as a json expression
      "text json": jQuery.parseJSON,

      // Parse text as xml
      "text xml": jQuery.parseXML
    },

    // For options that shouldn't be deep extended:
    // you can add your own custom options here if
    // and when you create one that shouldn't be
    // deep extended (see ajaxExtend)
    flatOptions: {
      context: true,
      url: true
    }
  },

  ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  ajaxTransport: addToPrefiltersOrTransports( transports ),

  // Main method
  ajax: function( url, options ) {

    // If url is an object, simulate pre-1.5 signature
    if ( typeof url === "object" ) {
      options = url;
      url = undefined;
    }

    // Force options to be an object
    options = options || {};

    var // ifModified key
      ifModifiedKey,
      // Response headers
      responseHeadersString,
      responseHeaders,
      // transport
      transport,
      // timeout handle
      timeoutTimer,
      // Cross-domain detection vars
      parts,
      // To know if global events are to be dispatched
      fireGlobals,
      // Loop variable
      i,
      // Create the final options object
      s = jQuery.ajaxSetup( {}, options ),
      // Callbacks context
      callbackContext = s.context || s,
      // Context for global events
      // It's the callbackContext if one was provided in the options
      // and if it's a DOM node or a jQuery collection
      globalEventContext = callbackContext !== s &&
        ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
            jQuery( callbackContext ) : jQuery.event,
      // Deferreds
      deferred = jQuery.Deferred(),
      completeDeferred = jQuery.Callbacks( "once memory" ),
      // Status-dependent callbacks
      statusCode = s.statusCode || {},
      // Headers (they are sent all at once)
      requestHeaders = {},
      requestHeadersNames = {},
      // The jqXHR state
      state = 0,
      // Default abort message
      strAbort = "canceled",
      // Fake xhr
      jqXHR = {

        readyState: 0,

        // Caches the header
        setRequestHeader: function( name, value ) {
          if ( !state ) {
            var lname = name.toLowerCase();
            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
            requestHeaders[ name ] = value;
          }
          return this;
        },

        // Raw string
        getAllResponseHeaders: function() {
          return state === 2 ? responseHeadersString : null;
        },

        // Builds headers hashtable if needed
        getResponseHeader: function( key ) {
          var match;
          if ( state === 2 ) {
            if ( !responseHeaders ) {
              responseHeaders = {};
              while( ( match = rheaders.exec( responseHeadersString ) ) ) {
                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
              }
            }
            match = responseHeaders[ key.toLowerCase() ];
          }
          return match === undefined ? null : match;
        },

        // Overrides response content-type header
        overrideMimeType: function( type ) {
          if ( !state ) {
            s.mimeType = type;
          }
          return this;
        },

        // Cancel the request
        abort: function( statusText ) {
          statusText = statusText || strAbort;
          if ( transport ) {
            transport.abort( statusText );
          }
          done( 0, statusText );
          return this;
        }
      };

    // Callback for when everything is done
    // It is defined here because jslint complains if it is declared
    // at the end of the function (which would be more logical and readable)
    function done( status, nativeStatusText, responses, headers ) {
      var isSuccess, success, error, response, modified,
        statusText = nativeStatusText;

      // Called once
      if ( state === 2 ) {
        return;
      }

      // State is "done" now
      state = 2;

      // Clear timeout if it exists
      if ( timeoutTimer ) {
        clearTimeout( timeoutTimer );
      }

      // Dereference transport for early garbage collection
      // (no matter how long the jqXHR object will be used)
      transport = undefined;

      // Cache response headers
      responseHeadersString = headers || "";

      // Set readyState
      jqXHR.readyState = status > 0 ? 4 : 0;

      // Get response data
      if ( responses ) {
        response = ajaxHandleResponses( s, jqXHR, responses );
      }

      // If successful, handle type chaining
      if ( status >= 200 && status < 300 || status === 304 ) {

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {

          modified = jqXHR.getResponseHeader("Last-Modified");
          if ( modified ) {
            jQuery.lastModified[ ifModifiedKey ] = modified;
          }
          modified = jqXHR.getResponseHeader("Etag");
          if ( modified ) {
            jQuery.etag[ ifModifiedKey ] = modified;
          }
        }

        // If not modified
        if ( status === 304 ) {

          statusText = "notmodified";
          isSuccess = true;

        // If we have data
        } else {

          isSuccess = ajaxConvert( s, response );
          statusText = isSuccess.state;
          success = isSuccess.data;
          error = isSuccess.error;
          isSuccess = !error;
        }
      } else {
        // We extract error from statusText
        // then normalize statusText and status for non-aborts
        error = statusText;
        if ( !statusText || status ) {
          statusText = "error";
          if ( status < 0 ) {
            status = 0;
          }
        }
      }

      // Set data for the fake xhr object
      jqXHR.status = status;
      jqXHR.statusText = ( nativeStatusText || statusText ) + "";

      // Success/Error
      if ( isSuccess ) {
        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
      } else {
        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
      }

      // Status-dependent callbacks
      jqXHR.statusCode( statusCode );
      statusCode = undefined;

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
            [ jqXHR, s, isSuccess ? success : error ] );
      }

      // Complete
      completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
        // Handle the global AJAX counter
        if ( !( --jQuery.active ) ) {
          jQuery.event.trigger( "ajaxStop" );
        }
      }
    }

    // Attach deferreds
    deferred.promise( jqXHR );
    jqXHR.success = jqXHR.done;
    jqXHR.error = jqXHR.fail;
    jqXHR.complete = completeDeferred.add;

    // Status-dependent callbacks
    jqXHR.statusCode = function( map ) {
      if ( map ) {
        var tmp;
        if ( state < 2 ) {
          for ( tmp in map ) {
            statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
          }
        } else {
          tmp = map[ jqXHR.status ];
          jqXHR.always( tmp );
        }
      }
      return this;
    };

    // Remove hash character (#7531: and string promotion)
    // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
    // We also use the url parameter if available
    s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

    // Extract dataTypes list
    s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

    // A cross-domain request is in order when we have a protocol:host:port mismatch
    if ( s.crossDomain == null ) {
      parts = rurl.exec( s.url.toLowerCase() ) || false;
      s.crossDomain = parts && ( parts.join(":") + ( parts[ 3 ] ? "" : parts[ 1 ] === "http:" ? 80 : 443 ) ) !==
        ( ajaxLocParts.join(":") + ( ajaxLocParts[ 3 ] ? "" : ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) );
    }

    // Convert data if not already a string
    if ( s.data && s.processData && typeof s.data !== "string" ) {
      s.data = jQuery.param( s.data, s.traditional );
    }

    // Apply prefilters
    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

    // If request was aborted inside a prefilter, stop there
    if ( state === 2 ) {
      return jqXHR;
    }

    // We can fire global events as of now if asked to
    fireGlobals = s.global;

    // Uppercase the type
    s.type = s.type.toUpperCase();

    // Determine if request has content
    s.hasContent = !rnoContent.test( s.type );

    // Watch for a new set of requests
    if ( fireGlobals && jQuery.active++ === 0 ) {
      jQuery.event.trigger( "ajaxStart" );
    }

    // More options handling for requests with no content
    if ( !s.hasContent ) {

      // If data is available, append data to url
      if ( s.data ) {
        s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
        // #9682: remove data so that it's not used in an eventual retry
        delete s.data;
      }

      // Get ifModifiedKey before adding the anti-cache parameter
      ifModifiedKey = s.url;

      // Add anti-cache in url if needed
      if ( s.cache === false ) {

        var ts = jQuery.now(),
          // try replacing _= if it is there
          ret = s.url.replace( rts, "$1_=" + ts );

        // if nothing was replaced, add timestamp to the end
        s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
      }
    }

    // Set the correct header, if data is being sent
    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
      jqXHR.setRequestHeader( "Content-Type", s.contentType );
    }

    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    if ( s.ifModified ) {
      ifModifiedKey = ifModifiedKey || s.url;
      if ( jQuery.lastModified[ ifModifiedKey ] ) {
        jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
      }
      if ( jQuery.etag[ ifModifiedKey ] ) {
        jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
      }
    }

    // Set the Accepts header for the server, depending on the dataType
    jqXHR.setRequestHeader(
      "Accept",
      s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
        s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
        s.accepts[ "*" ]
    );

    // Check for headers option
    for ( i in s.headers ) {
      jqXHR.setRequestHeader( i, s.headers[ i ] );
    }

    // Allow custom headers/mimetypes and early abort
    if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
        // Abort if not done already and return
        return jqXHR.abort();

    }

    // aborting is no longer a cancellation
    strAbort = "abort";

    // Install callbacks on deferreds
    for ( i in { success: 1, error: 1, complete: 1 } ) {
      jqXHR[ i ]( s[ i ] );
    }

    // Get transport
    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

    // If no transport, we auto-abort
    if ( !transport ) {
      done( -1, "No Transport" );
    } else {
      jqXHR.readyState = 1;
      // Send global event
      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
      }
      // Timeout
      if ( s.async && s.timeout > 0 ) {
        timeoutTimer = setTimeout( function(){
          jqXHR.abort( "timeout" );
        }, s.timeout );
      }

      try {
        state = 1;
        transport.send( requestHeaders, done );
      } catch (e) {
        // Propagate exception as error if not done
        if ( state < 2 ) {
          done( -1, e );
        // Simply rethrow otherwise
        } else {
          throw e;
        }
      }
    }

    return jqXHR;
  },

  // Counter for holding the number of active queries
  active: 0,

  // Last-Modified header cache for next request
  lastModified: {},
  etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

  var ct, type, finalDataType, firstDataType,
    contents = s.contents,
    dataTypes = s.dataTypes,
    responseFields = s.responseFields;

  // Fill responseXXX fields
  for ( type in responseFields ) {
    if ( type in responses ) {
      jqXHR[ responseFields[type] ] = responses[ type ];
    }
  }

  // Remove auto dataType and get content-type in the process
  while( dataTypes[ 0 ] === "*" ) {
    dataTypes.shift();
    if ( ct === undefined ) {
      ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
    }
  }

  // Check if we're dealing with a known content-type
  if ( ct ) {
    for ( type in contents ) {
      if ( contents[ type ] && contents[ type ].test( ct ) ) {
        dataTypes.unshift( type );
        break;
      }
    }
  }

  // Check to see if we have a response for the expected dataType
  if ( dataTypes[ 0 ] in responses ) {
    finalDataType = dataTypes[ 0 ];
  } else {
    // Try convertible dataTypes
    for ( type in responses ) {
      if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
        finalDataType = type;
        break;
      }
      if ( !firstDataType ) {
        firstDataType = type;
      }
    }
    // Or just use first one
    finalDataType = finalDataType || firstDataType;
  }

  // If we found a dataType
  // We add the dataType to the list if needed
  // and return the corresponding response
  if ( finalDataType ) {
    if ( finalDataType !== dataTypes[ 0 ] ) {
      dataTypes.unshift( finalDataType );
    }
    return responses[ finalDataType ];
  }
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

  var conv, conv2, current, tmp,
    // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(),
    prev = dataTypes[ 0 ],
    converters = {},
    i = 0;

  // Apply the dataFilter if provided
  if ( s.dataFilter ) {
    response = s.dataFilter( response, s.dataType );
  }

  // Create converters map with lowercased keys
  if ( dataTypes[ 1 ] ) {
    for ( conv in s.converters ) {
      converters[ conv.toLowerCase() ] = s.converters[ conv ];
    }
  }

  // Convert to each sequential dataType, tolerating list modification
  for ( ; (current = dataTypes[++i]); ) {

    // There's only work to do if current dataType is non-auto
    if ( current !== "*" ) {

      // Convert response if prev dataType is non-auto and differs from current
      if ( prev !== "*" && prev !== current ) {

        // Seek a direct converter
        conv = converters[ prev + " " + current ] || converters[ "* " + current ];

        // If none found, seek a pair
        if ( !conv ) {
          for ( conv2 in converters ) {

            // If conv2 outputs current
            tmp = conv2.split(" ");
            if ( tmp[ 1 ] === current ) {

              // If prev can be converted to accepted input
              conv = converters[ prev + " " + tmp[ 0 ] ] ||
                converters[ "* " + tmp[ 0 ] ];
              if ( conv ) {
                // Condense equivalence converters
                if ( conv === true ) {
                  conv = converters[ conv2 ];

                // Otherwise, insert the intermediate dataType
                } else if ( converters[ conv2 ] !== true ) {
                  current = tmp[ 0 ];
                  dataTypes.splice( i--, 0, current );
                }

                break;
              }
            }
          }
        }

        // Apply converter (if not an equivalence)
        if ( conv !== true ) {

          // Unless errors are allowed to bubble, catch and return them
          if ( conv && s["throws"] ) {
            response = conv( response );
          } else {
            try {
              response = conv( response );
            } catch ( e ) {
              return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
            }
          }
        }
      }

      // Update prev for next iteration
      prev = current;
    }
  }

  return { state: "success", data: response };
}
var oldCallbacks = [],
  rquestion = /\?/,
  rjsonp = /(=)\?(?=&|$)|\?\?/,
  nonce = jQuery.now();

// Default jsonp settings
jQuery.ajaxSetup({
  jsonp: "callback",
  jsonpCallback: function() {
    var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
    this[ callback ] = true;
    return callback;
  }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  var callbackName, overwritten, responseContainer,
    data = s.data,
    url = s.url,
    hasCallback = s.jsonp !== false,
    replaceInUrl = hasCallback && rjsonp.test( url ),
    replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
      !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &&
      rjsonp.test( data );

  // Handle iff the expected data type is "jsonp" or we have a parameter to set
  if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

    // Get callback name, remembering preexisting value associated with it
    callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
      s.jsonpCallback() :
      s.jsonpCallback;
    overwritten = window[ callbackName ];

    // Insert callback into url or form data
    if ( replaceInUrl ) {
      s.url = url.replace( rjsonp, "$1" + callbackName );
    } else if ( replaceInData ) {
      s.data = data.replace( rjsonp, "$1" + callbackName );
    } else if ( hasCallback ) {
      s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
    }

    // Use data converter to retrieve json after script execution
    s.converters["script json"] = function() {
      if ( !responseContainer ) {
        jQuery.error( callbackName + " was not called" );
      }
      return responseContainer[ 0 ];
    };

    // force json dataType
    s.dataTypes[ 0 ] = "json";

    // Install callback
    window[ callbackName ] = function() {
      responseContainer = arguments;
    };

    // Clean-up function (fires after converters)
    jqXHR.always(function() {
      // Restore preexisting value
      window[ callbackName ] = overwritten;

      // Save back as free
      if ( s[ callbackName ] ) {
        // make sure that re-using the options doesn't screw things around
        s.jsonpCallback = originalSettings.jsonpCallback;

        // save the callback name for future use
        oldCallbacks.push( callbackName );
      }

      // Call if it was a function and we have a response
      if ( responseContainer && jQuery.isFunction( overwritten ) ) {
        overwritten( responseContainer[ 0 ] );
      }

      responseContainer = overwritten = undefined;
    });

    // Delegate to script
    return "script";
  }
});
// Install script dataType
jQuery.ajaxSetup({
  accepts: {
    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
  },
  contents: {
    script: /javascript|ecmascript/
  },
  converters: {
    "text script": function( text ) {
      jQuery.globalEval( text );
      return text;
    }
  }
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
  if ( s.cache === undefined ) {
    s.cache = false;
  }
  if ( s.crossDomain ) {
    s.type = "GET";
    s.global = false;
  }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

  // This transport only deals with cross domain requests
  if ( s.crossDomain ) {

    var script,
      head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

    return {

      send: function( _, callback ) {

        script = document.createElement( "script" );

        script.async = "async";

        if ( s.scriptCharset ) {
          script.charset = s.scriptCharset;
        }

        script.src = s.url;

        // Attach handlers for all browsers
        script.onload = script.onreadystatechange = function( _, isAbort ) {

          if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

            // Handle memory leak in IE
            script.onload = script.onreadystatechange = null;

            // Remove the script
            if ( head && script.parentNode ) {
              head.removeChild( script );
            }

            // Dereference the script
            script = undefined;

            // Callback if not abort
            if ( !isAbort ) {
              callback( 200, "success" );
            }
          }
        };
        // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
        // This arises when a base node is used (#2709 and #4378).
        head.insertBefore( script, head.firstChild );
      },

      abort: function() {
        if ( script ) {
          script.onload( 0, 1 );
        }
      }
    };
  }
});
var xhrCallbacks,
  // #5280: Internet Explorer will keep connections alive if we don't abort on unload
  xhrOnUnloadAbort = window.ActiveXObject ? function() {
    // Abort all pending requests
    for ( var key in xhrCallbacks ) {
      xhrCallbacks[ key ]( 0, 1 );
    }
  } : false,
  xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
  try {
    return new window.XMLHttpRequest();
  } catch( e ) {}
}

function createActiveXHR() {
  try {
    return new window.ActiveXObject( "Microsoft.XMLHTTP" );
  } catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
  /* Microsoft failed to properly
   * implement the XMLHttpRequest in IE7 (can't request local files),
   * so we use the ActiveXObject when it is available
   * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
   * we need a fallback.
   */
  function() {
    return !this.isLocal && createStandardXHR() || createActiveXHR();
  } :
  // For all other browsers, use the standard XMLHttpRequest object
  createStandardXHR;

// Determine support properties
(function( xhr ) {
  jQuery.extend( jQuery.support, {
    ajax: !!xhr,
    cors: !!xhr && ( "withCredentials" in xhr )
  });
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

  jQuery.ajaxTransport(function( s ) {
    // Cross domain only allowed if supported through XMLHttpRequest
    if ( !s.crossDomain || jQuery.support.cors ) {

      var callback;

      return {
        send: function( headers, complete ) {

          // Get a new xhr
          var handle, i,
            xhr = s.xhr();

          // Open the socket
          // Passing null username, generates a login popup on Opera (#2865)
          if ( s.username ) {
            xhr.open( s.type, s.url, s.async, s.username, s.password );
          } else {
            xhr.open( s.type, s.url, s.async );
          }

          // Apply custom fields if provided
          if ( s.xhrFields ) {
            for ( i in s.xhrFields ) {
              xhr[ i ] = s.xhrFields[ i ];
            }
          }

          // Override mime type if needed
          if ( s.mimeType && xhr.overrideMimeType ) {
            xhr.overrideMimeType( s.mimeType );
          }

          // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.
          if ( !s.crossDomain && !headers["X-Requested-With"] ) {
            headers[ "X-Requested-With" ] = "XMLHttpRequest";
          }

          // Need an extra try/catch for cross domain requests in Firefox 3
          try {
            for ( i in headers ) {
              xhr.setRequestHeader( i, headers[ i ] );
            }
          } catch( _ ) {}

          // Do send the request
          // This may raise an exception which is actually
          // handled in jQuery.ajax (so no try/catch here)
          xhr.send( ( s.hasContent && s.data ) || null );

          // Listener
          callback = function( _, isAbort ) {

            var status,
              statusText,
              responseHeaders,
              responses,
              xml;

            // Firefox throws exceptions when accessing properties
            // of an xhr when a network error occurred
            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
            try {

              // Was never called and is aborted or complete
              if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

                // Only called once
                callback = undefined;

                // Do not keep as active anymore
                if ( handle ) {
                  xhr.onreadystatechange = jQuery.noop;
                  if ( xhrOnUnloadAbort ) {
                    delete xhrCallbacks[ handle ];
                  }
                }

                // If it's an abort
                if ( isAbort ) {
                  // Abort it manually if needed
                  if ( xhr.readyState !== 4 ) {
                    xhr.abort();
                  }
                } else {
                  status = xhr.status;
                  responseHeaders = xhr.getAllResponseHeaders();
                  responses = {};
                  xml = xhr.responseXML;

                  // Construct response list
                  if ( xml && xml.documentElement /* #4958 */ ) {
                    responses.xml = xml;
                  }

                  // When requesting binary data, IE6-9 will throw an exception
                  // on any attempt to access responseText (#11426)
                  try {
                    responses.text = xhr.responseText;
                  } catch( _ ) {
                  }

                  // Firefox throws an exception when accessing
                  // statusText for faulty cross-domain requests
                  try {
                    statusText = xhr.statusText;
                  } catch( e ) {
                    // We normalize with Webkit giving an empty statusText
                    statusText = "";
                  }

                  // Filter status for non standard behaviors

                  // If the request is local and we have data: assume a success
                  // (success with no data won't get notified, that's the best we
                  // can do given current implementations)
                  if ( !status && s.isLocal && !s.crossDomain ) {
                    status = responses.text ? 200 : 404;
                  // IE - #1450: sometimes returns 1223 when it should be 204
                  } else if ( status === 1223 ) {
                    status = 204;
                  }
                }
              }
            } catch( firefoxAccessException ) {
              if ( !isAbort ) {
                complete( -1, firefoxAccessException );
              }
            }

            // Call complete if needed
            if ( responses ) {
              complete( status, statusText, responses, responseHeaders );
            }
          };

          if ( !s.async ) {
            // if we're in sync mode we fire the callback
            callback();
          } else if ( xhr.readyState === 4 ) {
            // (IE6 & IE7) if it's in cache and has been
            // retrieved directly we need to fire the callback
            setTimeout( callback, 0 );
          } else {
            handle = ++xhrId;
            if ( xhrOnUnloadAbort ) {
              // Create the active xhrs callbacks list if needed
              // and attach the unload handler
              if ( !xhrCallbacks ) {
                xhrCallbacks = {};
                jQuery( window ).unload( xhrOnUnloadAbort );
              }
              // Add to list of active xhrs callbacks
              xhrCallbacks[ handle ] = callback;
            }
            xhr.onreadystatechange = callback;
          }
        },

        abort: function() {
          if ( callback ) {
            callback(0,1);
          }
        }
      };
    }
  });
}
var fxNow, timerId,
  rfxtypes = /^(?:toggle|show|hide)$/,
  rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
  rrun = /queueHooks$/,
  animationPrefilters = [ defaultPrefilter ],
  tweeners = {
    "*": [function( prop, value ) {
      var end, unit,
        tween = this.createTween( prop, value ),
        parts = rfxnum.exec( value ),
        target = tween.cur(),
        start = +target || 0,
        scale = 1,
        maxIterations = 20;

      if ( parts ) {
        end = +parts[2];
        unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

        // We need to compute starting value
        if ( unit !== "px" && start ) {
          // Iteratively approximate from a nonzero starting point
          // Prefer the current property, because this process will be trivial if it uses the same units
          // Fallback to end or a simple constant
          start = jQuery.css( tween.elem, prop, true ) || end || 1;

          do {
            // If previous iteration zeroed out, double until we get *something*
            // Use a string for doubling factor so we don't accidentally see scale as unchanged below
            scale = scale || ".5";

            // Adjust and apply
            start = start / scale;
            jQuery.style( tween.elem, prop, start + unit );

          // Update scale, tolerating zero or NaN from tween.cur()
          // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
          } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
        }

        tween.unit = unit;
        tween.start = start;
        // If a +=/-= token was provided, we're doing a relative animation
        tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
      }
      return tween;
    }]
  };

// Animations created synchronously will run synchronously
function createFxNow() {
  setTimeout(function() {
    fxNow = undefined;
  }, 0 );
  return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
  jQuery.each( props, function( prop, value ) {
    var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
      index = 0,
      length = collection.length;
    for ( ; index < length; index++ ) {
      if ( collection[ index ].call( animation, prop, value ) ) {

        // we're done with this property
        return;
      }
    }
  });
}

function Animation( elem, properties, options ) {
  var result,
    index = 0,
    tweenerIndex = 0,
    length = animationPrefilters.length,
    deferred = jQuery.Deferred().always( function() {
      // don't match elem in the :animated selector
      delete tick.elem;
    }),
    tick = function() {
      var currentTime = fxNow || createFxNow(),
        remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
        percent = 1 - ( remaining / animation.duration || 0 ),
        index = 0,
        length = animation.tweens.length;

      for ( ; index < length ; index++ ) {
        animation.tweens[ index ].run( percent );
      }

      deferred.notifyWith( elem, [ animation, percent, remaining ]);

      if ( percent < 1 && length ) {
        return remaining;
      } else {
        deferred.resolveWith( elem, [ animation ] );
        return false;
      }
    },
    animation = deferred.promise({
      elem: elem,
      props: jQuery.extend( {}, properties ),
      opts: jQuery.extend( true, { specialEasing: {} }, options ),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function( prop, end, easing ) {
        var tween = jQuery.Tween( elem, animation.opts, prop, end,
            animation.opts.specialEasing[ prop ] || animation.opts.easing );
        animation.tweens.push( tween );
        return tween;
      },
      stop: function( gotoEnd ) {
        var index = 0,
          // if we are going to the end, we want to run all the tweens
          // otherwise we skip this part
          length = gotoEnd ? animation.tweens.length : 0;

        for ( ; index < length ; index++ ) {
          animation.tweens[ index ].run( 1 );
        }

        // resolve when we played the last frame
        // otherwise, reject
        if ( gotoEnd ) {
          deferred.resolveWith( elem, [ animation, gotoEnd ] );
        } else {
          deferred.rejectWith( elem, [ animation, gotoEnd ] );
        }
        return this;
      }
    }),
    props = animation.props;

  propFilter( props, animation.opts.specialEasing );

  for ( ; index < length ; index++ ) {
    result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
    if ( result ) {
      return result;
    }
  }

  createTweens( animation, props );

  if ( jQuery.isFunction( animation.opts.start ) ) {
    animation.opts.start.call( elem, animation );
  }

  jQuery.fx.timer(
    jQuery.extend( tick, {
      anim: animation,
      queue: animation.opts.queue,
      elem: elem
    })
  );

  // attach callbacks from options
  return animation.progress( animation.opts.progress )
    .done( animation.opts.done, animation.opts.complete )
    .fail( animation.opts.fail )
    .always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
  var index, name, easing, value, hooks;

  // camelCase, specialEasing and expand cssHook pass
  for ( index in props ) {
    name = jQuery.camelCase( index );
    easing = specialEasing[ name ];
    value = props[ index ];
    if ( jQuery.isArray( value ) ) {
      easing = value[ 1 ];
      value = props[ index ] = value[ 0 ];
    }

    if ( index !== name ) {
      props[ name ] = value;
      delete props[ index ];
    }

    hooks = jQuery.cssHooks[ name ];
    if ( hooks && "expand" in hooks ) {
      value = hooks.expand( value );
      delete props[ name ];

      // not quite $.extend, this wont overwrite keys already present.
      // also - reusing 'index' from above because we have the correct "name"
      for ( index in value ) {
        if ( !( index in props ) ) {
          props[ index ] = value[ index ];
          specialEasing[ index ] = easing;
        }
      }
    } else {
      specialEasing[ name ] = easing;
    }
  }
}

jQuery.Animation = jQuery.extend( Animation, {

  tweener: function( props, callback ) {
    if ( jQuery.isFunction( props ) ) {
      callback = props;
      props = [ "*" ];
    } else {
      props = props.split(" ");
    }

    var prop,
      index = 0,
      length = props.length;

    for ( ; index < length ; index++ ) {
      prop = props[ index ];
      tweeners[ prop ] = tweeners[ prop ] || [];
      tweeners[ prop ].unshift( callback );
    }
  },

  prefilter: function( callback, prepend ) {
    if ( prepend ) {
      animationPrefilters.unshift( callback );
    } else {
      animationPrefilters.push( callback );
    }
  }
});

function defaultPrefilter( elem, props, opts ) {
  var index, prop, value, length, dataShow, tween, hooks, oldfire,
    anim = this,
    style = elem.style,
    orig = {},
    handled = [],
    hidden = elem.nodeType && isHidden( elem );

  // handle queue: false promises
  if ( !opts.queue ) {
    hooks = jQuery._queueHooks( elem, "fx" );
    if ( hooks.unqueued == null ) {
      hooks.unqueued = 0;
      oldfire = hooks.empty.fire;
      hooks.empty.fire = function() {
        if ( !hooks.unqueued ) {
          oldfire();
        }
      };
    }
    hooks.unqueued++;

    anim.always(function() {
      // doing this makes sure that the complete handler will be called
      // before this completes
      anim.always(function() {
        hooks.unqueued--;
        if ( !jQuery.queue( elem, "fx" ).length ) {
          hooks.empty.fire();
        }
      });
    });
  }

  // height/width overflow pass
  if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
    // Make sure that nothing sneaks out
    // Record all 3 overflow attributes because IE does not
    // change the overflow attribute when overflowX and
    // overflowY are set to the same value
    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

    // Set display property to inline-block for height/width
    // animations on inline elements that are having width/height animated
    if ( jQuery.css( elem, "display" ) === "inline" &&
        jQuery.css( elem, "float" ) === "none" ) {

      // inline-level elements accept inline-block;
      // block-level elements need to be inline with layout
      if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
        style.display = "inline-block";

      } else {
        style.zoom = 1;
      }
    }
  }

  if ( opts.overflow ) {
    style.overflow = "hidden";
    if ( !jQuery.support.shrinkWrapBlocks ) {
      anim.done(function() {
        style.overflow = opts.overflow[ 0 ];
        style.overflowX = opts.overflow[ 1 ];
        style.overflowY = opts.overflow[ 2 ];
      });
    }
  }


  // show/hide pass
  for ( index in props ) {
    value = props[ index ];
    if ( rfxtypes.exec( value ) ) {
      delete props[ index ];
      if ( value === ( hidden ? "hide" : "show" ) ) {
        continue;
      }
      handled.push( index );
    }
  }

  length = handled.length;
  if ( length ) {
    dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
    if ( hidden ) {
      jQuery( elem ).show();
    } else {
      anim.done(function() {
        jQuery( elem ).hide();
      });
    }
    anim.done(function() {
      var prop;
      jQuery.removeData( elem, "fxshow", true );
      for ( prop in orig ) {
        jQuery.style( elem, prop, orig[ prop ] );
      }
    });
    for ( index = 0 ; index < length ; index++ ) {
      prop = handled[ index ];
      tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
      orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

      if ( !( prop in dataShow ) ) {
        dataShow[ prop ] = tween.start;
        if ( hidden ) {
          tween.end = tween.start;
          tween.start = prop === "width" || prop === "height" ? 1 : 0;
        }
      }
    }
  }
}

function Tween( elem, options, prop, end, easing ) {
  return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
  constructor: Tween,
  init: function( elem, options, prop, end, easing, unit ) {
    this.elem = elem;
    this.prop = prop;
    this.easing = easing || "swing";
    this.options = options;
    this.start = this.now = this.cur();
    this.end = end;
    this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  },
  cur: function() {
    var hooks = Tween.propHooks[ this.prop ];

    return hooks && hooks.get ?
      hooks.get( this ) :
      Tween.propHooks._default.get( this );
  },
  run: function( percent ) {
    var eased,
      hooks = Tween.propHooks[ this.prop ];

    if ( this.options.duration ) {
      this.pos = eased = jQuery.easing[ this.easing ](
        percent, this.options.duration * percent, 0, 1, this.options.duration
      );
    } else {
      this.pos = eased = percent;
    }
    this.now = ( this.end - this.start ) * eased + this.start;

    if ( this.options.step ) {
      this.options.step.call( this.elem, this.now, this );
    }

    if ( hooks && hooks.set ) {
      hooks.set( this );
    } else {
      Tween.propHooks._default.set( this );
    }
    return this;
  }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
  _default: {
    get: function( tween ) {
      var result;

      if ( tween.elem[ tween.prop ] != null &&
        (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
        return tween.elem[ tween.prop ];
      }

      // passing any value as a 4th parameter to .css will automatically
      // attempt a parseFloat and fallback to a string if the parse fails
      // so, simple values such as "10px" are parsed to Float.
      // complex values such as "rotate(1rad)" are returned as is.
      result = jQuery.css( tween.elem, tween.prop, false, "" );
      // Empty strings, null, undefined and "auto" are converted to 0.
      return !result || result === "auto" ? 0 : result;
    },
    set: function( tween ) {
      // use step hook for back compat - use cssHook if its there - use .style if its
      // available and use plain properties where available
      if ( jQuery.fx.step[ tween.prop ] ) {
        jQuery.fx.step[ tween.prop ]( tween );
      } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
        jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
      } else {
        tween.elem[ tween.prop ] = tween.now;
      }
    }
  }
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  set: function( tween ) {
    if ( tween.elem.nodeType && tween.elem.parentNode ) {
      tween.elem[ tween.prop ] = tween.now;
    }
  }
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
  var cssFn = jQuery.fn[ name ];
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return speed == null || typeof speed === "boolean" ||
      // special check for .toggle( handler, handler, ... )
      ( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?
      cssFn.apply( this, arguments ) :
      this.animate( genFx( name, true ), speed, easing, callback );
  };
});

jQuery.fn.extend({
  fadeTo: function( speed, to, easing, callback ) {

    // show any hidden elements after setting opacity to 0
    return this.filter( isHidden ).css( "opacity", 0 ).show()

      // animate to the value specified
      .end().animate({ opacity: to }, speed, easing, callback );
  },
  animate: function( prop, speed, easing, callback ) {
    var empty = jQuery.isEmptyObject( prop ),
      optall = jQuery.speed( speed, easing, callback ),
      doAnimation = function() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation( this, jQuery.extend( {}, prop ), optall );

        // Empty animations resolve immediately
        if ( empty ) {
          anim.stop( true );
        }
      };

    return empty || optall.queue === false ?
      this.each( doAnimation ) :
      this.queue( optall.queue, doAnimation );
  },
  stop: function( type, clearQueue, gotoEnd ) {
    var stopQueue = function( hooks ) {
      var stop = hooks.stop;
      delete hooks.stop;
      stop( gotoEnd );
    };

    if ( typeof type !== "string" ) {
      gotoEnd = clearQueue;
      clearQueue = type;
      type = undefined;
    }
    if ( clearQueue && type !== false ) {
      this.queue( type || "fx", [] );
    }

    return this.each(function() {
      var dequeue = true,
        index = type != null && type + "queueHooks",
        timers = jQuery.timers,
        data = jQuery._data( this );

      if ( index ) {
        if ( data[ index ] && data[ index ].stop ) {
          stopQueue( data[ index ] );
        }
      } else {
        for ( index in data ) {
          if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
            stopQueue( data[ index ] );
          }
        }
      }

      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
          timers[ index ].anim.stop( gotoEnd );
          dequeue = false;
          timers.splice( index, 1 );
        }
      }

      // start the next in the queue if the last step wasn't forced
      // timers currently will call their complete callbacks, which will dequeue
      // but only if they were gotoEnd
      if ( dequeue || !gotoEnd ) {
        jQuery.dequeue( this, type );
      }
    });
  }
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
  var which,
    attrs = { height: type },
    i = 0;

  // if we include width, step value is 1 to do all cssExpand values,
  // if we don't include width, step value is 2 to skip over Left and Right
  includeWidth = includeWidth? 1 : 0;
  for( ; i < 4 ; i += 2 - includeWidth ) {
    which = cssExpand[ i ];
    attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  }

  if ( includeWidth ) {
    attrs.opacity = attrs.width = type;
  }

  return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
  slideDown: genFx("show"),
  slideUp: genFx("hide"),
  slideToggle: genFx("toggle"),
  fadeIn: { opacity: "show" },
  fadeOut: { opacity: "hide" },
  fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return this.animate( props, speed, easing, callback );
  };
});

jQuery.speed = function( speed, easing, fn ) {
  var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
    complete: fn || !fn && easing ||
      jQuery.isFunction( speed ) && speed,
    duration: speed,
    easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
  };

  opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
    opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

  // normalize opt.queue - true/undefined/null -> "fx"
  if ( opt.queue == null || opt.queue === true ) {
    opt.queue = "fx";
  }

  // Queueing
  opt.old = opt.complete;

  opt.complete = function() {
    if ( jQuery.isFunction( opt.old ) ) {
      opt.old.call( this );
    }

    if ( opt.queue ) {
      jQuery.dequeue( this, opt.queue );
    }
  };

  return opt;
};

jQuery.easing = {
  linear: function( p ) {
    return p;
  },
  swing: function( p ) {
    return 0.5 - Math.cos( p*Math.PI ) / 2;
  }
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
  var timer,
    timers = jQuery.timers,
    i = 0;

  for ( ; i < timers.length; i++ ) {
    timer = timers[ i ];
    // Checks the timer has not already been removed
    if ( !timer() && timers[ i ] === timer ) {
      timers.splice( i--, 1 );
    }
  }

  if ( !timers.length ) {
    jQuery.fx.stop();
  }
};

jQuery.fx.timer = function( timer ) {
  if ( timer() && jQuery.timers.push( timer ) && !timerId ) {
    timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
  }
};

jQuery.fx.interval = 13;

jQuery.fx.stop = function() {
  clearInterval( timerId );
  timerId = null;
};

jQuery.fx.speeds = {
  slow: 600,
  fast: 200,
  // Default speed
  _default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
  jQuery.expr.filters.animated = function( elem ) {
    return jQuery.grep(jQuery.timers, function( fn ) {
      return elem === fn.elem;
    }).length;
  };
}
var rroot = /^(?:body|html)$/i;

jQuery.fn.offset = function( options ) {
  if ( arguments.length ) {
    return options === undefined ?
      this :
      this.each(function( i ) {
        jQuery.offset.setOffset( this, options, i );
      });
  }

  var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
    box = { top: 0, left: 0 },
    elem = this[ 0 ],
    doc = elem && elem.ownerDocument;

  if ( !doc ) {
    return;
  }

  if ( (body = doc.body) === elem ) {
    return jQuery.offset.bodyOffset( elem );
  }

  docElem = doc.documentElement;

  // Make sure it's not a disconnected DOM node
  if ( !jQuery.contains( docElem, elem ) ) {
    return box;
  }

  // If we don't have gBCR, just use 0,0 rather than error
  // BlackBerry 5, iOS 3 (original iPhone)
  if ( typeof elem.getBoundingClientRect !== "undefined" ) {
    box = elem.getBoundingClientRect();
  }
  win = getWindow( doc );
  clientTop  = docElem.clientTop  || body.clientTop  || 0;
  clientLeft = docElem.clientLeft || body.clientLeft || 0;
  scrollTop  = win.pageYOffset || docElem.scrollTop;
  scrollLeft = win.pageXOffset || docElem.scrollLeft;
  return {
    top: box.top  + scrollTop  - clientTop,
    left: box.left + scrollLeft - clientLeft
  };
};

jQuery.offset = {

  bodyOffset: function( body ) {
    var top = body.offsetTop,
      left = body.offsetLeft;

    if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
      top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
      left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
    }

    return { top: top, left: left };
  },

  setOffset: function( elem, options, i ) {
    var position = jQuery.css( elem, "position" );

    // set position first, in-case top/left are set even on static elem
    if ( position === "static" ) {
      elem.style.position = "relative";
    }

    var curElem = jQuery( elem ),
      curOffset = curElem.offset(),
      curCSSTop = jQuery.css( elem, "top" ),
      curCSSLeft = jQuery.css( elem, "left" ),
      calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
      props = {}, curPosition = {}, curTop, curLeft;

    // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
    if ( calculatePosition ) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;
    } else {
      curTop = parseFloat( curCSSTop ) || 0;
      curLeft = parseFloat( curCSSLeft ) || 0;
    }

    if ( jQuery.isFunction( options ) ) {
      options = options.call( elem, i, curOffset );
    }

    if ( options.top != null ) {
      props.top = ( options.top - curOffset.top ) + curTop;
    }
    if ( options.left != null ) {
      props.left = ( options.left - curOffset.left ) + curLeft;
    }

    if ( "using" in options ) {
      options.using.call( elem, props );
    } else {
      curElem.css( props );
    }
  }
};


jQuery.fn.extend({

  position: function() {
    if ( !this[0] ) {
      return;
    }

    var elem = this[0],

    // Get *real* offsetParent
    offsetParent = this.offsetParent(),

    // Get correct offsets
    offset       = this.offset(),
    parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

    // Subtract element margins
    // note: when an element has margin: auto the offsetLeft and marginLeft
    // are the same in Safari causing offset.left to incorrectly be 0
    offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
    offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

    // Add offsetParent borders
    parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
    parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

    // Subtract the two offsets
    return {
      top:  offset.top  - parentOffset.top,
      left: offset.left - parentOffset.left
    };
  },

  offsetParent: function() {
    return this.map(function() {
      var offsetParent = this.offsetParent || document.body;
      while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || document.body;
    });
  }
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
  var top = /Y/.test( prop );

  jQuery.fn[ method ] = function( val ) {
    return jQuery.access( this, function( elem, method, val ) {
      var win = getWindow( elem );

      if ( val === undefined ) {
        return win ? (prop in win) ? win[ prop ] :
          win.document.documentElement[ method ] :
          elem[ method ];
      }

      if ( win ) {
        win.scrollTo(
          !top ? val : jQuery( win ).scrollLeft(),
           top ? val : jQuery( win ).scrollTop()
        );

      } else {
        elem[ method ] = val;
      }
    }, method, val, arguments.length, null );
  };
});

function getWindow( elem ) {
  return jQuery.isWindow( elem ) ?
    elem :
    elem.nodeType === 9 ?
      elem.defaultView || elem.parentWindow :
      false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
    // margin is only for outerHeight, outerWidth
    jQuery.fn[ funcName ] = function( margin, value ) {
      var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
        extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

      return jQuery.access( this, function( elem, type, value ) {
        var doc;

        if ( jQuery.isWindow( elem ) ) {
          // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
          // isn't a whole lot we can do. See pull request at this URL for discussion:
          // https://github.com/jquery/jquery/pull/764
          return elem.document.documentElement[ "client" + name ];
        }

        // Get document width or height
        if ( elem.nodeType === 9 ) {
          doc = elem.documentElement;

          // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
          // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
          return Math.max(
            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
            elem.body[ "offset" + name ], doc[ "offset" + name ],
            doc[ "client" + name ]
          );
        }

        return value === undefined ?
          // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css( elem, type, value, extra ) :

          // Set width or height on the element
          jQuery.style( elem, type, value, extra );
      }, type, chainable ? margin : undefined, chainable, null );
    };
  });
});
// Expose jQuery to the global object
// window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
  define('@qubit---jquery@1.8.2/jquery',[],function () { return jQuery; } );
}

})( window );
define('@qubit---jquery@1.8.2', ['@qubit---jquery@1.8.2/jquery'], function (main) { return main; });

//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define('@qubit---backbone@1.1.2/backbone',['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      // QUBIT MODIFICATION:
      // root.Backbone = factory(root, exports, _, $);
      factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));
define('@qubit---backbone@1.1.2', ['@qubit---backbone@1.1.2/backbone'], function (main) { return main; });

define('@qubit---backbone-deep-model@0.10.5/deep_helpers',['require','@qubit/underscore','@qubit/backbone'],function (require) {

  var _ = require("@qubit/underscore");
  var Backbone = require("@qubit/backbone");

  var arrays, basicObjects, deepClone, deepExtend, deepExtendCouple, isBasicObject,
    __slice = [].slice;

  deepClone = function(obj) {
    var func, isArr;
    if (!_.isObject(obj) || _.isFunction(obj)) {
      return obj;
    }
    if (obj instanceof Backbone.Collection || obj instanceof Backbone.Model) {
      return obj;
    }
    if (_.isDate(obj)) {
      return new Date(obj.getTime());
    }
    if (_.isRegExp(obj)) {
      return new RegExp(obj.source, obj.toString().replace(/.*\//, ""));
    }
    isArr = _.isArray(obj || _.isArguments(obj));
    func = function(memo, value, key) {
      if (isArr) {
        memo.push(deepClone(value));
      } else {
        memo[key] = deepClone(value);
      }
      return memo;
    };
    return _.reduce(obj, func, isArr ? [] : {});
  };

  isBasicObject = function(object) {
    if (object === null) return false;
    return (object.prototype === {}.prototype || object.prototype === Object.prototype) && _.isObject(object) && !_.isArray(object) && !_.isFunction(object) && !_.isDate(object) && !_.isRegExp(object) && !_.isArguments(object);
  };

  basicObjects = function(object) {
    return _.filter(_.keys(object), function(key) {
      return isBasicObject(object[key]);
    });
  };

  arrays = function(object) {
    return _.filter(_.keys(object), function(key) {
      return _.isArray(object[key]);
    });
  };

  deepExtendCouple = function(destination, source, maxDepth) {
    var combine, recurse, sharedArrayKey, sharedArrayKeys, sharedObjectKey, sharedObjectKeys, _i, _j, _len, _len1;
    if (maxDepth === null) {
      maxDepth = 20;
    }
    if (maxDepth <= 0) {
      console.warn('_.deepExtend(): Maximum depth of recursion hit.');
      return _.extend(destination, source);
    }
    sharedObjectKeys = _.intersection(basicObjects(destination), basicObjects(source));
    recurse = function(key) {
      return source[key] = deepExtendCouple(destination[key], source[key], maxDepth - 1);
    };
    for (_i = 0, _len = sharedObjectKeys.length; _i < _len; _i++) {
      sharedObjectKey = sharedObjectKeys[_i];
      recurse(sharedObjectKey);
    }
    sharedArrayKeys = _.intersection(arrays(destination), arrays(source));
    combine = function(key) {
      return source[key] = _.union(destination[key], source[key]);
    };
    for (_j = 0, _len1 = sharedArrayKeys.length; _j < _len1; _j++) {
      sharedArrayKey = sharedArrayKeys[_j];
      combine(sharedArrayKey);
    }
    return _.extend(destination, source);
  };

  deepExtend = function() {
    var finalObj, maxDepth, objects, _i;
    objects = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), maxDepth = arguments[_i++];
    if (!_.isNumber(maxDepth)) {
      objects.push(maxDepth);
      maxDepth = 20;
    }
    if (objects.length <= 1) {
      return objects[0];
    }
    if (maxDepth <= 0) {
      return _.extend.apply(this, objects);
    }
    finalObj = objects.shift();
    while (objects.length > 0) {
      finalObj = deepExtendCouple(finalObj, deepClone(objects.shift()), maxDepth);
    }
    return finalObj;
  };


  return {
    deepClone: deepClone,
    isBasicObject: isBasicObject,
    basicObjects: basicObjects,
    arrays: arrays,
    deepExtend: deepExtend
  };
});
/*jshint expr:true eqnull:true */
/**
 *
 * Backbone.DeepModel v0.10.4
 *
 * Copyright (c) 2013 Charles Davison, Pow Media Ltd
 *
 * https://github.com/powmedia/backbone-deep-model
 * Licensed under the MIT License
 */


/**
 * Main source
 */

define('@qubit---backbone-deep-model@0.10.5/backbone-deep-model',['@qubit/underscore', '@qubit/backbone', './deep_helpers'], function(_, Backbone, __) {

    /**
     * Takes a nested object and returns a shallow object keyed with the path names
     * e.g. { "level1.level2": "value" }
     *
     * @param  {Object}      Nested object e.g. { level1: { level2: 'value' } }
     * @return {Object}      Shallow object with path names e.g. { 'level1.level2': 'value' }
     */
    function objToPaths(obj) {
        var ret = {},
            separator = DeepModel.keyPathSeparator;

        for (var key in obj) {
            var val = obj[key];

            if (val && val.constructor === Object && !_.isEmpty(val)) {
                //Recursion for embedded objects
                var obj2 = objToPaths(val);

                for (var key2 in obj2) {
                    var val2 = obj2[key2];

                    ret[key + separator + key2] = val2;
                }
            } else {
                ret[key] = val;
            }
        }

        return ret;
    }

    /**
     * @param {Object}  Object to fetch attribute from
     * @param {String}  Object path e.g. 'user.name'
     * @return {Mixed}
     */
    function getNested(obj, path, return_exists) {
        var separator = DeepModel.keyPathSeparator;

        var fields = path.split(separator);
        var result = obj;
        return_exists || (return_exists === false);
        for (var i = 0, n = fields.length; i < n; i++) {
            if (return_exists && !_.has(result, fields[i])) {
                return false;
            }
            result = result[fields[i]];

            if (result == null && i < n - 1) {
                result = {};
            }

            if (typeof result === 'undefined') {
                if (return_exists)
                {
                    return true;
                }
                return result;
            }
        }
        if (return_exists)
        {
            return true;
        }
        return result;
    }

    /**
     * @param {Object} obj                Object to fetch attribute from
     * @param {String} path               Object path e.g. 'user.name'
     * @param {Object} [options]          Options
     * @param {Boolean} [options.unset]   Whether to delete the value
     * @param {Mixed}                     Value to set
     */
    function setNested(obj, path, val, options) {
        options = options || {};

        var separator = DeepModel.keyPathSeparator;

        var fields = path.split(separator);
        var result = obj;
        for (var i = 0, n = fields.length; i < n && result !== undefined ; i++) {
            var field = fields[i];

            //If the last in the path, set the value
            if (i === n - 1) {
                options.unset ? delete result[field] : result[field] = val;
            } else {
                //Create the child object if it doesn't exist, or isn't an object
                if (typeof result[field] === 'undefined' || ! _.isObject(result[field])) {
                    result[field] = {};
                }

                //Move onto the next part of the path
                result = result[field];
            }
        }
    }

    function deleteNested(obj, path) {
      setNested(obj, path, null, { unset: true });
    }

    var DeepModel = Backbone.Model.extend({

        // Override constructor
        // Support having nested defaults by using __.deepExtend instead of _.extend
        constructor: function(attributes, options) {
            var defaults;
            var attrs = attributes || {};
            this.cid = _.uniqueId('c');
            this.attributes = {};
            if (options && options.collection) this.collection = options.collection;
            if (options && options.parse) attrs = this.parse(attrs, options) || {};
            if (defaults = _.result(this, 'defaults')) {
                //<custom code>
                // Replaced the call to _.defaults with __.deepExtend.
                attrs = __.deepExtend({}, defaults, attrs);
                //</custom code>
            }
            this.set(attrs, options);
            this.changed = {};
            this.initialize.apply(this, arguments);
        },

        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return __.deepClone(this.attributes);
        },

        // Override get
        // Supports nested attributes via the syntax 'obj.attr' e.g. 'author.user.name'
        get: function(attr) {
            return getNested(this.attributes, attr);
        },

        // Override set
        // Supports nested attributes via the syntax 'obj.attr' e.g. 'author.user.name'
        set: function(key, val, options) {
            var attr, attrs, unset, changes, silent, changing, prev, current;
            if (key == null) return this;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            if (typeof key === 'object') {
              attrs = key;
              options = val || {};
            } else {
              (attrs = {})[key] = val;
            }

            options || (options = {});

            // Run validation.
            if (!this._validate(attrs, options)) return false;

            // Extract attributes and options.
            unset           = options.unset;
            silent          = options.silent;
            changes         = [];
            changing        = this._changing;
            this._changing  = true;

            if (!changing) {
              this._previousAttributes = __.deepClone(this.attributes); //<custom>: Replaced _.clone with __.deepClone
              this.changed = {};
            }
            current = this.attributes, prev = this._previousAttributes;

            // Check for changes of `id`.
            if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

            //<custom code>
            attrs = objToPaths(attrs);
            //</custom code>

            // For each `set` attribute, update or delete the current value.
            for (attr in attrs) {
              val = attrs[attr];

              //<custom code>: Using getNested, setNested and deleteNested
              if (!_.isEqual(getNested(current, attr), val)) changes.push(attr);
              if (!_.isEqual(getNested(prev, attr), val)) {
                setNested(this.changed, attr, val);
              } else {
                deleteNested(this.changed, attr);
              }
              unset ? deleteNested(current, attr) : setNested(current, attr, val);
              //</custom code>
            }

            // Trigger all relevant attribute changes.
            if (!silent) {
              if (changes.length) this._pending = options;

              //<custom code>
              var separator = DeepModel.keyPathSeparator;

              for (var i = 0, l = changes.length; i < l; i++) {
                var key = changes[i];

                this.trigger('change:' + key, this, getNested(current, key), options);

                var fields = key.split(separator);

                //Trigger change events for parent keys with wildcard (*) notation
                for(var n = fields.length - 1; n > 0; n--) {
                  var parentKey = _.first(fields, n).join(separator),
                      wildcardKey = parentKey + separator + '*';

                  this.trigger('change:' + wildcardKey, this, getNested(current, parentKey), options);
                }
                //</custom code>
              }
            }

            if (changing) return this;
            if (!silent) {
              while (this._pending) {
                options = this._pending;
                this._pending = false;
                this.trigger('change', this, options);
              }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },

        // Clear all attributes on the model, firing `"change"` unless you choose
        // to silence it.
        clear: function(options) {
          var attrs = {};
          var shallowAttributes = objToPaths(this.attributes);
          for (var key in shallowAttributes) attrs[key] = void 0;
          return this.set(attrs, _.extend({}, options, {unset: true}));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !_.isEmpty(this.changed);
          return getNested(this.changed, attr) !== undefined;
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          //<custom code>: objToPaths
          if (!diff) return this.hasChanged() ? objToPaths(this.changed) : false;
          //</custom code>

          var old = this._changing ? this._previousAttributes : this.attributes;

          //<custom code>
          diff = objToPaths(diff);
          old = objToPaths(old);
          //</custom code>

          var val, changed = false;
          for (var attr in diff) {
            if (_.isEqual(old[attr], (val = diff[attr]))) continue;
            (changed || (changed = {}))[attr] = val;
          }
          return changed;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;

          //<custom code>
          return getNested(this._previousAttributes, attr);
          //</custom code>
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          //<custom code>
          return __.deepClone(this._previousAttributes);
          //</custom code>
        }
    });


    //Config; override in your app to customise
    DeepModel.keyPathSeparator = '.';

    // ALTER HOW THIS MODULE IS EXPORTED

    //Exports
    // Backbone.DeepModel = DeepModel;

    //For use in NodeJS
    // if (typeof module != 'undefined') module.exports = DeepModel;

    return DeepModel;

});

define('@qubit---backbone-deep-model@0.10.5/main',['require','./backbone-deep-model'],function (require) {
  var DeepModel = require("./backbone-deep-model");

  return DeepModel.extend();

  // var DeepModelMethods = {
  //   get: DeepModel.prototype.get,
  //   set: DeepModel.prototype.set,
  //   change: DeepModel.prototype.change,
  //   hasChanged: DeepModel.prototype.hasChanged,
  //   changedAttributes: DeepModel.prototype.changedAttributes
  // };
  //
  // /**
  //  * Mixin the DeepModelMethods properties.
  //  *
  //  * @param {Object} obj
  //  * @return {Object}
  //  * @api private
  //  */

  // function mixin(obj) {
  //   for (var key in DeepModelMethods) {
  //     obj[key] = DeepModelMethods[key];
  //   }
  //   return obj;
  // }


  // /**
  //  * Export the DeepModel mixin
  //  *
  //  * @param  {Object} obj Backbone Model
  //  * @return {Object} obj Backbone Model with deep model functions mixed in
  //  */
  // return function (obj) {
  //   return mixin(obj);
  // };

});
define('@qubit---backbone-deep-model@0.10.5', ['@qubit---backbone-deep-model@0.10.5/main'], function (main) { return main; });

define('@qubit---layer@1.0.4/src/models/base_model',['require','@qubit/backbone-deep-model'],function (require) {

  var DeepModel = require("@qubit/backbone-deep-model");

  return DeepModel.extend({});
});
define('@qubit---layer@1.0.4/src/models/component_model',['require','./base_model'],function (require) {

  var BaseModel = require("./base_model");

  return BaseModel.extend({});
});
define('@qubit---layer@1.0.4/src/models/component_collection',['require','@qubit/backbone','./component_model'],function (require) {

  var Backbone = require("@qubit/backbone");

  return Backbone.Collection.extend({
    model: require("./component_model")
  });
});
define('@qubit---container_style_processor@1.0.0/src/modules/css_property',['require','@qubit/underscore'],function (require) {
  var _ = require("@qubit/underscore");

  // listing treatments for css properties
  var compatibilityMaps = {
    "border-radius": ["moz", "webkit"],
    "box-shadow": ["moz", "webkit"]
  };

  function CssProperty() {
    this.init();
  }

  CssProperty.prototype.init = function () {
    this.properties = {};
  };

  CssProperty.prototype.set = function (property, value) {
    var vendors = compatibilityMaps[property];
    if (vendors) {
      // TODO: vendors can be an array or function?
      _.each(vendors, function (vendor) {
        this.properties["-" + vendor + "-" + property] = value;
      }, this);
    }
    // finally apply itself
    this.properties[property] = value;
  };

  CssProperty.prototype.exports = function () {
    // deep clone?
    return this.properties;
  };

  return CssProperty;
});
define('@qubit---container_style_processor@1.0.0/src/modules/background',['require','./css_property'],function (require) {
  var CssProperty = require("./css_property");

  return function (options) {
    var css = new CssProperty();

    if (!options) {
      return {
        "background": ""
      };
    }

    if (options.image_url) {
      css.set("background-image", "url(" + options.image_url + ")");
    } else {
      css.set("background-image", "");
    }

    if (options.repeat) {
      css.set("background-repeat", "repeat");
    } else {
      css.set("background-repeat", "no-repeat");
    }

    if (options.position) {
      css.set("background-position", options.position.x + " " + options.position.y);
    } else {
      css.set("background-position", "");
    }

    if (options.color) {
      css.set("background-color", options.color);
    } else {
      css.set("background-color", "");
    }

    return css.exports();
  };
});
define('@qubit---container_style_processor@1.0.0/src/modules/border',['require','./css_property'],function (require) {
  var CssProperty = require("./css_property");

  return function (options) {
    var css = new CssProperty();

    if (!options) {
      return {};
    }

    if (options.color) {
      css.set("border-color", options.color);
    } else {
      css.set("border-color", "");
    }

    // TODO: browser compatible
    if (options.radius) {
      css.set("border-radius", options.radius);
    } else {
      css.set("border-radius", 0);
    }

    if (options.width) {
      css.set("border-width", options.width);
    } else {
      css.set("border-width", 0);
    }

    if (options.style) {
      css.set("border-style", options.style);
    } else {
      css.set("border-style", "solid");
    }

    return css.exports();
  };
});
define('@qubit---container_style_processor@1.0.0/src/modules/shadow',['require','./css_property'],function (require) {
  var CssProperty = require("./css_property");

  return function (options) {
    var css = new CssProperty();
    var value = [];

    if (!options) {
      return {};
    }

    // required 
    if (options.direction) {
      value.push(options.direction.h || "0px");
      value.push(options.direction.v || "0px");
    } else {
      value.push("0px 0px");
    }

    // the rest are optional
    if (options.blur) {
      value.push(options.blur);
    }

    if (options.spread) {
      value.push(options.spread);
    }

    if (options.color) {
      value.push(options.color);
    }

    if (options.inset) {
      value.push("inset");
    }

    css.set("box-shadow", value.join(" "));

    return css.exports();
  };
});
/*
 * Process custom CSS Schema and export them as compatible CSS
 */
define('@qubit---container_style_processor@1.0.0/src/container_style_processor',['require','@qubit/jquery','./modules/background','./modules/border','./modules/shadow'],function (require) {
  var $          = require("@qubit/jquery");
  var background = require("./modules/background");
  var border     = require("./modules/border");
  var shadow     = require("./modules/shadow");

  return function (options) {
    // process background
    var backgroundCss = background(options.background);
    var borderCss     = border(options.border);
    var shadowCss     = shadow(options.shadow);
    // procss border

    return $.extend({}, backgroundCss, borderCss, shadowCss);
    // process shadow
  };
});
define('@qubit---container_style_processor@1.0.0', ['@qubit---container_style_processor@1.0.0/src/container_style_processor'], function (main) { return main; });

define('@qubit---each@1.0.0/each',[],function () {

  var breaker = {};
  var ArrayProto = Array.prototype;
  var nativeForEach = ArrayProto.forEach;

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  return function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };
});
define('@qubit---each@1.0.0', ['@qubit---each@1.0.0/each'], function (main) { return main; });

define('@qubit---emitter@1.0.0/emitter',['require','@qubit/each'],function (require) {

  /**
   * Turn any object into an event emitter.
   *
   * Adapted from Backbone.
   *
   * Compatible with Backbone.Events and component/emitter
   *
   * You may bind with `on` or remove with `off` callback
   * functions to an event; `trigger`-ing or `emit`-ing an event
   * fires all callbacks in succession.
   *
   *     var emitter = require('emitter');
   *     var object = {};
   *     emitter(object);
   *     object.on('expand', function(){ alert('expanded'); });
   *     object.trigger('expand');
  */
 
  var each = require('@qubit/each');
 
  var Emitter = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var onceFn = once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      onceFn._callback = callback;
      return this.on(name, onceFn, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if ((events = this._events[name])) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = Array.prototype.slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  function once(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  }

  // Retrieve the names of an object's properties.
  function keys(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keyList = [];
    for (var key in obj) if (obj.hasOwnProperty(key)) keyList.push(key);
    return keyList;
  }

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  each(listenMethods, function(implementation, method) {
    Emitter[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  function uniqueId(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  }

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter) {
      obj[key] = Emitter[key];
    }
    return obj;
  }

  /**
   * Aliase for component/emitter compatibility.
   */
  Emitter.emit = Emitter.trigger;

  /**
   * Export the Emitter mixin
   *
   * @param  {Object} obj
   * @return {Object} obj with emitter functions mixed in
   */
  return function (obj) {
    return mixin(obj);
  };

});
define('@qubit---emitter@1.0.0', ['@qubit---emitter@1.0.0/emitter'], function (main) { return main; });

define('@qubit---layer@1.0.4/src/prod/component_prod_api',['require','@qubit/emitter'],function (require) {

  // TODO API's generators should live in their own dir
  // and have bases to extend from (in case we wanna differentiate between
  // component and container APIs which we might want to do)
  // the separation of production/preview APIs would also happen in that dir

  /**
   * Component's (and Container's) Production API
   */

  var emitter = require("@qubit/emitter");

  return function makeComponentAPI(deliver) {

    var componentAPI = emitter({
      isPreviewMode: function () {
        return false;
      },

      layer: {
        close: function (options) {
          deliver.close(options);
        }
      }
    });

    return componentAPI;
  };


});
define('@qubit---layer@1.0.4/src/prod/component_wrapper_view',['require','@qubit/jquery','@qubit/backbone'],function (require) {

  var $ = require("@qubit/jquery");
  var Backbone = require("@qubit/backbone");

  return Backbone.View.extend({
    initialize: function (options) {
      this.options = options || {};
      this.api = this.options.api;
      this.$el.addClass("deliver-component-wrapper");
      this.isLink = (this.options.componentView.el.tagName.toLowerCase() === "a");
    },
    render: function () {
      this.$el.html(this.options.componentView.render().el);
      this.position();
      this.resize();
      if (!this.isLink) {
        this.setupClickAction();
      }
      this.setZIndex();
      return this;
    },
    setZIndex: function () {
      this.$el.css("z-index", this.model.id);
    },
    position: function () {
      this.$el.css({
        position: "absolute",
        top: this.model.get("top"),
        left: this.model.get("left")
      });
    },
    wrapLink: function (production) {

      var url = this.model.get("click_action.url");
      var newTab = this.model.get("click_action.new_tab");
      var api = this.api;
      var $componentEl = $(this.options.componentView.el);

      if (!this.$a) {
        this.$a = $("<a></a>")
          .css({
            textDecoration: "inherit"
          });
        this.$a.insertBefore($componentEl);
        $componentEl.appendTo(this.$a);
      }

      this.$a.attr("href", url);

      if (newTab) {
        this.$a.attr("target", "blank");
      } else {
        this.$a.removeAttr("target");
      }

      if (production && this.model.get("click_action.close_container")) {
        var closeDuration = parseInt(this.model.get("click_action.close_duration"), 10);
        var closeDurationUnit = this.model.get("click_action.close_duration_unit");
        this.$a.on("click", function () {
          api.layer.close({
            duration: closeDuration,
            type: closeDurationUnit
          });
        });
      }


    },
    setupClickAction: function () {
      var hasLink = this.model.get("click_action.has_link");
      if (hasLink) {
        this.wrapLink(true);
      }
    },

    /**
     * Resize a component to the configured size
     */

    resize: function () {
      var $componentEl = $(this.options.componentView.el);
      var $wrapperEl = this.$el;
      var model = this.model;

      function setViewDimension(dim, options) {
        if ((options || {}).auto) {
          $componentEl.css(dim, "");
          $wrapperEl.css(dim, "");
        } else {
          $componentEl.css(dim, "100%");
          $wrapperEl.css(dim, model.get(dim));
        }
      }

      if (model.get("width")) {
        setViewDimension("width");
      }
      if (model.get("autoHeight")) {
        setViewDimension("height", { auto: true });
      } else if (model.get("height")) {
        setViewDimension("height");
      }
    }

  });


});
define('@qubit---layer@1.0.4/src/prod/composer',['require','@qubit/jquery','@qubit/underscore','@qubit/container_style_processor','./component_prod_api','./component_wrapper_view'],function (require) {

  // TODO this could easily be the base for the composer-preview version

  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");
  var containerStyleProcessor = require("@qubit/container_style_processor");
  var makeComponentAPI = require("./component_prod_api");
  var ComponentWrapperView = require("./component_wrapper_view");

  function Composer(options) {
    this.options = options;
    this.require = options.require;
  }

  Composer.prototype.compose = function () {
    // create the container
    this.container = this.createContainer(this.options.containerModel);
    // create the components
    this.components = this.options.componentCollection.map(function (componentModel) {
      return this.createComponent(componentModel);
    }, this);

    // render it all out
    this.container.render();
    if (this.container.el) {
      this.styleContainer();
      var $container = $(this.container.el);
      _.each(this.components, function (component) {
        $container.append(component.render().el);
      });
    }

    return this;
  };

  Composer.prototype.createComponent = function (componentModel) {
    // in here we create 2 views, the inner view and the wrapper
    var api = makeComponentAPI(this.options.deliver);
    var componentView = this.create(componentModel.get("type"), {
      model: componentModel
    }, api);
    return new ComponentWrapperView({
      componentView: componentView,
      model: componentModel,
      api: api
    });
  };

  Composer.prototype.createContainer = function (containerModel) {
    var containerView = this.create(containerModel.get("type"), {
      model: containerModel
    }, makeComponentAPI(this.options.deliver));

    // TODO: this should go away when container becomes a component
    containerView.model = containerModel;

    if (containerView.el) {
      $(containerView.el).addClass("deliver-container");
    }

    return containerView;
  };

  Composer.prototype.styleContainer = function () {
    var containerModel = this.options.containerModel;
    var style = containerStyleProcessor(containerModel.get("__style") || {});
    $(this.container.el).css(style);
  };

  Composer.prototype.create = function (objectType, options, api) {
    return new (this.require(objectType))(options, api);
  };

  Composer.prototype.destroyComponents = function () {
    if (this.components && this.components.length) {
      _.invoke(this.components, "remove", this);
    }
  };

  Composer.prototype.destroy = function () {
    var self = this;
    if (this.container && this.container.close) {
      this.container.close(function () {
        self.container.remove();
        self.destroyComponents.call(self);
      });
    } else {
      self.destroyComponents.call(self);
    }
  };

  return Composer;

});
define('@qubit---layer@1.0.4/src/advanced_mode',['require','@qubit/jquery'],function (require) {
  var $ = require("@qubit/jquery");

  function AdvancedMode(options) {
    this.initialize(options);
  }

  AdvancedMode.prototype.initialize = function (options) {
    this.options = options;
    this.exec();
  };

  AdvancedMode.prototype.update = function (options) {
    this.options = options;
    this.exec();
  };

  AdvancedMode.prototype.escape = function (text) {
    return text
        .replace("\\", "\x5C")
        .replace("\"", "\x22")
        .replace("'", "\x27")
        .replace("\n", "\x0A");
  };

  AdvancedMode.prototype.exec = function () {
    if (this.options && this.options.code) {

      //Many advanced tests access require using 'require' rather than through the global route
      //so here we replicate this functionality by creating a new closure with require available.
      //'Global' JS also no longer executes on the window scope so it is not a problem to wrap it up
      //in another closure.
      var code = "(function () { var require = window.__qubit.amd.require;";
      code += this.options.globalCode || "";
      code += ";\n(" + this.options.code + ")();";
      code += "}());";

      var escapedCode = this.escape(code);

      try {
        this.applyStyles();
        $.globalEval(escapedCode);
      } catch (e) { }
    }
  };

  AdvancedMode.prototype.applyStyles = function () {
    if (this.options.styles) {
      this._addStyleSheet(this.options.styles);
    }
  };

  AdvancedMode.prototype._addStyleSheet = function (css) {
    var head = document.getElementsByTagName('head')[0];
    var el = document.createElement('style');
    el.setAttribute('type', 'text/css');
    el.setAttribute('class', 'deliver-advanced-styles');
    if (el.styleSheet) {
      el.styleSheet.cssText = css;
    } else {
      el.appendChild(document.createTextNode(css));
    }
    head.appendChild(el);
  };

  return AdvancedMode;
});
define('@qubit---layer@1.0.4/src/layer',['require','./models/base_model','./models/component_collection','./prod/composer','./advanced_mode','@qubit/emitter'],function (require) {

  var ContainerModel = require("./models/base_model");
  var ComponentCollection = require("./models/component_collection");
  var Composer = require("./prod/composer");
  var AdvancedMode = require("./advanced_mode");
  var emitter = require("@qubit/emitter");

  function onBodyReady(cb) {
    if (document.body) {
      cb();
    } else {
      setTimeout(function () {
        onBodyReady(cb);
      }, 50);
    }
  }

  function Layer() {
    this.initialize.apply(this, arguments);
  }

  emitter(Layer.prototype);

  Layer.prototype.getAdvancedModeClass = function () {
    return AdvancedMode;
  };

  Layer.prototype.getComposerClass = function () {
    return Composer;
  };

  Layer.prototype.initialize = function (deliver, options) {
    this.deliver = deliver;
    this.options = options;

    // advanced mode does not require to create all other components
    if (this.isAdvancedMode()) {
      this.advancedMode = new (this.getAdvancedModeClass())(options.advanced);
    } else {
      this.createModels(options);
    }

  };

  Layer.prototype.isExclusive = function () {
    return this.options.modules[this.containerModel.get("type")].isExclusive;
  };

  Layer.prototype.run = function (cb) {
    var self = this;
    if (!this.isAdvancedMode()) {
      onBodyReady(function () {
        self.compose();
        if (cb) {
          cb();
        }
      });
    } else {
      if (cb) {
        cb();
      }
    }
  };

  Layer.prototype.compose = function () {
    var self = this;
    this.composer = new (this.getComposerClass())({
      containerModel: this.containerModel,
      componentCollection: this.componentCollection,
      deliver: this.deliver,
      require: function (moduleId) {
        return self.options.modules[moduleId];
      }
    });
    this.composer.compose();
  };

  Layer.prototype.isAdvancedMode = function () {
    return this.options && this.options.advanced && this.options.advanced.enabled;
  };

  Layer.prototype.createModels = function (options) {
    this.componentCollection = new ComponentCollection(options.components);
    this.containerModel = new ContainerModel(options.container);
  };

  Layer.prototype.destroy = function () {
    if (this.composer) {
      this.composer.destroy();
    }
  };

  return Layer;

});
define('@qubit---layer@1.0.4', ['@qubit---layer@1.0.4/src/layer'], function (main) { return main; });

define('@qubit---maxz@1.0.8/lib/get_style',['require','exports','module','@qubit/jquery'],function (require, exports, module) {var $ = require('@qubit/jquery')

module.exports = function getStyle (el, prop) {
  if (el.currentStyle) {
    return el.currentStyle[prop]
  } else if (window.getComputedStyle) {
    return document.defaultView.getComputedStyle(el, null)[prop]
  } else {
    return $(el).css(prop)
  }
}

});

define('@qubit---maxz@1.0.8/maxz',['require','exports','module','@qubit/jquery','./lib/get_style'],function (require, exports, module) {/*
 * maxz
 * by alanclarke
 * Created 2013
 * Copyright (c) Qubit Group Ltd.
 * All rights reserved
 */

var $ = require('@qubit/jquery')
var getStyle = require('./lib/get_style')

/*
 * z index values tend to get silly after a while with elements fighting
 * z-index wars against each other this can actually be dangerous since
 * values could eventually exceed the maximum integer value normalize brings
 * silly values like one billion down to a managed offset like 10,000 while
 * maintaining the existing order
 */

function nullOrUndefined (val) {
  return (val === null) || (typeof val === 'undefined')
}

module.exports = function maxz (scope, normalize, offset, toIgnore) {
  if (nullOrUndefined(normalize)) normalize = false
  if (nullOrUndefined(offset)) offset = 1000000
  var zIndex = 0
  var i = 0
  var elems = document.body.getElementsByTagName('*')
  var results = []
  offset = offset || 0

  for (i = 0; i < elems.length; i++) {
    if (toIgnore && $(elems[i]).is(toIgnore)) continue
    if (!elems[i].style) continue

    // temporarily update position to get accurate z index
    var position = getStyle(elems[i], 'position')
    if (position && position !== 'static') {
      var z = parseInt(getStyle(elems[i], 'zIndex'), 10)
      zIndex = Math.max(zIndex, z || 0)
      if (normalize && z && (z > offset)) {
        results.push({
          el: elems[i],
          zIndex: z
        })
      }
    }
  }
  if (normalize) {
    results.sort(function (a, b) {
      return a.zIndex - b.zIndex
    })
    for (i = 0; i < results.length; i++) {
      $(results[i].el).css('zIndex', i + offset)
    }
    return i + offset
  }
  return zIndex
}

});

define('@qubit---maxz@1.0.8', ['@qubit---maxz@1.0.8/maxz'], function (main) { return main; });

/*
 * overlay
 * https://bitbucket.org/QuBitProducts/overlay/overview
 * created: 19 Jul 2013
 * alan@qubitproducts.com
 * Licensed under the apache license.
 */

(function () {

  function overlay($, maxz) {

    function Overlay(element, options) {
      this.init(element, options);
      return this;
    }

    Overlay.prototype = {
      options: {
        speed: 0,
        css: {
          background: "transparent"
        },
        autoShow: true,
        opacity: 1
      },
      show: function (cb) {
        var self = this;
        this.$overlay.css({
          zIndex: maxz(this.$el, true, 10000) + 1,
          display: "inherit",
          opacity: 0
        });
        this.$overlay.fadeTo(this.options.speed, this.options.opacity, function () {
          self.$el.trigger("deliver-overlay-show");
          if (cb) {
            cb(self);
          }
        });
      },
      hide: function (cb) {
        var self = this;
        this.$overlay.fadeOut(this.options.speed, function () {
          self.$el.trigger("deliver-overlay-hide");
          if (cb) {
            cb(self);
          }
        });
      },
      init: function (element, options) {
        this.$el = $(element);
        this.$overlay = (this.$overlay || $("<div></div")).addClass("deliver-overlay");
        this.options = $.extend({}, this.options, options);
        this.isBody = this.$el.is("body");
        this.$container = (this.isBody ? this.$el : $('<div></div')).addClass("deliver-overlay-container");
        this.$overlay
          .appendTo(this.$container)
          .css($.extend({}, {
            position: "fixed",
            display: "block",
            width: "100%",
            height: "100%",
            top: 0,
            left: 0,
            zIndex: this.$el.css("zIndex") + 1
          }, this.options.css))
          .hide();
        if (!this.isBody) {
          var position = this.$el.css("position") || "relative";
          this._style = this.$el.attr("style");
          this.$container
            .insertAfter(this.$el)
            .append(this.$el)
            .css({
              width: this.$el.outerWidth(),
              height: this.$el.outerHeight(),
              position: position === "static" ? "relative" : position,
              padding: 0
            });
          this.copyCss("left right top bottom margin".split(" "), this.$el, this.$container);
          this.copyCss("top left bottom right margin", [0, 0, 0, 0, 0], this.$el);
        } else {
          this.$overlay.css({
            zIndex: maxz(this.$el, true, 10000) + 1
          });
        }
        if (this.options.autoShow) {
          this.show();
        }
      },
      copyCss: function (rules, $from, $to) {
        $.each(rules, function (index, name) {
          $to.css(name, $.isArray($from) ? $from[index] : $from.css(name));
        });
      },
      destroy: function () {
        this.$overlay.stop().remove();
        if (!this.isBody) {
          this.$el.attr("style", this._style);
          this.$el.insertAfter(this.$container);
          this.$container.stop().remove();
        } else {
          this.$el.removeClass("deliver-overlay-container");
        }
        this.$el.removeData("overlay");
      }
    };

    $.fn.overlay = function (options) {
      if ($.isFunction(Overlay.prototype[options])) {
        var plugin = $(this).data("overlay");
        return plugin[options].apply(plugin, Array.prototype.slice.call(arguments, 1));
      }
      return this.each(function () {
        var plugin = $.data(this, "overlay");
        if (!plugin) {
          $.data(this, "overlay", new Overlay(this, options));
        }
      });
    };
    return Overlay;
  }

  if (typeof define === 'function' && define.amd) {
    define('@qubit---overlay@0.0.2/src/overlay',["@qubit/jquery", "@qubit/maxz"], overlay);
  } else {
    overlay(jQuery);
  }
})();

define('@qubit---overlay@0.0.2', ['@qubit---overlay@0.0.2/src/overlay'], function (main) { return main; });

/*!
 * jQuery UI Position 1.11.3
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( factory ) {
  if ( typeof define === "function" && define.amd ) {

    // AMD. Register as an anonymous module.
    define( '@qubit---jquery-ui@1.11.3/position',[ "jquery" ], factory );
  } else {

    // Browser globals
    factory( jQuery );
  }
}(function( $ ) {
(function() {

$.ui = $.ui || {};

var cachedScrollbarWidth, supportsOffsetFractions,
  max = Math.max,
  abs = Math.abs,
  round = Math.round,
  rhorizontal = /left|center|right/,
  rvertical = /top|center|bottom/,
  roffset = /[\+\-]\d+(\.[\d]+)?%?/,
  rposition = /^\w+/,
  rpercent = /%$/,
  _position = $.fn.position;

function getOffsets( offsets, width, height ) {
  return [
    parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
    parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
  ];
}

function parseCss( element, property ) {
  return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
  var raw = elem[0];
  if ( raw.nodeType === 9 ) {
    return {
      width: elem.width(),
      height: elem.height(),
      offset: { top: 0, left: 0 }
    };
  }
  if ( $.isWindow( raw ) ) {
    return {
      width: elem.width(),
      height: elem.height(),
      offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
    };
  }
  if ( raw.preventDefault ) {
    return {
      width: 0,
      height: 0,
      offset: { top: raw.pageY, left: raw.pageX }
    };
  }
  return {
    width: elem.outerWidth(),
    height: elem.outerHeight(),
    offset: elem.offset()
  };
}

$.position = {
  scrollbarWidth: function() {
    if ( cachedScrollbarWidth !== undefined ) {
      return cachedScrollbarWidth;
    }
    var w1, w2,
      div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
      innerDiv = div.children()[0];

    $( "body" ).append( div );
    w1 = innerDiv.offsetWidth;
    div.css( "overflow", "scroll" );

    w2 = innerDiv.offsetWidth;

    if ( w1 === w2 ) {
      w2 = div[0].clientWidth;
    }

    div.remove();

    return (cachedScrollbarWidth = w1 - w2);
  },
  getScrollInfo: function( within ) {
    var overflowX = within.isWindow || within.isDocument ? "" :
        within.element.css( "overflow-x" ),
      overflowY = within.isWindow || within.isDocument ? "" :
        within.element.css( "overflow-y" ),
      hasOverflowX = overflowX === "scroll" ||
        ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
      hasOverflowY = overflowY === "scroll" ||
        ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
    return {
      width: hasOverflowY ? $.position.scrollbarWidth() : 0,
      height: hasOverflowX ? $.position.scrollbarWidth() : 0
    };
  },
  getWithinInfo: function( element ) {
    var withinElement = $( element || window ),
      isWindow = $.isWindow( withinElement[0] ),
      isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
    return {
      element: withinElement,
      isWindow: isWindow,
      isDocument: isDocument,
      offset: withinElement.offset() || { left: 0, top: 0 },
      scrollLeft: withinElement.scrollLeft(),
      scrollTop: withinElement.scrollTop(),

      // support: jQuery 1.6.x
      // jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
      width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
      height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
    };
  }
};

$.fn.position = function( options ) {
  if ( !options || !options.of ) {
    return _position.apply( this, arguments );
  }

  // make a copy, we don't want to modify arguments
  options = $.extend( {}, options );

  var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
    target = $( options.of ),
    within = $.position.getWithinInfo( options.within ),
    scrollInfo = $.position.getScrollInfo( within ),
    collision = ( options.collision || "flip" ).split( " " ),
    offsets = {};

  dimensions = getDimensions( target );
  if ( target[0].preventDefault ) {
    // force left top to allow flipping
    options.at = "left top";
  }
  targetWidth = dimensions.width;
  targetHeight = dimensions.height;
  targetOffset = dimensions.offset;
  // clone to reuse original targetOffset later
  basePosition = $.extend( {}, targetOffset );

  // force my and at to have valid horizontal and vertical positions
  // if a value is missing or invalid, it will be converted to center
  $.each( [ "my", "at" ], function() {
    var pos = ( options[ this ] || "" ).split( " " ),
      horizontalOffset,
      verticalOffset;

    if ( pos.length === 1) {
      pos = rhorizontal.test( pos[ 0 ] ) ?
        pos.concat( [ "center" ] ) :
        rvertical.test( pos[ 0 ] ) ?
          [ "center" ].concat( pos ) :
          [ "center", "center" ];
    }
    pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
    pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

    // calculate offsets
    horizontalOffset = roffset.exec( pos[ 0 ] );
    verticalOffset = roffset.exec( pos[ 1 ] );
    offsets[ this ] = [
      horizontalOffset ? horizontalOffset[ 0 ] : 0,
      verticalOffset ? verticalOffset[ 0 ] : 0
    ];

    // reduce to just the positions without the offsets
    options[ this ] = [
      rposition.exec( pos[ 0 ] )[ 0 ],
      rposition.exec( pos[ 1 ] )[ 0 ]
    ];
  });

  // normalize collision option
  if ( collision.length === 1 ) {
    collision[ 1 ] = collision[ 0 ];
  }

  if ( options.at[ 0 ] === "right" ) {
    basePosition.left += targetWidth;
  } else if ( options.at[ 0 ] === "center" ) {
    basePosition.left += targetWidth / 2;
  }

  if ( options.at[ 1 ] === "bottom" ) {
    basePosition.top += targetHeight;
  } else if ( options.at[ 1 ] === "center" ) {
    basePosition.top += targetHeight / 2;
  }

  atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
  basePosition.left += atOffset[ 0 ];
  basePosition.top += atOffset[ 1 ];

  return this.each(function() {
    var collisionPosition, using,
      elem = $( this ),
      elemWidth = elem.outerWidth(),
      elemHeight = elem.outerHeight(),
      marginLeft = parseCss( this, "marginLeft" ),
      marginTop = parseCss( this, "marginTop" ),
      collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
      collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
      position = $.extend( {}, basePosition ),
      myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

    if ( options.my[ 0 ] === "right" ) {
      position.left -= elemWidth;
    } else if ( options.my[ 0 ] === "center" ) {
      position.left -= elemWidth / 2;
    }

    if ( options.my[ 1 ] === "bottom" ) {
      position.top -= elemHeight;
    } else if ( options.my[ 1 ] === "center" ) {
      position.top -= elemHeight / 2;
    }

    position.left += myOffset[ 0 ];
    position.top += myOffset[ 1 ];

    // if the browser doesn't support fractions, then round for consistent results
    if ( !supportsOffsetFractions ) {
      position.left = round( position.left );
      position.top = round( position.top );
    }

    collisionPosition = {
      marginLeft: marginLeft,
      marginTop: marginTop
    };

    $.each( [ "left", "top" ], function( i, dir ) {
      if ( $.ui.position[ collision[ i ] ] ) {
        $.ui.position[ collision[ i ] ][ dir ]( position, {
          targetWidth: targetWidth,
          targetHeight: targetHeight,
          elemWidth: elemWidth,
          elemHeight: elemHeight,
          collisionPosition: collisionPosition,
          collisionWidth: collisionWidth,
          collisionHeight: collisionHeight,
          offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
          my: options.my,
          at: options.at,
          within: within,
          elem: elem
        });
      }
    });

    if ( options.using ) {
      // adds feedback as second argument to using callback, if present
      using = function( props ) {
        var left = targetOffset.left - position.left,
          right = left + targetWidth - elemWidth,
          top = targetOffset.top - position.top,
          bottom = top + targetHeight - elemHeight,
          feedback = {
            target: {
              element: target,
              left: targetOffset.left,
              top: targetOffset.top,
              width: targetWidth,
              height: targetHeight
            },
            element: {
              element: elem,
              left: position.left,
              top: position.top,
              width: elemWidth,
              height: elemHeight
            },
            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
          };
        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
          feedback.horizontal = "center";
        }
        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
          feedback.vertical = "middle";
        }
        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
          feedback.important = "horizontal";
        } else {
          feedback.important = "vertical";
        }
        options.using.call( this, props, feedback );
      };
    }

    elem.offset( $.extend( position, { using: using } ) );
  });
};

$.ui.position = {
  fit: {
    left: function( position, data ) {
      var within = data.within,
        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
        outerWidth = within.width,
        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
        overLeft = withinOffset - collisionPosLeft,
        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
        newOverRight;

      // element is wider than within
      if ( data.collisionWidth > outerWidth ) {
        // element is initially over the left side of within
        if ( overLeft > 0 && overRight <= 0 ) {
          newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
          position.left += overLeft - newOverRight;
        // element is initially over right side of within
        } else if ( overRight > 0 && overLeft <= 0 ) {
          position.left = withinOffset;
        // element is initially over both left and right sides of within
        } else {
          if ( overLeft > overRight ) {
            position.left = withinOffset + outerWidth - data.collisionWidth;
          } else {
            position.left = withinOffset;
          }
        }
      // too far left -> align with left edge
      } else if ( overLeft > 0 ) {
        position.left += overLeft;
      // too far right -> align with right edge
      } else if ( overRight > 0 ) {
        position.left -= overRight;
      // adjust based on position and margin
      } else {
        position.left = max( position.left - collisionPosLeft, position.left );
      }
    },
    top: function( position, data ) {
      var within = data.within,
        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
        outerHeight = data.within.height,
        collisionPosTop = position.top - data.collisionPosition.marginTop,
        overTop = withinOffset - collisionPosTop,
        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
        newOverBottom;

      // element is taller than within
      if ( data.collisionHeight > outerHeight ) {
        // element is initially over the top of within
        if ( overTop > 0 && overBottom <= 0 ) {
          newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
          position.top += overTop - newOverBottom;
        // element is initially over bottom of within
        } else if ( overBottom > 0 && overTop <= 0 ) {
          position.top = withinOffset;
        // element is initially over both top and bottom of within
        } else {
          if ( overTop > overBottom ) {
            position.top = withinOffset + outerHeight - data.collisionHeight;
          } else {
            position.top = withinOffset;
          }
        }
      // too far up -> align with top
      } else if ( overTop > 0 ) {
        position.top += overTop;
      // too far down -> align with bottom edge
      } else if ( overBottom > 0 ) {
        position.top -= overBottom;
      // adjust based on position and margin
      } else {
        position.top = max( position.top - collisionPosTop, position.top );
      }
    }
  },
  flip: {
    left: function( position, data ) {
      var within = data.within,
        withinOffset = within.offset.left + within.scrollLeft,
        outerWidth = within.width,
        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
        overLeft = collisionPosLeft - offsetLeft,
        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
        myOffset = data.my[ 0 ] === "left" ?
          -data.elemWidth :
          data.my[ 0 ] === "right" ?
            data.elemWidth :
            0,
        atOffset = data.at[ 0 ] === "left" ?
          data.targetWidth :
          data.at[ 0 ] === "right" ?
            -data.targetWidth :
            0,
        offset = -2 * data.offset[ 0 ],
        newOverRight,
        newOverLeft;

      if ( overLeft < 0 ) {
        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
          position.left += myOffset + atOffset + offset;
        }
      } else if ( overRight > 0 ) {
        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
          position.left += myOffset + atOffset + offset;
        }
      }
    },
    top: function( position, data ) {
      var within = data.within,
        withinOffset = within.offset.top + within.scrollTop,
        outerHeight = within.height,
        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
        collisionPosTop = position.top - data.collisionPosition.marginTop,
        overTop = collisionPosTop - offsetTop,
        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
        top = data.my[ 1 ] === "top",
        myOffset = top ?
          -data.elemHeight :
          data.my[ 1 ] === "bottom" ?
            data.elemHeight :
            0,
        atOffset = data.at[ 1 ] === "top" ?
          data.targetHeight :
          data.at[ 1 ] === "bottom" ?
            -data.targetHeight :
            0,
        offset = -2 * data.offset[ 1 ],
        newOverTop,
        newOverBottom;
      if ( overTop < 0 ) {
        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
          position.top += myOffset + atOffset + offset;
        }
      } else if ( overBottom > 0 ) {
        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
          position.top += myOffset + atOffset + offset;
        }
      }
    }
  },
  flipfit: {
    left: function() {
      $.ui.position.flip.left.apply( this, arguments );
      $.ui.position.fit.left.apply( this, arguments );
    },
    top: function() {
      $.ui.position.flip.top.apply( this, arguments );
      $.ui.position.fit.top.apply( this, arguments );
    }
  }
};

// fraction support test
(function() {
  var testElement, testElementParent, testElementStyle, offsetLeft, i,
    body = document.getElementsByTagName( "body" )[ 0 ],
    div = document.createElement( "div" );

  //Create a "fake body" for testing based on method used in jQuery.support
  testElement = document.createElement( body ? "div" : "body" );
  testElementStyle = {
    visibility: "hidden",
    width: 0,
    height: 0,
    border: 0,
    margin: 0,
    background: "none"
  };
  if ( body ) {
    $.extend( testElementStyle, {
      position: "absolute",
      left: "-1000px",
      top: "-1000px"
    });
  }
  for ( i in testElementStyle ) {
    testElement.style[ i ] = testElementStyle[ i ];
  }
  testElement.appendChild( div );
  testElementParent = body || document.documentElement;
  testElementParent.insertBefore( testElement, testElementParent.firstChild );

  div.style.cssText = "position: absolute; left: 10.7432222px;";

  offsetLeft = $( div ).offset().left;
  supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

  testElement.innerHTML = "";
  testElementParent.removeChild( testElement );
})();

})();

return $.ui.position;

}));

/*
 * Slider
 * created: 24 Jul 2013 by alan clarke, alan@qubitproducts.com
 */

define('@qubit---slider@1.0.2/src/slider',['require','@qubit/jquery','@qubit/maxz','@qubit/overlay','@qubit/jquery-ui/position'],function (require) {
  var $ = require("@qubit/jquery");
  var maxz = require("@qubit/maxz");
  var Overlay = require("@qubit/overlay");
  require("@qubit/jquery-ui/position");

  function Slider(options, api) {
    this.init(options, api);
  }

  Slider.prototype = {
    init: function (options, api) {
      this.model = options.model;
      this.api = api;
      this.$el = $("<div class=\"deliver-slider\"></div>");
      this.el = this.$el.get(0);
      if (options.container) {
        this.$container = $(options.container);
      }
    },
    cacheSelectors: function () {
      var self = this;
      this.$container = (this.$container || $(document.body));
      this.$window = $(window);
      this.$window.off("resize.qubit.deliver_slider");
      this.$window.on("resize.qubit.deliver_slider", function (event) {
        if (self.$window.is($(event.target))) {
          self.position();
        }
      });
    },
    closeLayer: function () {
      this.api.layer.close({
        duration: 0,
        type: "days"
      });
    },
    renderOverlay: function () {
      var self = this;
      this.$el.hide();
      this.overlay = new Overlay(this.$container, this.model.get("overlayOptions"));
      this.overlay.$overlay.on("click", function () {
        self.closeLayer();
      });
      this.overlay.show(function () {
        self.hasOverlay = true;
        return self.render();
      });
      return this;
    },
    destroyOverlay: function () {
      if (this.overlay) {
        this.overlay.destroy();
        this.$container.off("deliver-overlay-show");
        this.hasOverlay = false;
        delete this.overlay;
      }
    },
    render: function () {
      this.cacheSelectors();
      if (!this.hasOverlay) {
        this.destroyOverlay();
        this.$el.appendTo(this.$container);
        if (this.model.get("overlay")) {
          return this.renderOverlay();
        }
      } else {
        delete this.hasOverlay;
      }
      this.afterRender();
      window.q_ef_disable = true;
      return this;
    },
    afterRender: function () {
      this.$el.css(this.model.get("style") || {});
      this.resize();
      this.animate();
    },
    resize: function () {
      var size = this.model.get("size") || {};
      if (size.width && size.height) {
        this.$el.css(this.model.get("size"));
      }
    },
    limit: function (css) {
      var $container = this.$container.is("body") ? $(document) : this.$container;
      var maxLeft = $container.outerWidth() - this.$el.outerWidth();
      var maxTop = $container.outerHeight() - this.$el.outerHeight();
      css.left = (css.left < 0) ? 0 : css.left;
      css.left = (css.left > maxLeft) ? maxLeft : css.left;
      css.top = (css.top < 0) ? 0 : css.top;
      css.top = (css.top > maxTop) ? maxTop : css.top;
      return css;
    },
    setOffset: function (p, offset) {
      var i = 0;
      return p.replace(/(left|right|center|top|bottom)([+-]\d+)?/gi, function (match, pos) {
        var amount = (i++ ? offset.y : offset.x);
        if (amount === 0) {
          return pos;
        } else if (pos === "right" || pos === "bottom") {
          amount = -amount;
        }
        return pos + (amount >= 0 ? "+" : "") + amount;
      });
    },
    clearPosition: function () {
      this.$el.css({
        top: 0,
        left: 0,
        position: this.model.get("position.fixed") ? "fixed" : "absolute",
        margin: 0
      });
    },
    getPositionOptions: function (options) {
      var self = this;
      var position = {
        my: this.setOffset(options.my, options.offset),
        at: options.my,
        of: options.fixed ? this.$window : (this.$container.is("body") ? $(document) : this.$container),
        collision: "none"
      };
      position.using = function (css) {
        self.$el.css(self.limit(css));
      };
      return position;
    },
    animate: function () {
      var self = this;
      if (this.model.get("animation.type") === "fade") {
        this.position();
        this.$el.hide().fadeIn(this.model.get("speed"), function () {
          self.$el.trigger("rendered");
        });
      } else if (this.model.get("animation.type") === "slide") {
        var start, end;
        this.clearPosition();
        var position = this.getPositionOptions(this.model.get("position"));
        position.using = function (css) {
          end = self.limit(css);
        };
        this.$el.position(position);
        var containerHeight = position.of.outerWidth();
        var containerWidth = position.of.outerWidth();
        var width = this.$el.outerWidth();
        var height = this.$el.outerWidth();
        switch (this.model.get("animation.direction")) {
        case "top":
          start = $.extend({}, end, {
            top: -height
          });
          break;
        case "bottom":
          start = $.extend({}, end, {
            top: containerHeight + height
          });
          break;
        case "left":
          start = $.extend({}, end, {
            left: -width
          });
          break;
        default:
          start = $.extend({}, end, {
            left: containerWidth + width
          });
          break;
        }
        this.maxz();
        this.$el.css(start).show().animate(end, this.model.get("speed"), function () {
          self.$el.trigger("rendered");
        });
      } else {
        this.position();
        this.$el.trigger("rendered");
      }
    },
    maxz: function () {
      this.$el.css("zIndex", maxz($(document.body), true, 10000000) + 1);
    },
    position: function () {
      this.$el.show();
      this.clearPosition();
      var p = this.getPositionOptions(this.model.get("position"));
      this.$el.position(p);
      this.maxz();
    },
    close: function (cb) {
      if (this.overlay) {
        this.overlay.hide();
      }
      this.$el.fadeOut(this.model.get("speed"), function () {
        cb();
      });
    },
    remove: function () {
      this.destroyOverlay();
      this.$window && this.$window.off("resize.qubit.deliver_slider");
      this.$el.stop().remove();
    }
  };

  /* Should the container set (and respect) the vm.sliderShowing flag */
  Slider.isExclusive = true;

  return Slider;
});
define('@qubit---slider@1.0.2', ['@qubit---slider@1.0.2/src/slider'], function (main) { return main; });

define('@qubit---selector@1.1.0/lib/selectors',['require','@qubit/jquery'],function (require) {

  var $ = require("@qubit/jquery");

  return {

    id: function ($el, ignore) {
      var id = $el.attr("id");
      id = id ? "#" + id : "";
      if (ignore && id && id.match(ignore)) {
        return "";
      } else {
        return id;
      }
    },

    classnames: function ($el, ignore) {
      var classes = ($el.attr("class") || "").match(/\S+/g) || [];
      classes = $.map(classes, function (classname) {
        return "." + classname;
      });
      if (ignore) {
        classes = $.grep(classes, function (classname) {
          return !classname.match(ignore);
        });
      }
      return classes;
    },

    tagname: function ($el) {
      return ($el.prop("tagName") || "").toLowerCase();
    },

    index: function ($el, selector) {
      var $siblings = $($el.parent().children());
      if (selector) {
        $siblings = $siblings.filter(selector);
      }
      return (selector || "") + ":eq(" + $siblings.index($el) + ")";
    }

  };
});
/*
 * selector
 * by alanclarke
 * Created 2013
 * Copyright (c) Qubit Group Ltd.
 * All rights reserved
 */

define('@qubit---selector@1.1.0/selector',['require','@qubit/jquery','./lib/selectors'],function (require) {
  var $ = require("@qubit/jquery");
  var selectors = require("./lib/selectors");

  function Selector(options) {
    this.init(options);
  }

  Selector.prototype = {

    separator: " > ",

    init: function (options) {
      this.options = $.extend(true, {}, {ignore: false}, options);
    },

    destroy: function () {},

    elementFromPoint: function (x, y) {
      var check = false;
      var isRelative = true;

      if (!document.elementFromPoint) return null;

      if (!check) {
        var sl;
        if ((sl = $(document).scrollTop()) > 0) {
          isRelative = !(document.elementFromPoint(0, sl + $(window).height() - 1));
        } else if ((sl = $(document).scrollLeft()) > 0) {
          isRelative = !(document.elementFromPoint(sl + $(window).width() - 1, 0));
        }
        check = (sl > 0);
      }

      if (!isRelative) {
        x += $(document).scrollLeft();
        y += $(document).scrollTop();
      }
      return $(document.elementFromPoint(x, y));
    },

    eatParents: function ($el, fuzzy) {
      var $parent = $el.parent();
      if (!$parent.length) {
        return $el;
      }
      if ($parent.is("html") || $parent.is("body")) {
        return $el;
      }
      if ($parent.get(0).getBoundingClientRect &&
        $el.get(0).getBoundingClientRect) {
        var same = true;
        var bounds = $el.get(0).getBoundingClientRect();
        $.each($parent.get(0).getBoundingClientRect(), function (prop, value) {
          same = same && (Math.abs(bounds[prop] - value) < (fuzzy || 1));
        });
        if (same) {
          return this.eatParents($parent);
        }
      }
      return $el;
    },

    bestSelector: function (selectors, $el, $parent) {
      var best, min = false;
      $.each(selectors, function (index, selector) {
        var matches = $(selector, $parent).length;
        if (min === false) {
          if ($el.is(selector)) {
            best = selector;
          }
          min = matches;
        }

        // prefer the left most class if they're all the same
        // as people usually add less semantically useful classes at the end
        // e.g. .left or .large or .clearfix
        if ($el.is(selector) && $(selector, $parent).length < min) {
          best = selector;
          min = matches;
        }
      });
      return best;
    },

    checkSelector: function (selector, $el, $parent) {
      var $selected = $(selector, $parent);
      return $selected.length === 1 && $el.is($selected);
    },

    selectorsEquivalent: function ($results1, $results2) {
      $results1 = $($results1);
      $results2 = $($results2);
      return $results2 && $results1.length ===
        $results2.length && $results1.length === $results1.filter($results2).length;
    },

    compact: function (selector) {
      var self = this;
      // remove any redundant hierarchy first
      // as this changes semantics of selectors
      selector = this.removeRedundantHierarchy(selector);
      var parts = selector.match(/\S+/g) || [];
      var i = 0;
      $.each(parts, function (index) {
        var newSelector = parts.slice(0);
        newSelector.splice(index - i, 1);
        if (self.selectorsEquivalent(newSelector.join(" "), parts.join(" "))) {
          parts = newSelector;
          i++;
        }
      });
      return parts.join(" ");
    },

    removeRedundantHierarchy: function (selector) {
      var newSelector;
      var re = />/gi;
      while (re.exec(selector)) {
        newSelector = (selector.substring(0, re.lastIndex).replace(">", " ") +
          selector.substring(re.lastIndex)).replace(/\s+/gi, " ");
        if (this.selectorsEquivalent(newSelector, selector)) {
          selector = newSelector;
        }
      }
      return selector;
    },

    generateSelector: function ($el, parentSelector, $dom) {
      var $parent = $el.parent();
      parentSelector = parentSelector || "";

      // If id attribute exists use it
      var id = selectors.id($el, this.options.ignore);
      if (id && this.checkSelector(parentSelector + id, $el, $dom)) {
        return id;
      }

      // If tagname will suffice, use tagname
      var tagname = selectors.tagname($el);
      if (this.checkSelector(parentSelector + tagname, $el, $dom)) {
        return tagname;
      }

      // If classname will suffice, use classname
      var classnames = selectors.classnames($el, this.options.ignore);
      var bestClassname = this.bestSelector(classnames, $el, parentSelector, $dom);
      if (bestClassname && this.checkSelector(parentSelector + bestClassname, $el, $dom)) {
        return bestClassname;
      }

      // If all else fails, use the index of the element with respect to the parent
      var domIsNotParent = !$dom || ($parent.get(0) !== $dom.get(0));
      if (!parentSelector && $parent.length && domIsNotParent) {
        parentSelector = this.generateSelector($parent, null, $dom) + this.separator;
        // if no parent - try again with parent
        return parentSelector + this.generateSelector($el, parentSelector, $dom);
      } else {
        // if already have parent - use sibling index
        return selectors.index($el, id || bestClassname || tagname);
      }
    }
  };

  return Selector;

});

define('@qubit---selector@1.1.0', ['@qubit---selector@1.1.0/selector'], function (main) { return main; });

/*
 * in_page
 * by alanclarke
 * Created 2013
 * Copyright (c) Qubit Group Ltd.
 * All rights reserved
 */

define('@qubit---in_page@1.0.6/src/in_page',['require','@qubit/jquery','@qubit/selector'],function (require) {

  var $ = require("@qubit/jquery");
  var Selector = require("@qubit/selector");

  function InPage(options, api) {
    this.api = api;
    this.init(options);
  }

  InPage.prototype = {
    options: {},
    init: function (options) {
      this.model = options.model;
      // http://stackoverflow.com/questions/9542616/div-inside-others-with-margin-top-is-pushing-parents-down
      this.$el = $("<div>&nbsp;</div>");
      this.$dummy = $("<div>&nbsp;</div>").addClass(this.model.get("dummy.className"));
      this.el = this.$el.get(0);
      this.initHelpers();
      this.$window = $(window);
      this.pollCount = 0;
    },
    initHelpers: function () {
      this.selector = new Selector();
    },
    selectEl: function (selector) {
      if (this.$selected) {
        if (this.$selected.is(selector)) {
          return true;
        }
      }
      try {
        // restore style & html
        if (this.$selected) {
          if (this.$selected.html() !== this.$selected.data("deliver-in-page.html")) {
            this.$selected.html(this.$selected.data("deliver-in-page.html") || "");
          }
          this.$selected.attr("style", this.$selected.data("deliver-in-page.attr.style") || "");
        }

        this.$selected = $(selector);

        if (this.$selected.length) {
          this.$selected.find("script").remove();
          // never override the original style

          if (!this.$selected.data("deliver-in-page.attr.style")) {
            this.$selected.data("deliver-in-page.attr.style", this.$selected.attr("style"));
          }

          if (!this.$selected.data("deliver-in-page.html")) {
            this.$selected.data("deliver-in-page.html", this.$selected.html());
          }
        }

        return this.$selected.length;
      } catch (e) {
        return false;
      }
    },
    whenExists: function (cb, failCb) {
      var self = this;
      var complete = document.readyState === "complete";
      this.selectEl(this.model.get("selector"));
      if (this.$selected && this.$selected.length && this.$selected.is(":visible")) {
        this.$el.show();
        cb();
      } else {
        if (complete) {
          this.pollCount++;
          if (typeof failCb === "function" && this.pollCount > 5) {
            return failCb();
          }
        }
        self.timeout = setTimeout(function () {
          self.whenExists(cb, failCb);
        }, this.model.get("pollingFrequency"));
      }
    },
    edit: function () {
      this.$el.hide();
      this.$selected.html(this.model.get("html"));
    },
    applySize: function () {
      if (this.model.get("size")) {
        this.$el.css(this.model.get("size"));
      }
    },
    applyMargin: function () {
      if (this.model.get("margin")) {
        this.$el.css(this.model.get("margin"));
      }
    },
    getCss: function ($el) {
      // get important css attributes from element
      var position = $el.css("position");
      return {
        position: position === "static" ? "relative" : position,
        display: /inline/.test($el.css("display")) ? "inline-block" : "block",
        float: $el.css("float") || "none",
        zIndex: $el.css("zIndex"),
        top: $el.css("top") || 0,
        left: $el.css("left") || 0,
        right: $el.css("right") || 0,
        bottom: $el.css("bottom") || 0,
        margin: $el.css("margin") || 0,
        width: $el.outerWidth(),
        height: $el.outerHeight()
      };
    },
    createContainer: function () {
      var inject = this.model.get("inject");
      if (inject === "edit") {
        return this.edit();
      }

      var css = this.getCss(this.$selected);
      this.$el
        .show()
        .addClass(this.model.get("container.className"))
        .css(css)
        .css(this.model.get("container.css"));

      this.$el[inject === "after" ? "insertAfter" : "insertBefore"](this.$selected);
      if (inject === "replace") {
        this.$selected.hide();
      }

      this.applySize();
      this.applyMargin();
    },
    render: function () {
      var self = this;
      this.$body = $("body").css("margin", 0);
      this.whenExists(function () {
        self.createContainer();
      });
      return this;
    },
    cleanUp: function () {
      this.$el.hide();
      this.$dummy.hide();
      clearTimeout(this.timeout);
      this.pollCount = 0;
      delete this.timeout;
      if (this.$selected) {
        this.$selected.attr("style", this.$selected.data("deliver-in-page.attr.style") || "");
        if (this.$selected.html() !== this.$selected.data("deliver-in-page.html")) {
          this.$selected.html(this.$selected.data("deliver-in-page.html") || "");
        }
        this.$selected.show();
        delete this.$selected;
      }
    },
    close: function (cb) {
      this.remove();
      cb();
    },
    remove: function () {
      this.cleanUp();
      this.selector.destroy();
      this.$el.remove();
      this.$dummy.remove();
    }
  };

  /* Should the container set (and respect) the vm.sliderShowing flag */
  InPage.isExclusive = false;

  return InPage;

});

define('@qubit---in_page@1.0.6', ['@qubit---in_page@1.0.6/src/in_page'], function (main) { return main; });

define('@qubit---attr@1.0.0/attr',['require','@qubit/underscore'],function (require) {

  var _ = require("@qubit/underscore");

  // Get a variable
  return function getVariable(object, path) {
    return _.reduce(path.split("."), function (memo, val) {
      return (memo && memo[val]);
    }, object);
  };
});
define('@qubit---attr@1.0.0', ['@qubit---attr@1.0.0/attr'], function (main) { return main; });

define('@qubit---rephrase@1.0.1/src/index',['require','@qubit/jquery','@qubit/underscore','@qubit/attr'],function (require) {

  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");
  var attr = require("@qubit/attr");

  function Rephrase (options) {
    this.state = options.model;
  }

  // /**
  //  * Render methods
  //  */

  //try an immediate render
  //else try a deferred render
  //else try a body ready render
  //else poll
  Rephrase.prototype.render = function () {
    var self = this;
    if (this.canApplyEdits()) {
      this.applyEdits();
    } else {
      _.defer(function () {
        if (self.canApplyEdits()) {
          self.applyEdits();
        } else {
          $(function  () {
            self.poll();
          });
        }
      });
    }
  };

  Rephrase.prototype.applyEdits = function () {
    this.state.set("edits", this.initEdits(this.state.get("edits")), { silent: true });
    this.renderEdits(this.state.get("edits"));
  };

  Rephrase.prototype.canApplyEdits = function () {
    var edits = this.initEdits(this.state.get("edits"));
    var $dom = $("<body></body>").html($("body").clone().find("script,noscript,style").remove().end().html());
    return !this.renderEdits(edits, $dom);
  };

  Rephrase.prototype.poll = function () {
    var self = this;
    var win, giveup, attempts = 1000;
    this.wait(function () {
      giveup = !(attempts--);
      win = self.canApplyEdits();
      return win || giveup;
    }, function () {
      if (win) {
        //need to reinit $dummy elements
        self.applyEdits();
      }
    });
  };

  //singleton wait method
  Rephrase.prototype.wait = function wait(test, callback) {
    clearTimeout(this.timeout);
    if(test()) {
      callback();
    } else {
      this.timeout = setTimeout(function () {
        wait(test, callback);
      }, 20);
    }
  };

  /** 
   * Render all edits and return first failed edit or null
   */
  Rephrase.prototype.renderEdits = function (edits, $dom) {
    return _.find(edits, function (edit) {
      return !this.renderEdit(edit, $dom);
    }, this);
  };

  Rephrase.prototype.renderEdit = function (edit, $dom) {
    edit = this.addUVs(edit);
    // check if we've already injected the dummy into the dom
    var $el = $(edit.selector, $dom);
    if (!$el.length) {
      return false;
    }
    if (edit.operation === "insertAfter") {
      $el = $el.clone().insertAfter($el);
    }
    $el.html(edit.content)
      .toggle(!edit.hidden);

    if ($.trim(edit.css)) {
      $el.addClass("deliver-rephrase-edit-" + edit.cid);
      $("<style type=\"text/css\" class=\"deliver_reprhase_styles\"></style>").empty()
        .append(edit.css)
        .appendTo($("head", $dom));
    }

    //if element wasn't hidden via toggling, try forcing display: none
    if (edit.hidden && $el.is(":visible")) {
      var style = $el.attr("style")
        .replace(/display:\s?none/gi, "display: none !important");
      $el.attr("style", style);
    }

    return true;
  };

  Rephrase.prototype.initEdits = function (edits) {
    return (edits || []).slice(0);
  };

  Rephrase.prototype.addUVs = function (edit) {
    edit = _.clone(edit);
    if (edit.content && edit.content !== "") {
      var placeholders = edit.content.match(/\{\{([^}]*)\}\}/g);
      if (placeholders) {
        _.each(placeholders, function (placeholder) {
          var data = placeholder.replace(/{|}/g, "");
          if (data.indexOf("universal_variable.") > -1) {
            try {
              var value = attr(window, data);
              if (!_.isArray(value) && !_.isObject(value)) {
                edit.content = edit.content.replace("{{" + data + "}}", value || "");
              }
            } catch (e) {}
          }
        }, this);
      }
    }
    return edit;
  };

  Rephrase.prototype.remove = function () {};

  return Rephrase;
});

define('@qubit---rephrase@1.0.1', ['@qubit---rephrase@1.0.1/src/index'], function (main) { return main; });

define('@qubit---pill-maker@0.1.2/render',['require','@qubit/jquery'],function (require) {
  var $ = require("@qubit/jquery");

  return function (text, iterator) {
    var $text = $("<div>" + text + "</div>");
    $text.find("[data-pill]").each(function (i, pill) {
      var $pill = $(pill);
      var $span = $("<span/>")
        .attr("style", $pill.attr("style") || "")
        .css("display", "inline-block")
        .css("width", "")
        .css("height", "")
        .insertBefore($pill);
      $span.text(iterator($pill.data()));
      $pill.remove();
    });
    return $text.html();
  };
  
});
define('@qubit---textbox@1.0.0/textbox',['require','@qubit/pill-maker/render','@qubit/attr'],function (require) {

  var renderPills = require("@qubit/pill-maker/render");
  var attr = require("@qubit/attr");

  function Textbox(options) {
    this.model = options.model;
    this.el = options.el || document.createElement("div");
  }

  Textbox.prototype.render = function () {
    var contents = renderPills(this.model.get("contents") || "", function (data) {
      return attr(window, data.path) || "-";
    });
    this.el.innerHTML = contents;
    this.el.style.wordWrap = "break-word";
    this.el.style.textShadow = "none";
    return this;
  };

  Textbox.prototype.remove = function () {
    this.el.parentNode.removeChild(this.el);
  };

  return Textbox;
});
define('@qubit---textbox@1.0.0', ['@qubit---textbox@1.0.0/textbox'], function (main) { return main; });

define('@qubit---image@1.0.1/image',[],function () {

  /**
   * Image component
   */

  function Image(options, api) {
    this.options = options;
    this.model = this.options.model;
    this.api = api;
    this.el = document.createElement("img");
    this.el.style.display = "block";

    if (!this.model.get("url")) {
      // we want to show prompt
      api.imageUploader.show();

      api.imageUploader.on("uploaded", function (url) {
        this.model.set("url", url);
        api.imageUploader.off();
      }, this);

      api.imageUploader.on("cancel", function () {
        api.remove();
        api.imageUploader.off();
      }, this);
    }

    this.model.on("change:url", this.render, this);

    if (api.isPreviewMode()) {
      api.panels.register(["image", "click_action"]);
    }
  }

  Image.prototype.render = function () {
    this.el.src = this.model.get("url");
    return this;
  };

  Image.prototype.remove = function () {
    this.el.parentNode.removeChild(this.el);
  };

  return Image;
});
define('@qubit---image@1.0.1', ['@qubit---image@1.0.1/image'], function (main) { return main; });

define('@qubit---close-button@1.0.0/close-button',['require','@qubit/jquery'],function (require) {

  var $ = require("@qubit/jquery");
  function capitalize(s) {
    return s[0].toUpperCase() + s.slice(1);
  }

  /**
   * Close button component
   */
  function CloseButton(options, api) {
    this.initialize(options, api);
    this.setDefaults();
    this.attachEvents();
  }

  CloseButton.prototype.initialize = function (options, api) {
    this.model = options.model;
    this.api = api;

    this.el = document.createElement("a");
    this.$el = $(this.el);
  };

  CloseButton.prototype.setDefaults = function () {
    // default button styling
    if (!this.model.get("style")) {
      this.model.set({
        style: "thick",
        color: "#222",
        width: 20
      });
    }
    if (!this.model.get("click_action.close_duration")) {
      this.model.set("click_action.close_duration", "30");
    }
    if (!this.model.get("click_action.close_duration_unit")) {
      this.model.set("click_action.close_duration_unit", "days");
    }
  };

  CloseButton.prototype.attachEvents = function () {
    this.$el.on("click", $.proxy(this, "handleClick"));
  },

  /**
   * Render method checks which style the button is configured
   * to use (transparent, thin, thick or image) - and then
   * delegates to the specific render method, e.g. renderThick
   */

  CloseButton.prototype.render = function () {
    this.$el.empty();
    this.$el.css({
      textDecoration: "none"
    });
    var style = this.model.get("style");
    if (style) {
      this["render" + capitalize(style)]();
    }
    return this;
  };

  CloseButton.prototype.renderTransparent = function () {
    this.$content = $("<div>", {
      css: {
        cursor: "pointer",
        height: "100%"
      }
    }).appendTo(this.$el);
    if (this.api.isPreviewMode()) {
      this.$content.css({
        outline: "1px dashed #4FB1BA",
        minHeight: "5px"
      });
    }
  };

  CloseButton.prototype.renderThin = function () {
    var width = this.model.get("width");

    // this button is square, so in case the previous
    // button was some other shape, make this square again
    this.model.set("height", width);

    this.$content = $("<div>&times;</div>");
    this.$content.css({
      lineHeight: width + "px",
      cursor: "pointer",
      // different positioning than the Thick button
      // due to differences in Arial and Times New Roman
      // font, but keep the same absolute dimensions
      // i.e. the same amount of overall top/bottom and left
      // margins
      marginLeft: -0.02 * width,
      marginTop: 0.02 * width,
      marginBottom: 0.02 * width,
      fontFamily: "Times New Roman, serif",
      fontSize: width * 1.8 + "px",
      color: this.model.get("color"),
      fontWeight: "normal"
    }).appendTo(this.$el);
  };


  CloseButton.prototype.renderThick = function () {
    var width = this.model.get("width");

    // this button is square, so in case the previous
    // button was some other shape, make this square again
    this.model.set("height", width);

    this.$content = $("<div>&times;</div>");
    this.$content.css({
      lineHeight: width + "px",
      cursor: "pointer",
      marginLeft: -0.02 * width,
      marginTop: 0.04 * width,
      fontFamily: "Arial, sans-serif",
      fontSize: width * 1.8 + "px",
      color: this.model.get("color"),
      fontWeight: "bold"
    }).appendTo(this.$el);
  };

  CloseButton.renderImage = function () {
    var model = this.model;

    var src = model.get("image.src");

    // append the protocol to the image src if required
    if (src.indexOf("data:image") !== 0 &&
        src.indexOf("http://") !== 0 &&
        src.indexOf("https://")) {
      src = location.protocol + src;
    }

    this.$content = $("<img>", {
      attr: {
        src: src
      },
      css: {
        width: "100%",
        // important, because by default images are rendered as inline
        // and have ~margin at the bottom (due to line-height?)
        display: "block"
      }
    }).appendTo(this.$el);
  };

  CloseButton.prototype.remove = function () {
    this.$el.off().remove();
  };

  CloseButton.prototype.handleClick = function () {
    var d = this.model.get("click_action.close_duration");
    var type = this.model.get("click_action.close_duration_unit");
    this.api.layer.close({
      duration: parseInt(d, 10),
      type: type
    });
  };

  return CloseButton;
});
define('@qubit---close-button@1.0.0', ['@qubit---close-button@1.0.0/close-button'], function (main) { return main; });

define('cookieman@1.0.1/lib/get_domains',['require','exports','module'],function (require, exports, module) {module.exports = function getDomains(domain) {
  var domains = [], fragments = domain.split(".");
  var i = 0, l = fragments.length, fragment;
  for (i; i < l - 1; i++) {
    fragment = fragments.slice(i, fragments.length).join(".");
    domains.push(fragment, "." + fragment);
  }
  domains.push(null);
  return domains;
};

});

define('cookieman@1.0.1/lib/get_paths',['require','exports','module'],function (require, exports, module) {module.exports = function getPaths(path) {
  path = path.replace(/\/$/, "").split("/");
  var paths = [], i = 0, l = path.length;
  for (i; i < l; i++) {
    paths.push(path.slice(0, i + 1).join("/") || "/")
  }
  return paths;
};
});

define('cookieman@1.0.1/lib/trim',['require','exports','module'],function (require, exports, module) {module.exports = function (str) {
  return str.replace(/(^\s+|\s+$)/gi, "");
};
});

define('cookieman@1.0.1/lib/cookieman',['require','exports','module','./get_domains','./get_paths','./trim'],function (require, exports, module) {(function() {
  var getDomains = require("./get_domains");
  var getPaths = require("./get_paths");
  var trim = require("./trim");

  /**
   * Get a cookie
   *
   * @public
   * @param {String} name The cookie name
   * @returns {Array} Returns an array of matching cookies
   */
  function getCookie (name) {
    var cookie = [];
    var cookies = getCookies();
    var i = 0, l = cookies.length;
    for (i; i < l; i++) {
      if (cookies[i].name === name) {
        cookie.push(cookies[i]);
      }
    }
    return cookie;
  }

  /**
   * Set a cookie
   *
   * @public
   * @param {String} name The cookie name
   * @param {String} value The cookie value
   * @param {Object} options Optionally set expires, path or cookie domain
   */
  function setCookie(name, value, options) {
    var cookie = name + "=" + value + ";";
    options = options || {};
    if (options.expires) {
      cookie += "Expires=" + options.expires.toUTCString() + ";";
    }
    if (options.path) {
      cookie += "Path=" + options.path + ";";
    }
    if (options.domain) {
      cookie += "Domain=" + options.domain + ";";
    }
    document.cookie = cookie;
  }

  function splitCookie (cookie) {
    var parts = cookie.match(/([^=]+)(?:=([^;]*))?/);
    return parts ? parts.slice(1) : cookie;
  }

  /**
   * Get all cookies
   *
   * @public
   * @returns {Array} Returns the name and value of all available cookies
   */
  function getCookies() {
    if (!document.cookie) {
      return [];
    }
    var allCookies = [], cookie;
    var cookies = document.cookie.split(";");
    var i = 0, l = cookies.length;
    for (i;i < l; i++) {
      cookie = splitCookie(cookies[i]);
      allCookies.push({
        name: trim(cookie[0]),
        value: (cookie[1] && trim(cookie[1])) || null
      });
    }
    return allCookies;
  }

  /**
   * clear first instance of cookie
   *
   * @public
   * @param {String} name The cookie name
   * @param {Object} options Optionally set path or domain of cookie to be cleard
   * @returns {Boolean} Returns a boolean indicating whether the cookie was successfully cleard
   */
  function clearCookie(name, options) {
    var length = getCookies().length;
    options = options || {};
    options.expires = new Date(1);
    setCookie(name, "", options);
    return getCookies().length !== length;
  }

  /**
   * clear all instances of cookie
   *
   * @public
   * @param {String} name The cookie name
   * @returns {Boolean} Returns an array of objects containing the domain and path of any cleard cookies
   */
  function clearAll(name) {
    var d, p, cleard = [];
    var paths = getPaths(window.location.pathname);
    var domains = getDomains(window.location.hostname);

    if (clearCookie(name)) {
      return [{
        path: null,
        domain: null
      }];
    }

    // try deleting on all paths and domains, return the combination that actually works
    for (d = 0; d < domains.length; d++) {
      for (p = 0; p < paths.length; p++) {
        // track cleard cookies
        if (clearCookie(name, {
          path: paths[p],
          domain: domains[d]
        })) {
          cleard.push({
            domain: domains[d],
            path: paths[p]
          });
        }
      }
    }
    return cleard;
  }

  module.exports = {
    'get': getCookie,
    'set': setCookie,
    'cookies': getCookies,
    'clear': clearCookie,
    'clearAll': clearAll
  };

})();

});

define('cookieman@1.0.1', ['cookieman@1.0.1/lib/cookieman'], function (main) { return main; });

define('@qubit---biscotti@2.4.0/lib/session-cookie-index',['require','exports','module','underscore'],function (require, exports, module) {var _ = require('underscore')

/**
 * This defines how values are written to the session cookie.
 * Any change of order will not be backwards compatible so
 * new values should be added to the end of the array.
 * @type {Array}
 */
module.exports = [
  /**
   * Resets at the end of a session.
   */
  {
    name: 'sessionViewNumber',
    getter: getNumber
  },

  /**
   * Set only when a visitor has synchronised
   * this session.
   */
  {
    name: 'visitorIsSynced',
    getter: _.compose(Boolean, Number),
    setter: Number
  }
]

function getNumber (val) {
  return val ? Number(val) : 0
}

});

define('base64int@1.1.0/index',['require','exports','module'],function (require, exports, module) {var base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

module.exports = {
  encode: function encode64(num) {
    return (prefix(num) + map(toBase(Math.abs(num), 64), function (pos) {
      return base64Chars.charAt(pos);
    }).join('')) || base64Chars.charAt(0);
  },
  decode: function decode64(base64) {
    return (prefix(base64) ? -1 : 1) * fromBase(map(base64.replace(/^-/, '').split(''), function (pos) {
      return base64Chars.indexOf(pos);
    }), 64);
  }
};

function fromBase(input, base) {
  var val = 0;
  for (var i = 0; i < input.length; i++) {
    val += Math.pow(base, (input.length - 1) - i) * input[i];
  }
  return val;
}

function prefix(num) {
  if (String(num).charAt(0) === '-') return '-'
  return ''
}

function toBase(value, outputBase) {
  var digits = [];
  while (value > 0) {
    var remainder = value % outputBase;
    digits.unshift(remainder);
    value = (value - remainder) / outputBase;
  }
  return digits;
}

function map(list, it) {
  var vals = [];
  for (var i = 0; i < list.length; i++) {
    vals.push(it(list[i], i));
  }
  return vals;
}

});

define('base64int@1.1.0', ['base64int@1.1.0/index'], function (main) { return main; });

define('@qubit---biscotti@2.4.0/lib/permanent-cookie-index',['require','exports','module','underscore','cookieman','base64int'],function (require, exports, module) {var _ = require('underscore')
var cm = require('cookieman')
var base64Int = require('base64int')

var L1_SEPARATOR = '&'
var L2_SEPARATOR = '='
var PERMANENT_TIME = 1 * (1000 * 60 * 60 * 24 * 365)

/**
 * Do not change without migrating.
 */
var QUBIT_EPOCH_TIME = (2010 - 1970) * (365 * 24 * 60 * 60 * 1000)

/**
 * This defines how values are written to the permanent cookie.
 * Any change of order will not be backwards compatible so
 * new values should be added to the end of the array.
 * @type {Array}
 */
module.exports = [
  /**
   * Never changes.
   */
  {
    name: 'visitorId',
    getter: getLegacyVisitorId,
    setter: setLegacyVisitorId
  },

  /**
   * Increments on a new view.
   */
  {
    name: 'viewNumber',
    getter: getNumber
  },

  /**
   * Resets on a new entrance.
   */
  {
    name: 'entranceViewNumber',
    getter: getNumber
  },

  /**
   * Increments on a new session.
   */
  {
    name: 'sessionNumber',
    getter: getNumber
  },

  /**
   * Increments on a new entrance.
   */
  {
    name: 'entranceNumber',
    getter: getNumber
  },

  /**
   * Increments when a new event is reported.
   */
  {
    name: 'eventNumber',
    getter: getNumber
  },

  /**
   * Stores deliver component expiration timestamps
   * against (experiment id, component id) pairs
   * e.g. experimentId1=componentId1=t1&experimentId1=componentId2=t2 etc
   */
  {
    name: 'deliverCloseTime',
    getter: deliverCloseTimeGetter,
    setter: deliverCloseTimeSetter
  },

  /**
   * Increments on a conversion event.
   */
  {
    name: 'conversionNumber',
    getter: getNumber
  },

  /**
   * Increments on a new conversion cycle.
   */
  {
    name: 'conversionCycleNumber',
    getter: getConversionCycleNumber
  },

  /**
   * The visitor's lifetime value.
   */
  {
    name: 'lifetimeValue',
    getter: getNumber
  },

  /**
   * The first view date for the visitor.
   */
  {
    name: 'firstViewDate',
    getter: getDateToSecond,
    setter: setDateToSecond
  },

  /**
   * The last view date for the visitor.
   */
  {
    name: 'lastViewDate',
    getter: getDateToSecond,
    setter: setDateToSecond
  },

  /**
   * The first conversion date for the visitor.
   */
  {
    name: 'firstConversionDate',
    getter: getDateToSecond,
    setter: setDateToSecond
  },

  /**
   * The last conversion date for the visitor.
   */
  {
    name: 'lastConversionDate',
    getter: getDateToSecond,
    setter: setDateToSecond
  },

  /**
   * The membership engine visitor history.
   */
  {
    name: 'visitorHistory'
  },

  /**
   * The currency of the visitor.
   */
  {
    name: 'currency'
  },

  /**
   * The ip address of the visitor.
   */
  {
    name: 'ipAddress'
  },

  /**
   * The city of the visitor.
   */
  {
    name: 'city'
  },

  /**
   * The city code of the visitor.
   */
  {
    name: 'cityCode'
  },

  /**
   * The country of the visitor.
   */
  {
    name: 'country'
  },

  /**
   * The country code of the visitor.
   */
  {
    name: 'countryCode'
  },

  /**
   * The latitude of the visitor.
   */
  {
    name: 'latitude',
    getter: getNumberOrUndefined
  },

  /**
   * The longitude of the visitor.
   */
  {
    name: 'longitude',
    getter: getNumberOrUndefined
  },

  /**
   * The area of the visitor.
   */
  {
    name: 'area'
  },

  /**
   * The area code of the visitor.
   */
  {
    name: 'areaCode'
  },

  /**
   * The region of the visitor.
   */
  {
    name: 'region'
  },

  /**
   * The region code of the visitor.
   */
  {
    name: 'regionCode'
  }
]

/**
 * Retrieves the raw encoded value of 'deliverCloseTime'
 * from the permanent cookie and converts it into an
 * array of objects containing 'experimentId',
 * 'componentId' and 'expiration' keys (numbers)
 * @param {String} val
 * @return {Array}
 */
function deliverCloseTimeGetter (val) {
  if (!val) {
    return []
  }
  return _.map(val.split(L1_SEPARATOR), function (pairString) {
    var parts = _.map(pairString.split(L2_SEPARATOR), base64Int.decode)
    var minutesSinceQubit = parts[1]
    var unixStamp = decompressTimestamp(minutesSinceQubit, { level: 'minute' })
    return {
      experimentId: parts[0],
      expiration: unixStamp
    }
  })
}

/**
 * Converts an array of objects with keys 'experimentId',
 * 'componentId' and 'expiration' (of number value) into
 * a string (with numbers base64 encoded) that will be saved
 * to the cookie
 * @param {Array} configs
 * @return {String}
 */
function deliverCloseTimeSetter (configs) {
  if (!configs) {
    return ''
  }
  return _.map(configs, formatDeliverCloseCookieString).join(L1_SEPARATOR)

  function formatDeliverCloseCookieString (config) {
    return _.map([
      config.experimentId,
      compressTimestamp(config.expiration, { level: 'minute' })
    ], base64EncodeNumber).join(L2_SEPARATOR)
  }

  function base64EncodeNumber (n) {
    return base64Int.encode(Number(n))
  }
}

function compressTimestamp (timestamp, options) {
  if (options.level === 'minute') {
    return milliToMinutes(toQubitEpochTime(Number(timestamp)))
  }

  function milliToMinutes (ms) {
    return Math.ceil(ms / (1000 * 60))
  }

  function toQubitEpochTime (ms) {
    return ms - QUBIT_EPOCH_TIME
  }
}

function decompressTimestamp (compressed, options) {
  if (options.level === 'minute') {
    return toUnixEpochTime(minutesToMilli(compressed))
  }

  function toUnixEpochTime (qbms) {
    return qbms + QUBIT_EPOCH_TIME
  }

  function minutesToMilli (minutes) {
    return minutes * 1000 * 60
  }
}

function getNumberOrUndefined (val) {
  return !isNaN(Number(val)) ? Number(val) : undefined
}

function getNumber (val) {
  return val ? Number(val) : 0
}

function getConversionCycleNumber (val) {
  return getNumber(val) || 1
}

function getDateToSecond (timestamp) {
  return timestamp ? base64Int.decode(timestamp) * 1000 : undefined
}

function setDateToSecond (timestamp) {
  return timestamp ? base64Int.encode(Math.round(timestamp / 1000)) : ''
}

function getLegacyVisitorId (id) {
  var legacyId = cm.get('_qubitTracker')[0] && cm.get('_qubitTracker')[0].value
  return legacyId || id || undefined
}

function setLegacyVisitorId (id, domain) {
  /**
   * For legacy reasons, the visitor ID is
   * saved and used in the _qubitTracker cookie.
   * The id is also saved in the permanent cookie
   * and should be switched over when QTracker is
   * fully deprecated. This function is not implemented
   * as a setter as it has side affects.
   */
  cm.set('_qubitTracker', id, {
    expires: dateAfterMs(PERMANENT_TIME),
    domain: domain,
    path: '/'
  })
  return id
}

function dateAfterMs (n) {
  var now = new Date().getTime()
  return new Date(now + n)
}

});

define('@qubit---biscotti@2.4.0/lib/biscotti',['require','exports','module','underscore','cookieman','./session-cookie-index','./permanent-cookie-index'],function (require, exports, module) {var _ = require('underscore')
var cm = require('cookieman')

module.exports = function biscotti (domain) {
  return {
    session: createSessionCookie(domain),
    permanent: createPermanentCookie(domain)
  }
}

var SESSION_TIME = 30 * (1000 * 60)
var PERMANENT_TIME = 1 * (1000 * 60 * 60 * 24 * 365)
var SESSION_COOKIE_NAME = 'qb_session'
var PERMANENT_COOKIE_NAME = 'qb_permanent'
var L0_SEPARATOR = ':'

function createSessionCookie (domain) {
  return createCookie(domain, SESSION_COOKIE_NAME, require('./session-cookie-index'), SESSION_TIME)
}

function createPermanentCookie (domain) {
  return createCookie(domain, PERMANENT_COOKIE_NAME, require('./permanent-cookie-index'), PERMANENT_TIME)
}

function createCookie (domain, cookieName, cookieIndex, expireAfter) {
  var qb = (window.__qubit = window.__qubit || {})
  qb.biscottiCache = qb.biscottiCache || {}
  qb.biscottiCache[cookieName] = qb.biscottiCache[cookieName] || getRawCookieList()

  var biscotti = {
    persists: _.memoize(cookiePersists),
    set: set,
    get: get,
    getAll: getAll
  }

  return biscotti

  function set (name, value) {
    var setHash = getAll()
    if (_.isObject(name)) {
      _.extend(setHash, name)
    } else {
      setHash[name] = value
    }

    extendList(getCookieListCache(), toCookieList(cookieIndex, setHash, domain))
    cm.set(cookieName, getCookieListCache().join(L0_SEPARATOR), {
      expires: dateAfterMs(expireAfter),
      domain: domain,
      path: '/'
    })
  }

  function get (name) {
    return getAll()[name]
  }

  function getAll () {
    /**
     * Only use the cache if the cookie does not persist.
     */
    if (biscotti.persists()) {
      qb.biscottiCache[cookieName] = getRawCookieList() || []
    }

    return toCookieHash(cookieIndex, getCookieListCache())
  }

  function getRawCookieList () {
    return getCookie(cookieName) ? getCookie(cookieName).split(L0_SEPARATOR) : []
  }

  /**
   * Checks that cookies persist given the
   * browser settings and the domain set in
   * the options.
   * @return {Boolean} doesPersist
   */
  function cookiePersists () {
    var doesPersist
    setCookie('qb_persist_test', '123', dateAfterMs(expireAfter))
    doesPersist = getCookie('qb_persist_test') === '123'
    clearCookie('qb_persist_test')
    return doesPersist
  }

  /**
   * Sets a cookie given its name, value and
   * expires date. The cookie is always set on
   * the visitor domain and the root path.
   * @param {String}                keyName
   * @param {String|Number|Boolean} value
   * @param {Date}                  expires
   */
  function setCookie (name, value, expires) {
    cm.set(name, value, {
      expires: expires,
      domain: domain,
      path: '/'
    })
  }

  /**
   * Clears the cookie given its name, always
   * using the visitor domain and the root path.
   * @param  {String} keyName
   */
  function clearCookie (name) {
    cm.clear(name, {
      domain: domain,
      path: '/'
    })
  }

  function getCookieListCache () {
    return qb.biscottiCache[cookieName]
  }

}

function dateAfterMs (n) {
  var now = new Date().getTime()
  return new Date(now + n)
}

/**
 * Gets the first occurance of a cookie given
 * its name. Returns undefined if the cookie
 * does not exist.
 * @param  {String}           keyName
 * @return {String|Undefined} value
 */
function getCookie (name) {
  var cookie = cm.get(name)[0]
  if (cookie !== undefined) {
    return cookie.value
  }
}

function toCookieList (cookieIndex, cookieHash, domain) {
  return _.map(cookieIndex, function (cookieDef) {
    var cookieValue = cookieHash[cookieDef.name]
    if (cookieDef.setter) {
      cookieValue = cookieDef.setter(cookieValue, domain)
    }
    return cookieValue
  })
}

function toCookieHash (cookieIndex, cookieList) {
  var cookieHash = {}
  _.each(cookieIndex, function (cookieDef, i) {
    var cookieValue = cookieList[i]
    if (cookieDef.getter) {
      cookieValue = cookieDef.getter(cookieValue)
    }
    cookieHash[cookieDef.name] = cookieValue
  })
  return cookieHash
}

/**
 * Writes a list over a base list. Only the items
 * that are at an index less than the length of
 * base list will be changed. If the list is longer
 * than the base list then the base list will have the
 * extra items appended.
 * @param  {Array} baseList
 * @param  {Array} list
 */
function extendList (baseList, list) {
  _.forEach(list, function (item, index) {
    baseList[index] = item
  })
}

});

define('@qubit---biscotti@2.4.0', ['@qubit---biscotti@2.4.0/lib/biscotti'], function (main) { return main; });

define('@qubit---poller@1.2.7/poller',['require','exports','module','@qubit/jquery','@qubit/underscore','@qubit/attr'],function (require, exports, module) {var $ = require("@qubit/jquery");
var _ = require("@qubit/underscore");
var attr = require("@qubit/attr");

/**
 * Constants - these are not configurable to
 * make polling more efficient by reusing the
 * same global timeout.
 */

var INITIAL_TICK = 50; // The duration of the initial ticks before we start backing off
var INCREASE_RATE = 1.5; // The backoff multiplier
var BACKOFF_THRESHOLD = 5; // How many ticks before we start backing off
var MAX_DURATION = 15000; // How much time before we stop polling completely

/**
 * Globals
 */
var startTime, tickCount, currentTickDelay;
var callbacks = [];
var active = false;

/**
 * Main poller method to register 'targets' to poll for
 * and a callback when all targets validated and complete
 * 'targets' can be one of the following formats:
 *   - a selector string e.g. 'body > span.grid15'
 *   - a window variable formatted as a string e.g. 'window.universal_variable'
 *   - a function which returns a condition for which to stop the polling e.g.
 *     function () {
 *       return $(".some-class").length === 2;
 *     }
 *   - an array of any of the above formats
 */
module.exports = function poller(targets, callback) {
  var callbackItem = createCallbackItem(targets, callback);
  registerCallbackItem(callbackItem);

  // reset state
  startTime = (+new Date());
  tickCount = 0;
  currentTickDelay = INITIAL_TICK;

  // don't start ticking unless current ticking is inactive
  if (!active) {
    active = true;
    tick();
  }

  return callbackItem.cancel;
};

/**
 * A boolean check to see if the poller is currently active
 */
module.exports.isActive = function isActive() {
  return active;
};

/**
 * Loop through all registered callbacks, polling for selectors or executing filter functions
 */
function tick() {
  tickCount += 1;

  var errors = {};
  callbacks = _.filter(callbacks, function (callbackItem) {
    return filterCallbackItem(errors, callbackItem);
  });

  // all poller callbacks have been satisfied
  if (callbacks.length === 0) {
    active = false;
    return;
  }

  // we've reached the max threshold
  if ((+new Date() - startTime) > MAX_DURATION) {
    active = false;
    callbacks = [];
    _.each(errors, function(error, index) {
      console && console.error && console.error("Poller function errored at index " + index + ": " + error);
    });
    return;
  }

  // start increasing tick rate
  if (tickCount > BACKOFF_THRESHOLD) {
    currentTickDelay = currentTickDelay * INCREASE_RATE;
  }

  setTimeout(tick, currentTickDelay);
}

/**
 * Adds callback item to the global array of callbacks
 */
function createCallbackItem(targets, callback) {
  validateInputs(targets, callback);
  if (!_.isArray(targets)) {
    targets = [targets];
  }
  targets = _.compact(targets);
  var callbackItem = {
    targets: targets,
    callback: callback,
    cancel: function () {
      delete callbackItem.callback;
    }
  };
  return callbackItem;
}

/**
 * Register a callback item in the polling
 */
function registerCallbackItem(callbackItem) {
  return callbacks.push(callbackItem);
}

/**
 * Validate the input parameters passed to poller
 */
function validateInputs(targets, callback) {
  if (typeof targets === "number" || typeof targets === "boolean") {
    throw new Error([
      "Expected first argument to be selector string",
      "or array containing selectors, window variables or functions."
    ].join(" "));
  }

  if (typeof callback !== "function") {
    throw new Error("Expected second argument to be a callback function.");
  }
}

/**
 * Filter callback item based on the polling validation each of the specified polling
 * targets (selectors, window vars or functions). If the callback item passes the
 * validation then it's success callback is fired.
 */
function filterCallbackItem(errors, item) {
  var targets = item.targets;
  var cb = item.callback;

  // If the item has been cancelled, we want to remove
  // it from the polling chain
  if (!cb) {
    return false;
  }

  for (var index = 0; index < targets.length; index++) {
    var target = targets[index];
    if (typeof target === "function") {
      try {
        if (!target()) {
          return true;
        }
      } catch (err) {
        errors[index] = err.stack;
        return true;
      }
    } else if (target.indexOf("window.") === 0) {
      if (typeof attr(window, target) === "undefined") {
        return true;
      }
    } else if ($(target).length === 0) {
      return true;
    }
  }

  setTimeout(cb, 0);
  return false;
}

});

define('@qubit---poller@1.2.7', ['@qubit---poller@1.2.7/poller'], function (main) { return main; });

define('@qubit---layer@2.20.41/lib/lib/timeout',['require','exports','module'],function (require, exports, module) {module.exports = function timeout(done, duration) {
  var alreadyCalled = false;

  var t = setTimeout(function () {
    callDone(true);
  }, duration);

  function c() {
    callDone(false);
  }

  c.cancel = function () {
    clearTimeout(t);
  };

  return c;

  function callDone(timedOut) {
    if (!alreadyCalled) {
      alreadyCalled = true;
      done({timedOut: timedOut});
    }
  }
};

});

define('@qubit---layer@2.20.41/lib/lib/closing',['require','@qubit/underscore'],function (require) {

  var _ = require("@qubit/underscore");

  /**
   * Given a options object
   *  (
   *    biscotti,
   *    componentWrapperView,
   *    closeDuration,
   *    experimentId,
   *    isPreviewMode
   *  )
   *  call the 'close' method on the componentWrapperView
   *  (which calls the component's custom 'componentWillClose' method)
   *  and if we are not in preview mode, store the component's
   *  expiration date in a cookie using the biscotti API
   */

  function close (options) {
    var biscotti = options.biscotti;
    var componentWrapperView = options.outermostComponentWrapperView;

    // Don't store component expiration if there is
    // no close duration specified or we are previewing
    if (!options.closeDuration || options.isPreviewMode) {
      removeComponentWithChildren();
      return;
    }

    // store the expiration first, in case removal throws,
    // we're better off if we managed to store the cookie
    storeComponentExpiration({
      experimentId: options.experimentId,
      expiration: new Date().getTime() + options.closeDuration
    });

    removeComponentWithChildren();

    function storeComponentExpiration(closeConfig) {
      var expirationTimes = biscotti.permanent.get("deliverCloseTime");
      // clean up the cookie just in case, to not
      // have duplicate experiments in there
      expirationTimes = _.reject(expirationTimes, function (config) {
        return config.experimentId === closeConfig.experimentId;
      });
      expirationTimes.push(closeConfig);
      biscotti.permanent.set("deliverCloseTime", expirationTimes);
    }

    function removeComponentWithChildren() {
      componentWrapperView.close(function () {
        var childrenComponentModels = options.componentCollection.getAllChildren(componentWrapperView.model);
        var childrenComponentIds = _.pluck(childrenComponentModels, "id").reverse();
        _.each(options.componentWrapperViews, function (componentWrapperView) {
          if (_.contains(childrenComponentIds, componentWrapperView.model.id)) {
            componentWrapperView.remove();
          }
        });
      });
    }
  }

  function isClosed (biscotti, experimentId) {
    var componentExpirations = biscotti.permanent.get("deliverCloseTime");
    var closedComponentConfig = _.findWhere(componentExpirations, {experimentId: experimentId});
    if (closedComponentConfig) {
      if (new Date().getTime() >= closedComponentConfig.expiration) {
        // Close time has expired so remove it from the permanent cookie
        var nextCookie = _.without(componentExpirations, closedComponentConfig);
        biscotti.permanent.set("deliverCloseTime", nextCookie);
      } else {
        return closedComponentConfig.expiration;
      }
    }

    return false;
  }

  return {
    close: close,
    isClosed: isClosed
  };
});

define('@qubit---layer@2.20.41/lib/constants/cx',['require','exports','module','@qubit/underscore'],function (require, exports, module) {var _ = require("@qubit/underscore");

/**
 * For the most part, we try to adhere to the SuitCSS naming
 * conventions. However layer is not just about components,
 * therefore we have several special classes that don't
 * conform to the SuitCSS naming.
 *
 * For example, deliver-component, deliver-allowChildren,
 * deliver-editorElement are cross component concern classes.
 * They're not modifiers, they're not states. They're special
 * classes that can appear in many places. They have a special
 * meaning outside of styling. They're "globals" within the
 * "deliver" namespace.
 */

var deliverNamespace = "deliver-";
var deliverDomNamespace = "deliver-dom-";

/**
 * All core class names used within layer
 */
var coreClassNames = {
  // component classes
  COMPONENT: "component",
  COMPONENT_SELECTED: "is-selected",
  COMPONENT_IN_TRANSIT: "is-inTransit",
  COMPONENT_IS_BODY_PLACEMENT: "is-bodyPlacement",

  // tool classes
  EDITOR_TOOL_IFRAME: "EditorToolView",
  EDITOR_TOOL_WRAPPER: "EditorToolWrapper",

  TOOLS_IFRAME: "ToolsIframe",
  TOOLS: "Tools",
  TOOLS_TITLE: "Tools-title",
  TOOLS_LIST: "Tools-list",
  TOOLS_LIST_ITEM: "Tools-listItem",
  TOOLS_TOOL: "Tools-tool",
  TOOLS_OPTIONS_TOGGLE: "Tools-optionsToggle",

  TOOLS_DROPDOWN_IFRAME: "DropdownIframe",
  TOOLS_DROPDOWN: "ToolsDropdown",
  TOOLS_DROPDOWN_OPTION: "ToolsDropdown-option",

  // a className to be given to DOM elements that
  // shouldn't be highlighted with the element
  // highlighter
  PICKER_IGNORE: "ignoreWithPicker",

  // a className that can mark elements
  // as not valid targets for targeting components
  // against. Also these elements will be removed
  // temporarily everytime we're computing selectors.
  EDITOR_ELEMENT: "editorElement",

  // a class that makes elements nestable,
  // i.e. other components can be dropped into
  // such elements
  ALLOW_CHILDREN: "allowChildren",
  ALLOW_CHILDREN_NO_TEXT: "allowChildren--noText",

  // outlines
  HOVER_OUTLINE: "HoverOutline",
  SELECT_OUTLINE: "SelectOutline",
  ELEMENT_HOVER_OUTLINE: "ElementHoverOutline",

  // insert guide
  INSERT_GUIDE: "InsertGuide",

  // advanced mode classes
  ADVANCED_STYLES: "AdvancedStyles"
};

/**
 * All classes we add to DOM elements in the editor
 * unrelated to our extra tools
 */
var domClassNames = {
  // element classes
  ELEMENT_TRANSLUCENT: "is-translucent",

  // body classes
  IS_EDITOR: "is-editor",
  IS_PLACING: "is-placing"
};

/**
 * Add some extras/conveniences to the exported object
 */
function classConstants() {
  var cx = {};

  cx.deliverNamespace = deliverNamespace;
  cx.deliverDomNamespace = deliverDomNamespace;

  var namespacedCoreClassNames = explode(coreClassNames, deliverNamespace);
  var namespacedDomClassNames = explode(domClassNames, deliverDomNamespace);

  _.extend(cx, namespacedCoreClassNames, namespacedDomClassNames);

  // classes we can use for selector generation
  cx.selectorSafe = [
    namespacedCoreClassNames.COMPONENT
  ];

  // classes we can't use for selector generation
  cx.selectorUnsafe = computeUnsafeSelectors(namespacedCoreClassNames, namespacedDomClassNames, cx.selectorSafe);

  cx.set = set;

  return cx;
}

function explode (classNames, namespace) {
  return _.reduce(classNames, function (memo, className, key) {
    var nameSpacedClass = namespace + className;
    memo[key] = nameSpacedClass;
    memo["$" + key] = "." + nameSpacedClass;
    return memo;
  }, {});
}

function computeUnsafeSelectors(core, dom, safe) {
  return _.difference(names(core).concat(names(dom)), safe);
  function names(obj) {
    return _.filter(obj, function (str) {
      return str[0] !== ".";
    });
  }
}

/**
 * a helper function for converting an array of classNames
 * into space separated className string
 */
function set () {
  return _.unique(_.toArray(arguments)).join(" ");
}

module.exports = classConstants();

});

define('@qubit---layer@2.20.41/lib/should_activate',['require','exports','module','@qubit/jquery','@qubit/underscore','@qubit/biscotti','@qubit/poller','./lib/timeout','./lib/closing','./constants/cx'],function (require, exports, module) {var $ = require("@qubit/jquery");
var _ = require("@qubit/underscore");
var createBiscotti = require("@qubit/biscotti");
var poller = require("@qubit/poller");
var timeout = require("./lib/timeout");
var isClosed = require("./lib/closing").isClosed;
var cx = require("./constants/cx");

module.exports = function createShouldActivate(config) {
  config = config || {};
  return function shouldActivate(options, cb) {
    var componentActivations = options.componentActivations || [];

    if (!config.skipClosedCheck) {
      var biscotti = options.biscotti || createBiscotti(options.meta.cookieDomain);
      var closedUntil = isClosed(biscotti, options.meta.experimentId);
      if (closedUntil) {
        return cb(false, "Experiment has been closed until " + new Date(closedUntil).toISOString());
      }
    }

    var onPollComplete = options.timeout
      ? timeout(validateSelectors, options.timeout)
      : validateSelectors;
    // Ensure that all of the elements that this variation,
    // as well as all other variations of this experimeent
    // are targeting are on the current page, before we
    // consider this layer eligible to activate
    var cancel = poller(options.selectorsToPoll || [], onPollComplete);

    return function cancelPolling() {
      cancel();
      if (onPollComplete.cancel) {
        onPollComplete.cancel();
      }
    };

    function validateSelectors(status) {
      if (status && status.timedOut) {
        return cb(false, "Polling for elements timed out");
      }
      // Once we found all the elements, let's validate
      // that they're unique and are not occupied
      if (allSelectorsValid(options.selectorsToPoll)) {
        checkComponentActivations({}, componentActivations, function (reason) {
          if (reason) {
            cb(false, reason);
          } else {
            cb(true);
          }
        });
      } else {
        cb(false, "Selectors for this layer are already occupied or match multiple elements.");
      }
    }
  };
};

/**
 * Check all component activations for this layer in async sequence
 */
function checkComponentActivations(options, componentActivations, cb) {
  checkComponentActivation(0);

  function checkComponentActivation(index) {
    if (index === componentActivations.length) {
      cb(null);
      return;
    }
    var componentActivation = componentActivations[index];
    if (componentActivation.shouldActivate) {
      try {
        componentActivation.shouldActivate(options, function (shouldActivate, reason) {
          if (shouldActivate) {
            checkComponentActivation(index + 1);
          } else {
            cb("Component activation failed: " + reason);
          }
        });
      } catch (e) {
        cb("Error in component activation: " + e.message);
      }
    } else {
      checkComponentActivation(index + 1);
    }
  }
}

/**
 * And that they are unique and not inside of another component that has already been rendered
 * Or, the element's next sibling isn't a Mimic component!
 */
function allSelectorsValid(selectors) {
  return _.every(selectors, function(sel) {
    var $el = $(sel);
    return (
      $el.length === 1 &&
      $el.closest(cx.COMPONENT).length === 0 &&
      // TODO consider checking for something like
      // deliver-component-target and marking up all targets
      // within layer - in other words, we stop relying on Mimic
      // className
      !$el.next().hasClass("deliver-component-Mimic")
    );
  });
}

});

define('@qubit---layer@2.20.41/lib/models/base_model',['require','@qubit/backbone-deep-model'],function (require) {

  var DeepModel = require("@qubit/backbone-deep-model");

  return DeepModel.extend({});
});
define('@qubit---layer@2.20.41/lib/models/component_model',['require','./base_model'],function (require) {

  var BaseModel = require("./base_model");

  return BaseModel.extend({
    getPlacement: function () {
      if (this.get("selector") === "body") {
        return "body";
      } else {
        return "inline";
      }
    }
  });
});
define('@qubit---layer@2.20.41/lib/models/component_collection',['require','@qubit/underscore','@qubit/backbone','./component_model'],function (require) {
  var _ = require("@qubit/underscore");
  var Backbone = require("@qubit/backbone");

  return Backbone.Collection.extend({
    model: require("./component_model"),

    update: function (attr, options) {
      this.get(attr.id).set(attr, options);
    },

    removeWithChildren: function (models, options) {
      models = _.isArray(models) ? models : [models];
      models = _.flatten(_.map(models, this.getAllChildren));
      // remove in reverse-render order so that
      // on each view removal the remaining views
      // can be re-rendered properly without error
      models = _.sortBy(models, function (model) {
        return -model.get("seq");
      });
      this.remove(models, options || {});
      return models;
    },

    getAllChildren: function (model) {
      // we'll store all children including model here
      // we store models by id here to avoid recursing
      // into models that have already been merged
      var children = {};
      children[model.id] = model;

      var byParentId = model.collection.groupBy("parentId");
      // remove the models that have no parents, which means
      // they're also not children of any other model
      delete byParentId["undefined"];
      delete byParentId["false"];

      // start recursing
      mergeChildren(model);

      // return an array of models
      return _.values(children);

      function mergeChildren(model) {
        var c = byParentId[model.id];
        _.each(c, function (child) {
          // stop infinite recursion by checking if
          // we already have processed this model
          if (!children[child.id]) {
            children[child.id] = child;
            mergeChildren(child);
          }
        });
      }
    }
  });

});

define('@qubit---layer@2.20.41/lib/advanced/advanced_mode',['require','@qubit/jquery','../constants/cx'],function (require) {
  var $ = require("@qubit/jquery");
  var cx = require("../constants/cx");

  function AdvancedMode(options) {
    this.initialize(options);
  }

  AdvancedMode.prototype.initialize = function (options) {
    this.options = options;
    this.exec();
  };

  AdvancedMode.prototype.update = function (options) {
    this.options = options;
    this.exec();
  };

  AdvancedMode.prototype.escape = function (text) {
    return text
        .replace("\\", "\x5C")
        .replace("\"", "\x22")
        .replace("'", "\x27")
        .replace("\n", "\x0A");
  };

  AdvancedMode.prototype.exec = function () {
    if (this.options && this.options.code) {

      // Many advanced tests access require using 'require' rather than through the global route
      // so here we replicate this functionality by creating a new closure with require available.
      // 'Global' JS also no longer executes on the window scope so it is not a problem to wrap it up
      // in another closure.
      var code = "(function () { var require = window.__qubit.amd.require;";
      code += this.options.globalCode || "";
      code += ";\n(" + this.options.code + ")();";
      code += "}());";

      var escapedCode = this.escape(code);

      try {
        this.applyStyles();
        $.globalEval(escapedCode);
      } catch (e) { }
    }
  };

  AdvancedMode.prototype.applyStyles = function (styles) {
    styles = styles || this.options.styles;
    styles && this._addStyleSheet(styles);
  };

  AdvancedMode.prototype._addStyleSheet = function (css) {
    var head = document.getElementsByTagName("head")[0];
    var el = document.createElement("style");
    el.setAttribute("type", "text/css");
    el.setAttribute("class", cx.ADVANCED_STYLES);
    if (el.styleSheet) {
      el.styleSheet.cssText = css;
    } else {
      el.appendChild(document.createTextNode(css));
    }
    head.appendChild(el);
  };

  return AdvancedMode;
});
define('@qubit---css@0.1.6/normalize',{});
define('@qubit---css@0.1.6/css',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define('@qubit---css@0.1.6', ['@qubit---css@0.1.6/css'], function (main) { return main; });


define('@qubit---css@0.1.6/css!@qubit---layer@2.20.41/lib/composer/styles/composer',[],function(){});
define('@qubit---backbone-model-cursor@1.1.0/cursor',['require','exports','module'],function (require, exports, module) {var CURSOR_SYMBOL = {};

module.exports = function (model, cursorKey, options) {
  options = options || {};
  var handlers = [];
  var Model = options.modelClass || model.constructor;
  // the attributes are deep cloned when instantiating a new
  // deep model so this bit is safe
  var submodel = new Model(model.get(cursorKey));
  sync(model, submodel, "down");
  sync(model, submodel, "up");
  submodel.cursor = {};
  submodel.cursor.destroy = function () {
    removeListeners(model);
    removeListeners(submodel);
  };

  function sync(m1, m2, direction) {
    var changeKey, source, sink;
    if (direction === "down") {
      changeKey = "change:" + cursorKey + ".*";
      source = m1;
      sink = m2;
    } else {
      changeKey = "change";
      source = m2;
      sink = m1;
    }

    handlers.push(onChange);
    handlers.push(onRemove);

    source.on(changeKey, onChange);
    source.on("remove", onRemove);

    function onChange(model, value, options) {
      var changedAttributes;

      if (changeKey === "change") {
        options = value;
      }
      
      if (options.cursor === CURSOR_SYMBOL) {
        return;
      }

      if (options.unset) {
        changedAttributes = model.changedAttributes()
        if (direction === "down") {
          unsetAll(sink, changedAttributes, function (attr) {
            // since we're syncing down, convert
            // "cursorKey.foo.bar" to "foo.bar"
            return attr.slice(cursorKey.length + 1);
          });
        } else {
          unsetAll(sink, changedAttributes, function (attr) {
            // since we're syncing up, convert
            // "foo.bar" to "cursorKey.foo.bar"
            return cursorKey + "." + attr;
          });
        }
      } else {
        // set deep clones attributes so we don't pass on
        // any objects by reference here
        if (direction === "down") {
          sink.set(source.get(cursorKey), opt());
        } else {
          sink.set(cursorKey, source.toJSON(), opt());
        }
      }
    }

    function onRemove() {
      removeListeners(m1);
      removeListeners(m2);
    }

    function opt() {
      return {
        cursor: CURSOR_SYMBOL
      };
    }
  }

  function unsetAll(model, attributes, transformKey) {
    var attr;
    for (attr in attributes) {
      if (attributes.hasOwnProperty(attr)) {
        if (attributes[attr] === undefined) {
          model.unset(transformKey(attr));
        }
      }
    }
  }

  function removeListeners(model) {
    // remove handlers on both sources and sinks
    handlers.forEach(function (handler) {
      model.off("change:" + cursorKey + ".*", handler);
      model.off("change", handler);
      model.off("remove", handler);
    });
  }

  return submodel;
};
});

define('@qubit---backbone-model-cursor@1.1.0', ['@qubit---backbone-model-cursor@1.1.0/cursor'], function (main) { return main; });

define('@qubit---layer@2.20.41/lib/api/component_prod_api',['require','@qubit/jquery','@qubit/underscore'],function (require) {
  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");

  /**
   * Component's (and Container's) Production API
   */

  return function makeComponentAPI(model, actions) {

    var componentAPI = {
      id: model.id,

      inEditor: function () {
        return false;
      },

      getTargetEl: function () {
        return $(model.get("selector")).get(0);
      },

      getChildrenIds: function () {
        var childModels = model.collection.where({parentId: model.id});
        return _.pluck(childModels, "id");
      },

      /**
       * Closes the outermost parent component (self-inclusive)
       * for a specified amount of milliseconds
       *
       * E.g. closeDuration could be 2days = (2 * 24 * 60 * 60 * 1000)ms
       */
      close: function (closeDuration) {
        return actions.close(closeDuration);
      }
    };

    return {
      "public": componentAPI,
      destroy: function () {}
    };
  };
});

define('@qubit---layer@2.20.41/lib/wrapper/component_wrapper_view',['require','@qubit/backbone','../constants/cx'],function (require) {

  var Backbone = require("@qubit/backbone");
  var cx = require("../constants/cx");

  return Backbone.View.extend({

    initialize: function (options) {
      this.options = options || {};
      this.api = this.options.api;
      this.setElement(this.options.componentView.el);
    },

    componentWillMount: function () {
      if (this.options.componentView.componentWillMount) {
        this.options.componentView.componentWillMount();
      }
    },

    render: function () {
      var uid = this.model.get("uid");
      if (uid) {
        this.$el.attr("id", "deliver-component-" + uid);
      }
      this.$el.addClass(cx.COMPONENT)
        .addClass(cx.COMPONENT + "-i" + this.model.id)
        .data("deliver-component-id", this.model.id);
      this.options.componentView.render();
      return this;
    },

    componentDidMount: function () {
      if (this.options.componentView.componentDidMount) {
        this.options.componentView.componentDidMount();
      }
    },

    close: function (cb) {
      if (this.options.componentView.componentWillClose) {
        this.options.componentView.componentWillClose(function () {
          cb();
        });
      } else {
        cb();
      }
    },

    remove: function () {
      this.options.componentView.remove();
      this.$el.remove();
      this.api.destroy();
    }

  });

});

define('@qubit---layer@2.20.41/lib/composer/meta',['require','exports','module'],function (require, exports, module) {module.exports = function createMeta(meta) {
  return {
    // NEW API
    trackingId: meta.trackingId,
    cookieDomain: meta.cookieDomain,
    experimentId: meta.experimentId,
    iterationId: meta.iterationId,
    variationId: meta.variationId,
    variationMasterId: meta.variationMasterId,
    // OLD, DEPRECATED API
    property: {
      trackingId: meta.trackingId,
      cookieDomain: meta.cookieDomain
    },
    experiment: {
      experimentId: meta.experimentId,
      iterationId: meta.iterationId,
      variationId: meta.variationId,
      variationMasterId: meta.variationMasterId
    }
  };
};
});

define('@qubit---layer@2.20.41/lib/composer/composer',['require','css!./styles/composer','@qubit/jquery','@qubit/underscore','@qubit/backbone-model-cursor','../api/component_prod_api','../wrapper/component_wrapper_view','../lib/closing','./meta'],function (require) {

  require("css!./styles/composer");
  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");
  var cursor = require("@qubit/backbone-model-cursor");
  var makeComponentAPI = require("../api/component_prod_api");
  var ComponentWrapperView = require("../wrapper/component_wrapper_view");
  var closeComponent = require("../lib/closing").close;
  var meta = require("./meta");

  function Composer(options) {
    this.options = options;
    this.require = options.require;
  }

  Composer.prototype.compose = function () {
    this.components = this.options.componentCollection.map(this.createComponent, this);
    this.render();
    return this;
  };

  Composer.prototype.render = function () {
    inSequence(this.components, this.renderComponent, this);
    return this;
  };

  /**
   * Like render, but only ensures that component is in the correct
   * position in the DOM, without calling component.render() method
   * @return {[type]} [description]
   */
  Composer.prototype.reposition = function () {
    inSequence(this.components, function (component) {
      this.renderComponent(component, {
        positionOnly: true
      });
    }, this);
    return this;
  };

  Composer.prototype.renderComponent = function (component, options) {
    options = options || {};
    if (!options.positionOnly) {
      component.componentWillMount();
      component.render();
    }

    var injector = component.model.get("injector");
    var $target = $(component.model.get("selector"));

    if (injector === "target") {
      $target.data("deliver-target", component.model.id);
      $target.after(component.el);
    } else {
      $target[injector](component.el);
    }

    if (!options.positionOnly) {
      component.componentDidMount();
    }
    return component;
  };

  Composer.prototype.createComponent = function (componentModel) {
    var self = this;
    var api = makeComponentAPI(componentModel, {
      close: function (closeDuration) {
        closeComponent({
          closeDuration: closeDuration,
          biscotti: self.options.biscotti,
          experimentId: self.options.meta.experimentId,
          isPreviewMode: self.options.isPreviewMode,
          outermostComponentWrapperView: self.getOutermostComponentWrapperView(componentModel),
          componentCollection: self.options.componentCollection,
          componentWrapperViews: self.components
        });
      }
    });
    var componentView = this.create(componentModel.get("type"), {
      model: cursor(componentModel, "settings"),
      uiState: cursor(componentModel, "uiState"),
      api: api["public"],
      meta: meta(this.options.meta)
    });
    return new ComponentWrapperView({
      componentView: componentView,
      model: componentModel,
      api: api
    });
  };

  Composer.prototype.create = function (objectType, options, api) {
    return new (this.require(objectType))(options, api);
  };

  Composer.prototype.destroy = function () {
    if (this.components && this.components.length) {
      _.invoke(this.components, "remove", this);
    }
  };

  Composer.prototype.getOutermostComponentWrapperView = function (componentModel) {
    while (componentModel.get("parentId")) {
      componentModel = componentModel.collection.get(componentModel.get("parentId"));
    }
    return _.findWhere(this.components, {model: componentModel});
  };

  function inSequence(components, fn, context) {
    components = _.sortBy(components, function (component) {
      return component.model.get("seq");
    });
    _.each(components, fn, context);
  }

  return Composer;

});

define('@qubit---layer@2.20.41/lib/layer',['require','@qubit/underscore','@qubit/emitter','@qubit/biscotti','./should_activate','./models/component_collection','./advanced/advanced_mode','./composer/composer'],function (require) {

  var _ = require("@qubit/underscore");
  var emitter = require("@qubit/emitter");
  var createBiscotti = require("@qubit/biscotti");
  var createShouldActivate = require("./should_activate");
  var ComponentCollection = require("./models/component_collection");
  var AdvancedMode = require("./advanced/advanced_mode");
  var Composer = require("./composer/composer");

  function Layer() {
    this.initialize.apply(this, arguments);
  }

  Layer.shouldActivate = createShouldActivate();

  /**
   * This is used in conjunction with shouldActivate
   * from within smartserve.js
   */
  Layer.getSelectorsToPoll = function (components) {
    return _.pluck(_.filter(components, function(component) {
      return component.targetsPageElement;
    }), "selector");
  };

  Layer.isExclusive = function (options) {
    options = options || {};
    return !!_.find(options.components, function (component) {
      return component.isExclusive;
    });
  };

  // this is so that we could use this.listenTo
  emitter(Layer.prototype);

  Layer.prototype.getAdvancedModeClass = function () {
    return AdvancedMode;
  };

  Layer.prototype.getComposerClass = function () {
    return Composer;
  };

  Layer.prototype.initialize = function (deliver, options) {
    this.deliver = deliver;
    this.options = options;
    this.options.meta = this.options.meta || {};

    this.biscotti = this.options.biscotti || createBiscotti(this.options.meta.cookieDomain);

    // advanced mode does not require to create all other components
    if (this.isAdvancedMode()) {
      this.advancedMode = new (this.getAdvancedModeClass())(options.advanced);
    } else {
      this.createModels(options);
    }
  };

  /**
   * This method only exists to support the current version
   * of smartserve generator.
   */
  Layer.prototype.isExclusive = function () {
    return false;
  };

  Layer.prototype.isPreviewMode = function () {
    return this.options.isPreviewMode;
  };

  Layer.prototype.run = function () {
    if (!this.isAdvancedMode()) {
      this.compose();
    }
  };

  Layer.prototype.require = function (moduleId) {
    return this.options.modules[moduleId];
  };

  Layer.prototype.compose = function () {
    var self = this;
    this.composer = new (this.getComposerClass())({
      componentCollection: this.componentCollection,
      deliver: this.deliver,
      meta: this.options.meta,
      isPreviewMode: self.isPreviewMode(),
      require: function (moduleId) {
        return self.require(moduleId);
      },
      pkgMetas: this.options.pkgMetas,
      biscotti: this.biscotti
    });
    this.composer.compose();
  };

  Layer.prototype.isAdvancedMode = function () {
    return this.options && this.options.advanced && this.options.advanced.enabled;
  };

  Layer.prototype.createModels = function (options) {
    this.componentCollection = new ComponentCollection(options.components);
  };

  Layer.prototype.destroy = function () {
    if (this.composer) {
      this.composer.destroy();
    }
  };

  return Layer;

});

define('@qubit---layer@2.20.41', ['@qubit---layer@2.20.41/lib/layer'], function (main) { return main; });


define('@qubit---css@0.1.6/css!@qubit---textbox@2.4.12/styles',[],function(){});
define('@qubit---textbox@2.4.12/textbox',['require','@qubit/jquery','css!./styles'],function (require) {

  var $ = require("@qubit/jquery");

  require("css!./styles");

  function Textbox(options) {
    this.model = options.model;
    this.el = options.el || document.createElement("div");
    $(this.el).addClass("deliver-component-Textbox");
  }

  Textbox.prototype.render = function () {
    this.el.innerHTML = this.model.get("contents");
    this.applyCss();
    return this;
  };

  Textbox.prototype.applyCss = function () {
    var css = this.model.get("css");
    if (css) $(this.el).css(this.model.get("css"));
  };

  Textbox.prototype.remove = function () {
    this.el.parentNode.removeChild(this.el);
  };

  return Textbox;

});

define('@qubit---textbox@2.4.12', ['@qubit---textbox@2.4.12/textbox'], function (main) { return main; });


define('@qubit---css@0.1.6/css!@qubit---block@1.5.8/styles',[],function(){});
define('@qubit---block@1.5.8/block',['require','css!./styles','@qubit/jquery','@qubit/underscore'],function (require) {

  require("css!./styles");
  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");

  function Block(options) {
    options = options || {};
    this.model = options.model;
    this.setDefaults();
    this.el = options.el || document.createElement("div");
    this.$el = $(this.el).addClass("deliver-component-Block deliver-allowChildren");
  }

  Block.prototype.setDefaults = function () {
    var model = this.model;
    var defaults = {
      paddingTop: "10px",
      paddingBottom: "10px",
      paddingLeft: "10px",
      paddingRight: "10px"
    };
    // Set defaults
    _.each(defaults, function (val, key) {
      if (!model.get("css." + key)) model.set("css." + key, val);
    });
  };

  Block.prototype.render = function () {
    var cssAttrs = this.model.get("css");
    if (cssAttrs) $(this.el).css(cssAttrs);
  };

  Block.prototype.remove = function () {
    this.$el.remove();
  };

  return Block;

});

define('@qubit---block@1.5.8', ['@qubit---block@1.5.8/block'], function (main) { return main; });

define('@qubit---vanish@1.0.0/index',['require','exports','module','@qubit/jquery'],function (require, exports, module) {var $ = require("@qubit/jquery");

function Vanish() {
  this.initialize.apply(this, arguments);
}

Vanish.prototype.initialize = function (options) {
  options = options || {};
  this.model = options.model;
  this.api = options.api;
  this.el = options.el || document.createElement("div");
  this.el.className = "deliver-component-Vanish";
  this.el.style.display = "none";
  this.el.style.visibility = "hidden";
};

Vanish.prototype.remove = function () {
  this.$target.show();
};

Vanish.prototype.render = function () {
  this.setTarget(this.api.getTargetEl());
};

Vanish.prototype.componentDidMount = function () {
  this.$target.hide();
};

Vanish.prototype.setTarget = function (target) {
  this.$target = $(target);
};

module.exports = Vanish;

});

define('@qubit---vanish@1.0.0', ['@qubit---vanish@1.0.0/index'], function (main) { return main; });

define('@qubit---mimic@1.3.15/lib/assume',['require','exports','module'],function (require, exports, module) {/**
 * Make $el assume the styles / dimensions of $target
 */
module.exports = function assume($mime, $target) {
  var styles = getInlineStyles($target);
  $mime.css(styles);
  return styles;
};

function getInlineStyles($el) {
  var position = $el.css("position");
  var display = $el.css("display");
  var styles = {
    position: position === "static" ? "relative" : position,
    display: display === "block" ? "block" : "inline-block",
    clear: $el.css("clear") || "none",
    fontSize: $el.css("font-size"),
    fontFamily: $el.css("font-family"),
    fontWeight: $el.css("font-weight"),
    textDecoration: $el.css("text-decoration"),
    lineHeight: $el.css("line-height"),
    "float": $el.css("float") || "none",
    zIndex: $el.css("zIndex"),
    top: $el.css("top") || 0,
    left: $el.css("left") || 0,
    right: $el.css("right") || 0,
    bottom: $el.css("bottom") || 0,
    margin: $el.css("margin"),
    padding: $el.css("padding"),
    width: getDimension($el, "width"),
    height: getDimension($el, "height"),
    transform: $el.css("transform")
  };
  return styles;
}

function getDimension($el, dim) {
  var boundingRect = getBoundingClientRect($el);
  return $el.get(0).style[dim] ||
    (boundingRect[dim] ? Math.floor(boundingRect[dim]) + "px" : $el.css(dim));
}

function getBoundingClientRect($el) {
  var el = $el.get(0);
  return el ? el.getBoundingClientRect() : {};
}

});


define('@qubit---css@0.1.6/css!@qubit---mimic@1.3.15/styles',[],function(){});
define('@qubit---mimic@1.3.15/mimic',['require','exports','module','@qubit/jquery','./lib/assume','css!./styles'],function (require, exports, module) {var $ = require("@qubit/jquery");
var assume = require("./lib/assume");

require("css!./styles");

function Mimic() {
  this.initialize.apply(this, arguments);
}

Mimic.prototype.initialize = function (options) {
  options = options || {};
  this.model = options.model;
  this.api = options.api;
  this.el = options.el || document.createElement("div");
  this.$el = $(this.el);
  this.$el
    .addClass("deliver-component-Mimic")
    .addClass("deliver-allowChildren");
  this.$el.hide();
  this.standardiseDimensions(this.model.get("css.height"), this.model.get("css.width"));
};

/**
 * Only store height and width as strings e.g. "100px".
 */
Mimic.prototype.standardiseDimensions = function (height, width) {
  if (typeof height === "number") {
    this.model.set("css.height", height + "px");
  }
  if (typeof width === "number") {
    this.model.set("css.width", width + "px");
  }
};

Mimic.prototype.remove = function () {
  this.$target && this.$target.show();
  this.$el.remove();
};

Mimic.prototype.render = function () {
  if (!this.$target) {
    this.setTarget(this.api.getTargetEl());
  }
  this.applyCSS();
};

Mimic.prototype.applyCSS = function () {
  var cssAttrs = this.model.get("css");
  if (!cssAttrs) {
    return;
  }
  if (cssAttrs.backgroundColor || cssAttrs.backgroundImage) {
    this.$el.addClass("deliver-allowChildren--noText");
  } else if (tooSmallForGuideText(cssAttrs)) {
    this.$el.addClass("deliver-allowChildren--noText");
  } else {
    this.$el.removeClass("deliver-allowChildren--noText");
  }
  this.$el.css(cssAttrs);
};

Mimic.prototype.componentDidMount = function () {
  if (!this.$target || !this.$target.get(0)) {
    return;
  }
  var model = this.model;
  this.$el.show();
  // make this.$el mimic styles of this.$target
  var assumed = assume(this.$el, this.$target);
  this.applyCSS();

  // show in settings the assumed height / width if not set on model
  if (!model.has("css.height")) {
    model.set("css.height", assumed.height);
  }
  if (!model.has("css.width")) {
    model.set("css.width", assumed.width);
  }
  // this needs to happen after 'assume' call because
  // .hide() causes display "none"
  this.$target.hide();
};

Mimic.prototype.setTarget = function (target) {
  this.$target = $(target);
};

module.exports = Mimic;

function isNullOrUndefined (a) {
  return a === null || typeof a === "undefined";
}

function extractPixelValue (dimensionStr) {
  if (!isNullOrUndefined(dimensionStr) && isPixelString(dimensionStr)) {
    return parseInt(dimensionStr.replace("px", ""), 10);
  }
  return null;
}

function tooSmallForGuideText(css) {
  var widthValuePx = extractPixelValue(css.width);
  var heightValuePx = extractPixelValue(css.height);
  return (!isNullOrUndefined(widthValuePx) && widthValuePx <= 100) ||
    (!isNullOrUndefined(heightValuePx) && heightValuePx <= 30);
}

function isPixelString (str) {
  return typeof str === "string" && /[0-9.]px\s*$/.test(str);
}

});

define('@qubit---mimic@1.3.15', ['@qubit---mimic@1.3.15/mimic'], function (main) { return main; });

/*!
 * jQuery UI Core 1.11.3
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( factory ) {
  if ( typeof define === "function" && define.amd ) {

    // AMD. Register as an anonymous module.
    define( '@qubit---jquery-ui@1.11.3/core',[ "jquery" ], factory );
  } else {

    // Browser globals
    factory( jQuery );
  }
}(function( $ ) {

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
  version: "1.11.3",

  keyCode: {
    BACKSPACE: 8,
    COMMA: 188,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ENTER: 13,
    ESCAPE: 27,
    HOME: 36,
    LEFT: 37,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    PERIOD: 190,
    RIGHT: 39,
    SPACE: 32,
    TAB: 9,
    UP: 38
  }
});

// plugins
$.fn.extend({
  scrollParent: function( includeHidden ) {
    var position = this.css( "position" ),
      excludeStaticParent = position === "absolute",
      overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
      scrollParent = this.parents().filter( function() {
        var parent = $( this );
        if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
          return false;
        }
        return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
      }).eq( 0 );

    return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
  },

  uniqueId: (function() {
    var uuid = 0;

    return function() {
      return this.each(function() {
        if ( !this.id ) {
          this.id = "ui-id-" + ( ++uuid );
        }
      });
    };
  })(),

  removeUniqueId: function() {
    return this.each(function() {
      if ( /^ui-id-\d+$/.test( this.id ) ) {
        $( this ).removeAttr( "id" );
      }
    });
  }
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
  var map, mapName, img,
    nodeName = element.nodeName.toLowerCase();
  if ( "area" === nodeName ) {
    map = element.parentNode;
    mapName = map.name;
    if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
      return false;
    }
    img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
    return !!img && visible( img );
  }
  return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
    !element.disabled :
    "a" === nodeName ?
      element.href || isTabIndexNotNaN :
      isTabIndexNotNaN) &&
    // the element and all of its ancestors must be visible
    visible( element );
}

function visible( element ) {
  return $.expr.filters.visible( element ) &&
    !$( element ).parents().addBack().filter(function() {
      return $.css( this, "visibility" ) === "hidden";
    }).length;
}

$.extend( $.expr[ ":" ], {
  data: $.expr.createPseudo ?
    $.expr.createPseudo(function( dataName ) {
      return function( elem ) {
        return !!$.data( elem, dataName );
      };
    }) :
    // support: jQuery <1.8
    function( elem, i, match ) {
      return !!$.data( elem, match[ 3 ] );
    },

  focusable: function( element ) {
    return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
  },

  tabbable: function( element ) {
    var tabIndex = $.attr( element, "tabindex" ),
      isTabIndexNaN = isNaN( tabIndex );
    return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
  }
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
  $.each( [ "Width", "Height" ], function( i, name ) {
    var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
      type = name.toLowerCase(),
      orig = {
        innerWidth: $.fn.innerWidth,
        innerHeight: $.fn.innerHeight,
        outerWidth: $.fn.outerWidth,
        outerHeight: $.fn.outerHeight
      };

    function reduce( elem, size, border, margin ) {
      $.each( side, function() {
        size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
        if ( border ) {
          size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
        }
        if ( margin ) {
          size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
        }
      });
      return size;
    }

    $.fn[ "inner" + name ] = function( size ) {
      if ( size === undefined ) {
        return orig[ "inner" + name ].call( this );
      }

      return this.each(function() {
        $( this ).css( type, reduce( this, size ) + "px" );
      });
    };

    $.fn[ "outer" + name] = function( size, margin ) {
      if ( typeof size !== "number" ) {
        return orig[ "outer" + name ].call( this, size );
      }

      return this.each(function() {
        $( this).css( type, reduce( this, size, true, margin ) + "px" );
      });
    };
  });
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
  $.fn.addBack = function( selector ) {
    return this.add( selector == null ?
      this.prevObject : this.prevObject.filter( selector )
    );
  };
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
  $.fn.removeData = (function( removeData ) {
    return function( key ) {
      if ( arguments.length ) {
        return removeData.call( this, $.camelCase( key ) );
      } else {
        return removeData.call( this );
      }
    };
  })( $.fn.removeData );
}

// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.fn.extend({
  focus: (function( orig ) {
    return function( delay, fn ) {
      return typeof delay === "number" ?
        this.each(function() {
          var elem = this;
          setTimeout(function() {
            $( elem ).focus();
            if ( fn ) {
              fn.call( elem );
            }
          }, delay );
        }) :
        orig.apply( this, arguments );
    };
  })( $.fn.focus ),

  disableSelection: (function() {
    var eventType = "onselectstart" in document.createElement( "div" ) ?
      "selectstart" :
      "mousedown";

    return function() {
      return this.bind( eventType + ".ui-disableSelection", function( event ) {
        event.preventDefault();
      });
    };
  })(),

  enableSelection: function() {
    return this.unbind( ".ui-disableSelection" );
  },

  zIndex: function( zIndex ) {
    if ( zIndex !== undefined ) {
      return this.css( "zIndex", zIndex );
    }

    if ( this.length ) {
      var elem = $( this[ 0 ] ), position, value;
      while ( elem.length && elem[ 0 ] !== document ) {
        // Ignore z-index if position is set to a value where z-index is ignored by the browser
        // This makes behavior of this function consistent across browsers
        // WebKit always returns auto if the element is positioned
        position = elem.css( "position" );
        if ( position === "absolute" || position === "relative" || position === "fixed" ) {
          // IE returns 0 when zIndex is not specified
          // other browsers return a string
          // we ignore the case of nested elements with an explicit value of 0
          // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
          value = parseInt( elem.css( "zIndex" ), 10 );
          if ( !isNaN( value ) && value !== 0 ) {
            return value;
          }
        }
        elem = elem.parent();
      }
    }

    return 0;
  }
});

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
$.ui.plugin = {
  add: function( module, option, set ) {
    var i,
      proto = $.ui[ module ].prototype;
    for ( i in set ) {
      proto.plugins[ i ] = proto.plugins[ i ] || [];
      proto.plugins[ i ].push( [ option, set[ i ] ] );
    }
  },
  call: function( instance, name, args, allowDisconnected ) {
    var i,
      set = instance.plugins[ name ];

    if ( !set ) {
      return;
    }

    if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
      return;
    }

    for ( i = 0; i < set.length; i++ ) {
      if ( instance.options[ set[ i ][ 0 ] ] ) {
        set[ i ][ 1 ].apply( instance.element, args );
      }
    }
  }
};

}));

/*!
 * jQuery UI Widget 1.11.3
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( factory ) {
  if ( typeof define === "function" && define.amd ) {

    // AMD. Register as an anonymous module.
    define( '@qubit---jquery-ui@1.11.3/widget',[ "jquery" ], factory );
  } else {

    // Browser globals
    factory( jQuery );
  }
}(function( $ ) {

var widget_uuid = 0,
  widget_slice = Array.prototype.slice;

$.cleanData = (function( orig ) {
  return function( elems ) {
    var events, elem, i;
    for ( i = 0; (elem = elems[i]) != null; i++ ) {
      try {

        // Only trigger remove when necessary to save time
        events = $._data( elem, "events" );
        if ( events && events.remove ) {
          $( elem ).triggerHandler( "remove" );
        }

      // http://bugs.jquery.com/ticket/8235
      } catch ( e ) {}
    }
    orig( elems );
  };
})( $.cleanData );

$.widget = function( name, base, prototype ) {
  var fullName, existingConstructor, constructor, basePrototype,
    // proxiedPrototype allows the provided prototype to remain unmodified
    // so that it can be used as a mixin for multiple widgets (#8876)
    proxiedPrototype = {},
    namespace = name.split( "." )[ 0 ];

  name = name.split( "." )[ 1 ];
  fullName = namespace + "-" + name;

  if ( !prototype ) {
    prototype = base;
    base = $.Widget;
  }

  // create selector for plugin
  $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
    return !!$.data( elem, fullName );
  };

  $[ namespace ] = $[ namespace ] || {};
  existingConstructor = $[ namespace ][ name ];
  constructor = $[ namespace ][ name ] = function( options, element ) {
    // allow instantiation without "new" keyword
    if ( !this._createWidget ) {
      return new constructor( options, element );
    }

    // allow instantiation without initializing for simple inheritance
    // must use "new" keyword (the code above always passes args)
    if ( arguments.length ) {
      this._createWidget( options, element );
    }
  };
  // extend with the existing constructor to carry over any static properties
  $.extend( constructor, existingConstructor, {
    version: prototype.version,
    // copy the object used to create the prototype in case we need to
    // redefine the widget later
    _proto: $.extend( {}, prototype ),
    // track widgets that inherit from this widget in case this widget is
    // redefined after a widget inherits from it
    _childConstructors: []
  });

  basePrototype = new base();
  // we need to make the options hash a property directly on the new instance
  // otherwise we'll modify the options hash on the prototype that we're
  // inheriting from
  basePrototype.options = $.widget.extend( {}, basePrototype.options );
  $.each( prototype, function( prop, value ) {
    if ( !$.isFunction( value ) ) {
      proxiedPrototype[ prop ] = value;
      return;
    }
    proxiedPrototype[ prop ] = (function() {
      var _super = function() {
          return base.prototype[ prop ].apply( this, arguments );
        },
        _superApply = function( args ) {
          return base.prototype[ prop ].apply( this, args );
        };
      return function() {
        var __super = this._super,
          __superApply = this._superApply,
          returnValue;

        this._super = _super;
        this._superApply = _superApply;

        returnValue = value.apply( this, arguments );

        this._super = __super;
        this._superApply = __superApply;

        return returnValue;
      };
    })();
  });
  constructor.prototype = $.widget.extend( basePrototype, {
    // TODO: remove support for widgetEventPrefix
    // always use the name + a colon as the prefix, e.g., draggable:start
    // don't prefix for widgets that aren't DOM-based
    widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
  }, proxiedPrototype, {
    constructor: constructor,
    namespace: namespace,
    widgetName: name,
    widgetFullName: fullName
  });

  // If this widget is being redefined then we need to find all widgets that
  // are inheriting from it and redefine all of them so that they inherit from
  // the new version of this widget. We're essentially trying to replace one
  // level in the prototype chain.
  if ( existingConstructor ) {
    $.each( existingConstructor._childConstructors, function( i, child ) {
      var childPrototype = child.prototype;

      // redefine the child widget using the same prototype that was
      // originally used, but inherit from the new version of the base
      $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
    });
    // remove the list of existing child constructors from the old constructor
    // so the old child constructors can be garbage collected
    delete existingConstructor._childConstructors;
  } else {
    base._childConstructors.push( constructor );
  }

  $.widget.bridge( name, constructor );

  return constructor;
};

$.widget.extend = function( target ) {
  var input = widget_slice.call( arguments, 1 ),
    inputIndex = 0,
    inputLength = input.length,
    key,
    value;
  for ( ; inputIndex < inputLength; inputIndex++ ) {
    for ( key in input[ inputIndex ] ) {
      value = input[ inputIndex ][ key ];
      if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
        // Clone objects
        if ( $.isPlainObject( value ) ) {
          target[ key ] = $.isPlainObject( target[ key ] ) ?
            $.widget.extend( {}, target[ key ], value ) :
            // Don't extend strings, arrays, etc. with objects
            $.widget.extend( {}, value );
        // Copy everything else by reference
        } else {
          target[ key ] = value;
        }
      }
    }
  }
  return target;
};

$.widget.bridge = function( name, object ) {
  var fullName = object.prototype.widgetFullName || name;
  $.fn[ name ] = function( options ) {
    var isMethodCall = typeof options === "string",
      args = widget_slice.call( arguments, 1 ),
      returnValue = this;

    if ( isMethodCall ) {
      this.each(function() {
        var methodValue,
          instance = $.data( this, fullName );
        if ( options === "instance" ) {
          returnValue = instance;
          return false;
        }
        if ( !instance ) {
          return $.error( "cannot call methods on " + name + " prior to initialization; " +
            "attempted to call method '" + options + "'" );
        }
        if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
          return $.error( "no such method '" + options + "' for " + name + " widget instance" );
        }
        methodValue = instance[ options ].apply( instance, args );
        if ( methodValue !== instance && methodValue !== undefined ) {
          returnValue = methodValue && methodValue.jquery ?
            returnValue.pushStack( methodValue.get() ) :
            methodValue;
          return false;
        }
      });
    } else {

      // Allow multiple hashes to be passed on init
      if ( args.length ) {
        options = $.widget.extend.apply( null, [ options ].concat(args) );
      }

      this.each(function() {
        var instance = $.data( this, fullName );
        if ( instance ) {
          instance.option( options || {} );
          if ( instance._init ) {
            instance._init();
          }
        } else {
          $.data( this, fullName, new object( options, this ) );
        }
      });
    }

    return returnValue;
  };
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
  widgetName: "widget",
  widgetEventPrefix: "",
  defaultElement: "<div>",
  options: {
    disabled: false,

    // callbacks
    create: null
  },
  _createWidget: function( options, element ) {
    element = $( element || this.defaultElement || this )[ 0 ];
    this.element = $( element );
    this.uuid = widget_uuid++;
    this.eventNamespace = "." + this.widgetName + this.uuid;

    this.bindings = $();
    this.hoverable = $();
    this.focusable = $();

    if ( element !== this ) {
      $.data( element, this.widgetFullName, this );
      this._on( true, this.element, {
        remove: function( event ) {
          if ( event.target === element ) {
            this.destroy();
          }
        }
      });
      this.document = $( element.style ?
        // element within the document
        element.ownerDocument :
        // element is window or document
        element.document || element );
      this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
    }

    this.options = $.widget.extend( {},
      this.options,
      this._getCreateOptions(),
      options );

    this._create();
    this._trigger( "create", null, this._getCreateEventData() );
    this._init();
  },
  _getCreateOptions: $.noop,
  _getCreateEventData: $.noop,
  _create: $.noop,
  _init: $.noop,

  destroy: function() {
    this._destroy();
    // we can probably remove the unbind calls in 2.0
    // all event bindings should go through this._on()
    this.element
      .unbind( this.eventNamespace )
      .removeData( this.widgetFullName )
      // support: jquery <1.6.3
      // http://bugs.jquery.com/ticket/9413
      .removeData( $.camelCase( this.widgetFullName ) );
    this.widget()
      .unbind( this.eventNamespace )
      .removeAttr( "aria-disabled" )
      .removeClass(
        this.widgetFullName + "-disabled " +
        "ui-state-disabled" );

    // clean up events and states
    this.bindings.unbind( this.eventNamespace );
    this.hoverable.removeClass( "ui-state-hover" );
    this.focusable.removeClass( "ui-state-focus" );
  },
  _destroy: $.noop,

  widget: function() {
    return this.element;
  },

  option: function( key, value ) {
    var options = key,
      parts,
      curOption,
      i;

    if ( arguments.length === 0 ) {
      // don't return a reference to the internal hash
      return $.widget.extend( {}, this.options );
    }

    if ( typeof key === "string" ) {
      // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
      options = {};
      parts = key.split( "." );
      key = parts.shift();
      if ( parts.length ) {
        curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
        for ( i = 0; i < parts.length - 1; i++ ) {
          curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
          curOption = curOption[ parts[ i ] ];
        }
        key = parts.pop();
        if ( arguments.length === 1 ) {
          return curOption[ key ] === undefined ? null : curOption[ key ];
        }
        curOption[ key ] = value;
      } else {
        if ( arguments.length === 1 ) {
          return this.options[ key ] === undefined ? null : this.options[ key ];
        }
        options[ key ] = value;
      }
    }

    this._setOptions( options );

    return this;
  },
  _setOptions: function( options ) {
    var key;

    for ( key in options ) {
      this._setOption( key, options[ key ] );
    }

    return this;
  },
  _setOption: function( key, value ) {
    this.options[ key ] = value;

    if ( key === "disabled" ) {
      this.widget()
        .toggleClass( this.widgetFullName + "-disabled", !!value );

      // If the widget is becoming disabled, then nothing is interactive
      if ( value ) {
        this.hoverable.removeClass( "ui-state-hover" );
        this.focusable.removeClass( "ui-state-focus" );
      }
    }

    return this;
  },

  enable: function() {
    return this._setOptions({ disabled: false });
  },
  disable: function() {
    return this._setOptions({ disabled: true });
  },

  _on: function( suppressDisabledCheck, element, handlers ) {
    var delegateElement,
      instance = this;

    // no suppressDisabledCheck flag, shuffle arguments
    if ( typeof suppressDisabledCheck !== "boolean" ) {
      handlers = element;
      element = suppressDisabledCheck;
      suppressDisabledCheck = false;
    }

    // no element argument, shuffle and use this.element
    if ( !handlers ) {
      handlers = element;
      element = this.element;
      delegateElement = this.widget();
    } else {
      element = delegateElement = $( element );
      this.bindings = this.bindings.add( element );
    }

    $.each( handlers, function( event, handler ) {
      function handlerProxy() {
        // allow widgets to customize the disabled handling
        // - disabled as an array instead of boolean
        // - disabled class as method for disabling individual parts
        if ( !suppressDisabledCheck &&
            ( instance.options.disabled === true ||
              $( this ).hasClass( "ui-state-disabled" ) ) ) {
          return;
        }
        return ( typeof handler === "string" ? instance[ handler ] : handler )
          .apply( instance, arguments );
      }

      // copy the guid so direct unbinding works
      if ( typeof handler !== "string" ) {
        handlerProxy.guid = handler.guid =
          handler.guid || handlerProxy.guid || $.guid++;
      }

      var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
        eventName = match[1] + instance.eventNamespace,
        selector = match[2];
      if ( selector ) {
        delegateElement.delegate( selector, eventName, handlerProxy );
      } else {
        element.bind( eventName, handlerProxy );
      }
    });
  },

  _off: function( element, eventName ) {
    eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
      this.eventNamespace;
    element.unbind( eventName ).undelegate( eventName );

    // Clear the stack to avoid memory leaks (#10056)
    this.bindings = $( this.bindings.not( element ).get() );
    this.focusable = $( this.focusable.not( element ).get() );
    this.hoverable = $( this.hoverable.not( element ).get() );
  },

  _delay: function( handler, delay ) {
    function handlerProxy() {
      return ( typeof handler === "string" ? instance[ handler ] : handler )
        .apply( instance, arguments );
    }
    var instance = this;
    return setTimeout( handlerProxy, delay || 0 );
  },

  _hoverable: function( element ) {
    this.hoverable = this.hoverable.add( element );
    this._on( element, {
      mouseenter: function( event ) {
        $( event.currentTarget ).addClass( "ui-state-hover" );
      },
      mouseleave: function( event ) {
        $( event.currentTarget ).removeClass( "ui-state-hover" );
      }
    });
  },

  _focusable: function( element ) {
    this.focusable = this.focusable.add( element );
    this._on( element, {
      focusin: function( event ) {
        $( event.currentTarget ).addClass( "ui-state-focus" );
      },
      focusout: function( event ) {
        $( event.currentTarget ).removeClass( "ui-state-focus" );
      }
    });
  },

  _trigger: function( type, event, data ) {
    var prop, orig,
      callback = this.options[ type ];

    data = data || {};
    event = $.Event( event );
    event.type = ( type === this.widgetEventPrefix ?
      type :
      this.widgetEventPrefix + type ).toLowerCase();
    // the original event may come from any element
    // so we need to reset the target on the new event
    event.target = this.element[ 0 ];

    // copy original event properties over to the new event
    orig = event.originalEvent;
    if ( orig ) {
      for ( prop in orig ) {
        if ( !( prop in event ) ) {
          event[ prop ] = orig[ prop ];
        }
      }
    }

    this.element.trigger( event, data );
    return !( $.isFunction( callback ) &&
      callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
      event.isDefaultPrevented() );
  }
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
  $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
    if ( typeof options === "string" ) {
      options = { effect: options };
    }
    var hasOptions,
      effectName = !options ?
        method :
        options === true || typeof options === "number" ?
          defaultEffect :
          options.effect || defaultEffect;
    options = options || {};
    if ( typeof options === "number" ) {
      options = { duration: options };
    }
    hasOptions = !$.isEmptyObject( options );
    options.complete = callback;
    if ( options.delay ) {
      element.delay( options.delay );
    }
    if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
      element[ method ]( options );
    } else if ( effectName !== method && element[ effectName ] ) {
      element[ effectName ]( options.duration, options.easing, callback );
    } else {
      element.queue(function( next ) {
        $( this )[ method ]();
        if ( callback ) {
          callback.call( element[ 0 ] );
        }
        next();
      });
    }
  };
});

return $.widget;

}));

/*!
 * jQuery UI Mouse 1.11.3
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */
(function( factory ) {
  if ( typeof define === "function" && define.amd ) {

    // AMD. Register as an anonymous module.
    define('@qubit---jquery-ui@1.11.3/mouse',[
      "jquery",
      "./widget"
    ], factory );
  } else {

    // Browser globals
    factory( jQuery );
  }
}(function( $ ) {

var mouseHandled = false;
$( document ).mouseup( function() {
  mouseHandled = false;
});

return $.widget("ui.mouse", {
  version: "1.11.3",
  options: {
    cancel: "input,textarea,button,select,option",
    distance: 1,
    delay: 0
  },
  _mouseInit: function() {
    var that = this;

    this.element
      .bind("mousedown." + this.widgetName, function(event) {
        return that._mouseDown(event);
      })
      .bind("click." + this.widgetName, function(event) {
        if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
          $.removeData(event.target, that.widgetName + ".preventClickEvent");
          event.stopImmediatePropagation();
          return false;
        }
      });

    this.started = false;
  },

  // TODO: make sure destroying one instance of mouse doesn't mess with
  // other instances of mouse
  _mouseDestroy: function() {
    this.element.unbind("." + this.widgetName);
    if ( this._mouseMoveDelegate ) {
      this.document
        .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
        .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
    }
  },

  _mouseDown: function(event) {
    // don't let more than one widget handle mouseStart
    if ( mouseHandled ) {
      return;
    }

    this._mouseMoved = false;

    // we may have missed mouseup (out of window)
    (this._mouseStarted && this._mouseUp(event));

    this._mouseDownEvent = event;

    var that = this,
      btnIsLeft = (event.which === 1),
      // event.target.nodeName works around a bug in IE 8 with
      // disabled inputs (#7620)
      elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
    if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
      return true;
    }

    this.mouseDelayMet = !this.options.delay;
    if (!this.mouseDelayMet) {
      this._mouseDelayTimer = setTimeout(function() {
        that.mouseDelayMet = true;
      }, this.options.delay);
    }

    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
      this._mouseStarted = (this._mouseStart(event) !== false);
      if (!this._mouseStarted) {
        event.preventDefault();
        return true;
      }
    }

    // Click event may never have fired (Gecko & Opera)
    if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
      $.removeData(event.target, this.widgetName + ".preventClickEvent");
    }

    // these delegates are required to keep context
    this._mouseMoveDelegate = function(event) {
      return that._mouseMove(event);
    };
    this._mouseUpDelegate = function(event) {
      return that._mouseUp(event);
    };

    this.document
      .bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
      .bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

    event.preventDefault();

    mouseHandled = true;
    return true;
  },

  _mouseMove: function(event) {
    // Only check for mouseups outside the document if you've moved inside the document
    // at least once. This prevents the firing of mouseup in the case of IE<9, which will
    // fire a mousemove event if content is placed under the cursor. See #7778
    // Support: IE <9
    if ( this._mouseMoved ) {
      // IE mouseup check - mouseup happened when mouse was out of window
      if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
        return this._mouseUp(event);

      // Iframe mouseup check - mouseup occurred in another document
      } else if ( !event.which ) {
        return this._mouseUp( event );
      }
    }

    if ( event.which || event.button ) {
      this._mouseMoved = true;
    }

    if (this._mouseStarted) {
      this._mouseDrag(event);
      return event.preventDefault();
    }

    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
      this._mouseStarted =
        (this._mouseStart(this._mouseDownEvent, event) !== false);
      (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
    }

    return !this._mouseStarted;
  },

  _mouseUp: function(event) {
    this.document
      .unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
      .unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

    if (this._mouseStarted) {
      this._mouseStarted = false;

      if (event.target === this._mouseDownEvent.target) {
        $.data(event.target, this.widgetName + ".preventClickEvent", true);
      }

      this._mouseStop(event);
    }

    mouseHandled = false;
    return false;
  },

  _mouseDistanceMet: function(event) {
    return (Math.max(
        Math.abs(this._mouseDownEvent.pageX - event.pageX),
        Math.abs(this._mouseDownEvent.pageY - event.pageY)
      ) >= this.options.distance
    );
  },

  _mouseDelayMet: function(/* event */) {
    return this.mouseDelayMet;
  },

  // These are placeholder methods, to be overriden by extending plugin
  _mouseStart: function(/* event */) {},
  _mouseDrag: function(/* event */) {},
  _mouseStop: function(/* event */) {},
  _mouseCapture: function(/* event */) { return true; }
});

}));

/*!
 * jQuery UI Draggable 1.11.3
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */
(function( factory ) {
  if ( typeof define === "function" && define.amd ) {

    // AMD. Register as an anonymous module.
    define('@qubit---jquery-ui@1.11.3/draggable',[
      "jquery",
      "./core",
      "./mouse",
      "./widget"
    ], factory );
  } else {

    // Browser globals
    factory( jQuery );
  }
}(function( $ ) {

$.widget("ui.draggable", $.ui.mouse, {
  version: "1.11.3",
  widgetEventPrefix: "drag",
  options: {
    addClasses: true,
    appendTo: "parent",
    axis: false,
    connectToSortable: false,
    containment: false,
    cursor: "auto",
    cursorAt: false,
    grid: false,
    handle: false,
    helper: "original",
    iframeFix: false,
    opacity: false,
    refreshPositions: false,
    revert: false,
    revertDuration: 500,
    scope: "default",
    scroll: true,
    scrollSensitivity: 20,
    scrollSpeed: 20,
    snap: false,
    snapMode: "both",
    snapTolerance: 20,
    stack: false,
    zIndex: false,

    // callbacks
    drag: null,
    start: null,
    stop: null
  },
  _create: function() {

    if ( this.options.helper === "original" ) {
      this._setPositionRelative();
    }
    if (this.options.addClasses){
      this.element.addClass("ui-draggable");
    }
    if (this.options.disabled){
      this.element.addClass("ui-draggable-disabled");
    }
    this._setHandleClassName();

    this._mouseInit();
  },

  _setOption: function( key, value ) {
    this._super( key, value );
    if ( key === "handle" ) {
      this._removeHandleClassName();
      this._setHandleClassName();
    }
  },

  _destroy: function() {
    if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
      this.destroyOnClear = true;
      return;
    }
    this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
    this._removeHandleClassName();
    this._mouseDestroy();
  },

  _mouseCapture: function(event) {
    var o = this.options;

    this._blurActiveElement( event );

    // among others, prevent a drag on a resizable-handle
    if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
      return false;
    }

    //Quit if we're not on a valid handle
    this.handle = this._getHandle(event);
    if (!this.handle) {
      return false;
    }

    this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

    return true;

  },

  _blockFrames: function( selector ) {
    this.iframeBlocks = this.document.find( selector ).map(function() {
      var iframe = $( this );

      return $( "<div>" )
        .css( "position", "absolute" )
        .appendTo( iframe.parent() )
        .outerWidth( iframe.outerWidth() )
        .outerHeight( iframe.outerHeight() )
        .offset( iframe.offset() )[ 0 ];
    });
  },

  _unblockFrames: function() {
    if ( this.iframeBlocks ) {
      this.iframeBlocks.remove();
      delete this.iframeBlocks;
    }
  },

  _blurActiveElement: function( event ) {
    var document = this.document[ 0 ];

    // Only need to blur if the event occurred on the draggable itself, see #10527
    if ( !this.handleElement.is( event.target ) ) {
      return;
    }

    // support: IE9
    // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
    try {

      // Support: IE9, IE10
      // If the <body> is blurred, IE will switch windows, see #9520
      if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {

        // Blur any element that currently has focus, see #4261
        $( document.activeElement ).blur();
      }
    } catch ( error ) {}
  },

  _mouseStart: function(event) {

    var o = this.options;

    //Create and append the visible helper
    this.helper = this._createHelper(event);

    this.helper.addClass("ui-draggable-dragging");

    //Cache the helper size
    this._cacheHelperProportions();

    //If ddmanager is used for droppables, set the global draggable
    if ($.ui.ddmanager) {
      $.ui.ddmanager.current = this;
    }

    /*
     * - Position generation -
     * This block generates everything position related - it's the core of draggables.
     */

    //Cache the margins of the original element
    this._cacheMargins();

    //Store the helper's css position
    this.cssPosition = this.helper.css( "position" );
    this.scrollParent = this.helper.scrollParent( true );
    this.offsetParent = this.helper.offsetParent();
    this.hasFixedAncestor = this.helper.parents().filter(function() {
        return $( this ).css( "position" ) === "fixed";
      }).length > 0;

    //The element's absolute position on the page minus margins
    this.positionAbs = this.element.offset();
    this._refreshOffsets( event );

    //Generate the original position
    this.originalPosition = this.position = this._generatePosition( event, false );
    this.originalPageX = event.pageX;
    this.originalPageY = event.pageY;

    //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

    //Set a containment if given in the options
    this._setContainment();

    //Trigger event + callbacks
    if (this._trigger("start", event) === false) {
      this._clear();
      return false;
    }

    //Recache the helper size
    this._cacheHelperProportions();

    //Prepare the droppable offsets
    if ($.ui.ddmanager && !o.dropBehaviour) {
      $.ui.ddmanager.prepareOffsets(this, event);
    }

    // Reset helper's right/bottom css if they're set and set explicit width/height instead
    // as this prevents resizing of elements with right/bottom set (see #7772)
    this._normalizeRightBottom();

    this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

    //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
    if ( $.ui.ddmanager ) {
      $.ui.ddmanager.dragStart(this, event);
    }

    return true;
  },

  _refreshOffsets: function( event ) {
    this.offset = {
      top: this.positionAbs.top - this.margins.top,
      left: this.positionAbs.left - this.margins.left,
      scroll: false,
      parent: this._getParentOffset(),
      relative: this._getRelativeOffset()
    };

    this.offset.click = {
      left: event.pageX - this.offset.left,
      top: event.pageY - this.offset.top
    };
  },

  _mouseDrag: function(event, noPropagation) {
    // reset any necessary cached properties (see #5009)
    if ( this.hasFixedAncestor ) {
      this.offset.parent = this._getParentOffset();
    }

    //Compute the helpers position
    this.position = this._generatePosition( event, true );
    this.positionAbs = this._convertPositionTo("absolute");

    //Call plugins and callbacks and use the resulting position if something is returned
    if (!noPropagation) {
      var ui = this._uiHash();
      if (this._trigger("drag", event, ui) === false) {
        this._mouseUp({});
        return false;
      }
      this.position = ui.position;
    }

    this.helper[ 0 ].style.left = this.position.left + "px";
    this.helper[ 0 ].style.top = this.position.top + "px";

    if ($.ui.ddmanager) {
      $.ui.ddmanager.drag(this, event);
    }

    return false;
  },

  _mouseStop: function(event) {

    //If we are using droppables, inform the manager about the drop
    var that = this,
      dropped = false;
    if ($.ui.ddmanager && !this.options.dropBehaviour) {
      dropped = $.ui.ddmanager.drop(this, event);
    }

    //if a drop comes from outside (a sortable)
    if (this.dropped) {
      dropped = this.dropped;
      this.dropped = false;
    }

    if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
      $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
        if (that._trigger("stop", event) !== false) {
          that._clear();
        }
      });
    } else {
      if (this._trigger("stop", event) !== false) {
        this._clear();
      }
    }

    return false;
  },

  _mouseUp: function( event ) {
    this._unblockFrames();

    //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
    if ( $.ui.ddmanager ) {
      $.ui.ddmanager.dragStop(this, event);
    }

    // Only need to focus if the event occurred on the draggable itself, see #10527
    if ( this.handleElement.is( event.target ) ) {
      // The interaction is over; whether or not the click resulted in a drag, focus the element
      this.element.focus();
    }

    return $.ui.mouse.prototype._mouseUp.call(this, event);
  },

  cancel: function() {

    if (this.helper.is(".ui-draggable-dragging")) {
      this._mouseUp({});
    } else {
      this._clear();
    }

    return this;

  },

  _getHandle: function(event) {
    return this.options.handle ?
      !!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
      true;
  },

  _setHandleClassName: function() {
    this.handleElement = this.options.handle ?
      this.element.find( this.options.handle ) : this.element;
    this.handleElement.addClass( "ui-draggable-handle" );
  },

  _removeHandleClassName: function() {
    this.handleElement.removeClass( "ui-draggable-handle" );
  },

  _createHelper: function(event) {

    var o = this.options,
      helperIsFunction = $.isFunction( o.helper ),
      helper = helperIsFunction ?
        $( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
        ( o.helper === "clone" ?
          this.element.clone().removeAttr( "id" ) :
          this.element );

    if (!helper.parents("body").length) {
      helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
    }

    // http://bugs.jqueryui.com/ticket/9446
    // a helper function can return the original element
    // which wouldn't have been set to relative in _create
    if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
      this._setPositionRelative();
    }

    if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
      helper.css("position", "absolute");
    }

    return helper;

  },

  _setPositionRelative: function() {
    if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
      this.element[ 0 ].style.position = "relative";
    }
  },

  _adjustOffsetFromHelper: function(obj) {
    if (typeof obj === "string") {
      obj = obj.split(" ");
    }
    if ($.isArray(obj)) {
      obj = { left: +obj[0], top: +obj[1] || 0 };
    }
    if ("left" in obj) {
      this.offset.click.left = obj.left + this.margins.left;
    }
    if ("right" in obj) {
      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
    }
    if ("top" in obj) {
      this.offset.click.top = obj.top + this.margins.top;
    }
    if ("bottom" in obj) {
      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
    }
  },

  _isRootNode: function( element ) {
    return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
  },

  _getParentOffset: function() {

    //Get the offsetParent and cache its position
    var po = this.offsetParent.offset(),
      document = this.document[ 0 ];

    // This is a special case where we need to modify a offset calculated on start, since the following happened:
    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
    if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
      po.left += this.scrollParent.scrollLeft();
      po.top += this.scrollParent.scrollTop();
    }

    if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
      po = { top: 0, left: 0 };
    }

    return {
      top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
      left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
    };

  },

  _getRelativeOffset: function() {
    if ( this.cssPosition !== "relative" ) {
      return { top: 0, left: 0 };
    }

    var p = this.element.position(),
      scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

    return {
      top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
      left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
    };

  },

  _cacheMargins: function() {
    this.margins = {
      left: (parseInt(this.element.css("marginLeft"), 10) || 0),
      top: (parseInt(this.element.css("marginTop"), 10) || 0),
      right: (parseInt(this.element.css("marginRight"), 10) || 0),
      bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
    };
  },

  _cacheHelperProportions: function() {
    this.helperProportions = {
      width: this.helper.outerWidth(),
      height: this.helper.outerHeight()
    };
  },

  _setContainment: function() {

    var isUserScrollable, c, ce,
      o = this.options,
      document = this.document[ 0 ];

    this.relativeContainer = null;

    if ( !o.containment ) {
      this.containment = null;
      return;
    }

    if ( o.containment === "window" ) {
      this.containment = [
        $( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
        $( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
        $( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
        $( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
      ];
      return;
    }

    if ( o.containment === "document") {
      this.containment = [
        0,
        0,
        $( document ).width() - this.helperProportions.width - this.margins.left,
        ( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
      ];
      return;
    }

    if ( o.containment.constructor === Array ) {
      this.containment = o.containment;
      return;
    }

    if ( o.containment === "parent" ) {
      o.containment = this.helper[ 0 ].parentNode;
    }

    c = $( o.containment );
    ce = c[ 0 ];

    if ( !ce ) {
      return;
    }

    isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

    this.containment = [
      ( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
      ( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
      ( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
        ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
        ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
        this.helperProportions.width -
        this.margins.left -
        this.margins.right,
      ( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
        ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
        ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
        this.helperProportions.height -
        this.margins.top -
        this.margins.bottom
    ];
    this.relativeContainer = c;
  },

  _convertPositionTo: function(d, pos) {

    if (!pos) {
      pos = this.position;
    }

    var mod = d === "absolute" ? 1 : -1,
      scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

    return {
      top: (
        pos.top +                               // The absolute mouse position
        this.offset.relative.top * mod +                    // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.parent.top * mod -                    // The offsetParent's offset without borders (offset + border)
        ( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
      ),
      left: (
        pos.left +                                // The absolute mouse position
        this.offset.relative.left * mod +                   // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.parent.left * mod -                   // The offsetParent's offset without borders (offset + border)
        ( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
      )
    };

  },

  _generatePosition: function( event, constrainPosition ) {

    var containment, co, top, left,
      o = this.options,
      scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
      pageX = event.pageX,
      pageY = event.pageY;

    // Cache the scroll
    if ( !scrollIsRootNode || !this.offset.scroll ) {
      this.offset.scroll = {
        top: this.scrollParent.scrollTop(),
        left: this.scrollParent.scrollLeft()
      };
    }

    /*
     * - Position constraining -
     * Constrain the position to a mix of grid, containment.
     */

    // If we are not dragging yet, we won't check for options
    if ( constrainPosition ) {
      if ( this.containment ) {
        if ( this.relativeContainer ){
          co = this.relativeContainer.offset();
          containment = [
            this.containment[ 0 ] + co.left,
            this.containment[ 1 ] + co.top,
            this.containment[ 2 ] + co.left,
            this.containment[ 3 ] + co.top
          ];
        } else {
          containment = this.containment;
        }

        if (event.pageX - this.offset.click.left < containment[0]) {
          pageX = containment[0] + this.offset.click.left;
        }
        if (event.pageY - this.offset.click.top < containment[1]) {
          pageY = containment[1] + this.offset.click.top;
        }
        if (event.pageX - this.offset.click.left > containment[2]) {
          pageX = containment[2] + this.offset.click.left;
        }
        if (event.pageY - this.offset.click.top > containment[3]) {
          pageY = containment[3] + this.offset.click.top;
        }
      }

      if (o.grid) {
        //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
        top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
        pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

        left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
        pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
      }

      if ( o.axis === "y" ) {
        pageX = this.originalPageX;
      }

      if ( o.axis === "x" ) {
        pageY = this.originalPageY;
      }
    }

    return {
      top: (
        pageY -                                 // The absolute mouse position
        this.offset.click.top -                       // Click offset (relative to the element)
        this.offset.relative.top -                        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.parent.top +                        // The offsetParent's offset without borders (offset + border)
        ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
      ),
      left: (
        pageX -                                 // The absolute mouse position
        this.offset.click.left -                        // Click offset (relative to the element)
        this.offset.relative.left -                       // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.parent.left +                       // The offsetParent's offset without borders (offset + border)
        ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
      )
    };

  },

  _clear: function() {
    this.helper.removeClass("ui-draggable-dragging");
    if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
      this.helper.remove();
    }
    this.helper = null;
    this.cancelHelperRemoval = false;
    if ( this.destroyOnClear ) {
      this.destroy();
    }
  },

  _normalizeRightBottom: function() {
    if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
      this.helper.width( this.helper.width() );
      this.helper.css( "right", "auto" );
    }
    if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
      this.helper.height( this.helper.height() );
      this.helper.css( "bottom", "auto" );
    }
  },

  // From now on bulk stuff - mainly helpers

  _trigger: function( type, event, ui ) {
    ui = ui || this._uiHash();
    $.ui.plugin.call( this, type, [ event, ui, this ], true );

    // Absolute position and offset (see #6884 ) have to be recalculated after plugins
    if ( /^(drag|start|stop)/.test( type ) ) {
      this.positionAbs = this._convertPositionTo( "absolute" );
      ui.offset = this.positionAbs;
    }
    return $.Widget.prototype._trigger.call( this, type, event, ui );
  },

  plugins: {},

  _uiHash: function() {
    return {
      helper: this.helper,
      position: this.position,
      originalPosition: this.originalPosition,
      offset: this.positionAbs
    };
  }

});

$.ui.plugin.add( "draggable", "connectToSortable", {
  start: function( event, ui, draggable ) {
    var uiSortable = $.extend( {}, ui, {
      item: draggable.element
    });

    draggable.sortables = [];
    $( draggable.options.connectToSortable ).each(function() {
      var sortable = $( this ).sortable( "instance" );

      if ( sortable && !sortable.options.disabled ) {
        draggable.sortables.push( sortable );

        // refreshPositions is called at drag start to refresh the containerCache
        // which is used in drag. This ensures it's initialized and synchronized
        // with any changes that might have happened on the page since initialization.
        sortable.refreshPositions();
        sortable._trigger("activate", event, uiSortable);
      }
    });
  },
  stop: function( event, ui, draggable ) {
    var uiSortable = $.extend( {}, ui, {
      item: draggable.element
    });

    draggable.cancelHelperRemoval = false;

    $.each( draggable.sortables, function() {
      var sortable = this;

      if ( sortable.isOver ) {
        sortable.isOver = 0;

        // Allow this sortable to handle removing the helper
        draggable.cancelHelperRemoval = true;
        sortable.cancelHelperRemoval = false;

        // Use _storedCSS To restore properties in the sortable,
        // as this also handles revert (#9675) since the draggable
        // may have modified them in unexpected ways (#8809)
        sortable._storedCSS = {
          position: sortable.placeholder.css( "position" ),
          top: sortable.placeholder.css( "top" ),
          left: sortable.placeholder.css( "left" )
        };

        sortable._mouseStop(event);

        // Once drag has ended, the sortable should return to using
        // its original helper, not the shared helper from draggable
        sortable.options.helper = sortable.options._helper;
      } else {
        // Prevent this Sortable from removing the helper.
        // However, don't set the draggable to remove the helper
        // either as another connected Sortable may yet handle the removal.
        sortable.cancelHelperRemoval = true;

        sortable._trigger( "deactivate", event, uiSortable );
      }
    });
  },
  drag: function( event, ui, draggable ) {
    $.each( draggable.sortables, function() {
      var innermostIntersecting = false,
        sortable = this;

      // Copy over variables that sortable's _intersectsWith uses
      sortable.positionAbs = draggable.positionAbs;
      sortable.helperProportions = draggable.helperProportions;
      sortable.offset.click = draggable.offset.click;

      if ( sortable._intersectsWith( sortable.containerCache ) ) {
        innermostIntersecting = true;

        $.each( draggable.sortables, function() {
          // Copy over variables that sortable's _intersectsWith uses
          this.positionAbs = draggable.positionAbs;
          this.helperProportions = draggable.helperProportions;
          this.offset.click = draggable.offset.click;

          if ( this !== sortable &&
              this._intersectsWith( this.containerCache ) &&
              $.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
            innermostIntersecting = false;
          }

          return innermostIntersecting;
        });
      }

      if ( innermostIntersecting ) {
        // If it intersects, we use a little isOver variable and set it once,
        // so that the move-in stuff gets fired only once.
        if ( !sortable.isOver ) {
          sortable.isOver = 1;

          sortable.currentItem = ui.helper
            .appendTo( sortable.element )
            .data( "ui-sortable-item", true );

          // Store helper option to later restore it
          sortable.options._helper = sortable.options.helper;

          sortable.options.helper = function() {
            return ui.helper[ 0 ];
          };

          // Fire the start events of the sortable with our passed browser event,
          // and our own helper (so it doesn't create a new one)
          event.target = sortable.currentItem[ 0 ];
          sortable._mouseCapture( event, true );
          sortable._mouseStart( event, true, true );

          // Because the browser event is way off the new appended portlet,
          // modify necessary variables to reflect the changes
          sortable.offset.click.top = draggable.offset.click.top;
          sortable.offset.click.left = draggable.offset.click.left;
          sortable.offset.parent.left -= draggable.offset.parent.left -
            sortable.offset.parent.left;
          sortable.offset.parent.top -= draggable.offset.parent.top -
            sortable.offset.parent.top;

          draggable._trigger( "toSortable", event );

          // Inform draggable that the helper is in a valid drop zone,
          // used solely in the revert option to handle "valid/invalid".
          draggable.dropped = sortable.element;

          // Need to refreshPositions of all sortables in the case that
          // adding to one sortable changes the location of the other sortables (#9675)
          $.each( draggable.sortables, function() {
            this.refreshPositions();
          });

          // hack so receive/update callbacks work (mostly)
          draggable.currentItem = draggable.element;
          sortable.fromOutside = draggable;
        }

        if ( sortable.currentItem ) {
          sortable._mouseDrag( event );
          // Copy the sortable's position because the draggable's can potentially reflect
          // a relative position, while sortable is always absolute, which the dragged
          // element has now become. (#8809)
          ui.position = sortable.position;
        }
      } else {
        // If it doesn't intersect with the sortable, and it intersected before,
        // we fake the drag stop of the sortable, but make sure it doesn't remove
        // the helper by using cancelHelperRemoval.
        if ( sortable.isOver ) {

          sortable.isOver = 0;
          sortable.cancelHelperRemoval = true;

          // Calling sortable's mouseStop would trigger a revert,
          // so revert must be temporarily false until after mouseStop is called.
          sortable.options._revert = sortable.options.revert;
          sortable.options.revert = false;

          sortable._trigger( "out", event, sortable._uiHash( sortable ) );
          sortable._mouseStop( event, true );

          // restore sortable behaviors that were modfied
          // when the draggable entered the sortable area (#9481)
          sortable.options.revert = sortable.options._revert;
          sortable.options.helper = sortable.options._helper;

          if ( sortable.placeholder ) {
            sortable.placeholder.remove();
          }

          // Recalculate the draggable's offset considering the sortable
          // may have modified them in unexpected ways (#8809)
          draggable._refreshOffsets( event );
          ui.position = draggable._generatePosition( event, true );

          draggable._trigger( "fromSortable", event );

          // Inform draggable that the helper is no longer in a valid drop zone
          draggable.dropped = false;

          // Need to refreshPositions of all sortables just in case removing
          // from one sortable changes the location of other sortables (#9675)
          $.each( draggable.sortables, function() {
            this.refreshPositions();
          });
        }
      }
    });
  }
});

$.ui.plugin.add("draggable", "cursor", {
  start: function( event, ui, instance ) {
    var t = $( "body" ),
      o = instance.options;

    if (t.css("cursor")) {
      o._cursor = t.css("cursor");
    }
    t.css("cursor", o.cursor);
  },
  stop: function( event, ui, instance ) {
    var o = instance.options;
    if (o._cursor) {
      $("body").css("cursor", o._cursor);
    }
  }
});

$.ui.plugin.add("draggable", "opacity", {
  start: function( event, ui, instance ) {
    var t = $( ui.helper ),
      o = instance.options;
    if (t.css("opacity")) {
      o._opacity = t.css("opacity");
    }
    t.css("opacity", o.opacity);
  },
  stop: function( event, ui, instance ) {
    var o = instance.options;
    if (o._opacity) {
      $(ui.helper).css("opacity", o._opacity);
    }
  }
});

$.ui.plugin.add("draggable", "scroll", {
  start: function( event, ui, i ) {
    if ( !i.scrollParentNotHidden ) {
      i.scrollParentNotHidden = i.helper.scrollParent( false );
    }

    if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
      i.overflowOffset = i.scrollParentNotHidden.offset();
    }
  },
  drag: function( event, ui, i  ) {

    var o = i.options,
      scrolled = false,
      scrollParent = i.scrollParentNotHidden[ 0 ],
      document = i.document[ 0 ];

    if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
      if ( !o.axis || o.axis !== "x" ) {
        if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
          scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
        } else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
          scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
        }
      }

      if ( !o.axis || o.axis !== "y" ) {
        if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
          scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
        } else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
          scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
        }
      }

    } else {

      if (!o.axis || o.axis !== "x") {
        if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
          scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
        } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
          scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
        }
      }

      if (!o.axis || o.axis !== "y") {
        if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
          scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
        } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
          scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
        }
      }

    }

    if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
      $.ui.ddmanager.prepareOffsets(i, event);
    }

  }
});

$.ui.plugin.add("draggable", "snap", {
  start: function( event, ui, i ) {

    var o = i.options;

    i.snapElements = [];

    $(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
      var $t = $(this),
        $o = $t.offset();
      if (this !== i.element[0]) {
        i.snapElements.push({
          item: this,
          width: $t.outerWidth(), height: $t.outerHeight(),
          top: $o.top, left: $o.left
        });
      }
    });

  },
  drag: function( event, ui, inst ) {

    var ts, bs, ls, rs, l, r, t, b, i, first,
      o = inst.options,
      d = o.snapTolerance,
      x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
      y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

    for (i = inst.snapElements.length - 1; i >= 0; i--){

      l = inst.snapElements[i].left - inst.margins.left;
      r = l + inst.snapElements[i].width;
      t = inst.snapElements[i].top - inst.margins.top;
      b = t + inst.snapElements[i].height;

      if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
        if (inst.snapElements[i].snapping) {
          (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
        }
        inst.snapElements[i].snapping = false;
        continue;
      }

      if (o.snapMode !== "inner") {
        ts = Math.abs(t - y2) <= d;
        bs = Math.abs(b - y1) <= d;
        ls = Math.abs(l - x2) <= d;
        rs = Math.abs(r - x1) <= d;
        if (ts) {
          ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
        }
        if (bs) {
          ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
        }
        if (ls) {
          ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
        }
        if (rs) {
          ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
        }
      }

      first = (ts || bs || ls || rs);

      if (o.snapMode !== "outer") {
        ts = Math.abs(t - y1) <= d;
        bs = Math.abs(b - y2) <= d;
        ls = Math.abs(l - x1) <= d;
        rs = Math.abs(r - x2) <= d;
        if (ts) {
          ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
        }
        if (bs) {
          ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
        }
        if (ls) {
          ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
        }
        if (rs) {
          ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
        }
      }

      if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
        (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
      }
      inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

    }

  }
});

$.ui.plugin.add("draggable", "stack", {
  start: function( event, ui, instance ) {
    var min,
      o = instance.options,
      group = $.makeArray($(o.stack)).sort(function(a, b) {
        return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
      });

    if (!group.length) { return; }

    min = parseInt($(group[0]).css("zIndex"), 10) || 0;
    $(group).each(function(i) {
      $(this).css("zIndex", min + i);
    });
    this.css("zIndex", (min + group.length));
  }
});

$.ui.plugin.add("draggable", "zIndex", {
  start: function( event, ui, instance ) {
    var t = $( ui.helper ),
      o = instance.options;

    if (t.css("zIndex")) {
      o._zIndex = t.css("zIndex");
    }
    t.css("zIndex", o.zIndex);
  },
  stop: function( event, ui, instance ) {
    var o = instance.options;

    if (o._zIndex) {
      $(ui.helper).css("zIndex", o._zIndex);
    }
  }
});

return $.ui.draggable;

}));

define('@qubit---toggle-slider@1.3.2/draggable',['require','@qubit/jquery-ui/draggable','@qubit/jquery','@qubit/underscore'],function (require) {

  /**
   * Make a component draggable
   * The position is saved to the model and the component is positioned
   * absolutely based on the saved position upon rendering
   */

  require("@qubit/jquery-ui/draggable");
  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");

  var d = function draggable(component, api) {

    var $el = $(component.el);
    var model = component.model;
    var $window = $(window);

    model.on("change:offset change:anchor", reposition, this);

    // reposition now in case component is already rendered
    reposition();

    // and reposition everytime the component is rerendered
    component.render = _.wrap(component.render, function (render) {
      render.apply(component);
      reposition();
    });

    makeDraggable($el);

    return draggableAPI();

    function draggableAPI() {
      return {
        remove: function () {
          makeUndraggable($el);
          model.off("change:offset change:anchor", reposition);
        }
      };
    }

    function reposition() {
      d.reposition(component);
    }

    function handleDragStart() {
      api.tools.hide();
    }

    function handleDragStop(e, ui) {
      api.tools.show();
      model.set({
        anchor: half(ui.position.top),
        offset: offset(ui.position.top)
      });
    }

    function half(top) {
      var wm = $window.height() / 2;
      var cm = top + ($el.outerHeight() / 2);
      return wm < cm ? "bottom" : "top";
    }

    function offset(top) {
      if (half(top) === "top") {
        return top;
      } else {
        return $window.height() - top - $el.outerHeight();
      }
    }

    function makeDraggable($el) {
      if (!$el.data("ui-draggable")) {
        $el.draggable({
          start: handleDragStart,
          stop: handleDragStop,
          axis: "y",
          cancel: "[contenteditable='true'], .ui-draggable .ui-draggable"
        });
      }
    }

    function makeUndraggable($el) {
      if ($el.data("ui-draggable")) {
        $el.draggable("destroy");
      }
    }
  };

  d.reposition = function (component) {
    var anchor = component.model.get("anchor");
    var oppositeAnchor = (anchor === "top") ? "bottom" : "top";
    $(component.el)
      .css(oppositeAnchor, "auto")
      .css(anchor, component.model.get("offset"));
  };

  return d;

});


define('@qubit---css@0.1.6/css!@qubit---toggle-slider@1.3.2/style',[],function(){});
define('@qubit---toggle-slider@1.3.2/index',['require','exports','module','@qubit/jquery','@qubit/underscore','./draggable','@qubit/css!./style'],function (require, exports, module) {/**
 * Deps
 */

var $ = require("@qubit/jquery");
var _ = require("@qubit/underscore");
var draggable = require("./draggable");

require("@qubit/css!./style");

var ANIMATION_DURATION = 600;

/**
 * Constructor
 * @param {Object} options
 * @param {Object} api
 */
function ToggleSlider() {
  this.initialize.apply(this, arguments);
}

/**
 * Initialize method called by constructor
 * @param  {Object} options
 */
ToggleSlider.prototype.initialize = function (options) {
  this.api = options.api;
  this.model = options.model;
  this.state = {
    opened: false
  };

  if (!this.model.get("toggleWidth")) {
    this.model.set("toggleWidth", "50px");
  }

  if (!this.model.get("css")) {
    this.model.set("css", {
      width: "350px",
      height: "180px"
    });
  }

  this.el = options.el || document.createElement("div");
  this.$el = $(this.el).addClass("deliver-component deliver-component-ToggleSlider");
  this.$el.on("click", ".deliver-component-ToggleSlider-toggle", _.bind(this.handleToggle, this));

  this.animate = options.animate === undefined ? true : options.animate;

  this.model.on("change", this.render, this);
};

ToggleSlider.prototype.remove = function () {
  this.draggable && this.draggable.remove();
  this.$el.remove();
};

ToggleSlider.prototype.render = function () {
  // apply slider css
  this.applyCss();

  // remove the animation right before rendering
  // the size/position in case we're rerendering
  // due to changed settings - we want the component
  // tools to be positioned correctly
  if (this.animate) {
    this.$el.css("transition", "");
  }

  // append the container on the first render
  // don't touch afterwards since it might contain children
  if (this.$el.find(".deliver-component-ToggleSlider-container").length === 0) {
    this.$el.append($("<div>")
      .addClass("deliver-component-ToggleSlider-container")
      .addClass("deliver-allowChildren"));
  }

  // render the right offset
  this.renderRightOffset();

  // enable the animation now, so that clicking will animate
  if (this.animate) {
    var $el = this.$el;
    // we need a timeout here, because otherwise, the browser ignores
    // 'disabling' of the animation above.
    setTimeout(function () {
      $el.css("transition", "right " + (ANIMATION_DURATION / 1000) + "s ease");
    }, 1);
  }

  this.renderToggle();
  return this;
};

ToggleSlider.prototype.componentDidMount = function () {
  if (this.api.inEditor()) {
    this.api.draggable.disable();
    this.draggable = draggable(this, this.api);
  } else {
    draggable.reposition(this);
  }
};

ToggleSlider.prototype.renderRightOffset = function () {
  var opened = this.state.opened;
  var css = this.model.get("css") || {};
  var width = parseInt(css.width, 10);
  var toggleWidth = parseInt(this.model.get("toggleWidth"), 10);
  if (opened) {
    this.$el.css({
      right: 0,
      left: ""
    });
  } else {
    this.$el.css({
      right: -(width - toggleWidth),
      left: ""
    });
  }
};

ToggleSlider.prototype.renderToggle = function () {
  this.$el.find(".deliver-component-ToggleSlider-toggle").remove();
  var $toggle = $("<div/>").addClass("deliver-component-ToggleSlider-toggle").css({
    width: this.model.get("toggleWidth")
  });
  $toggle.addClass("deliver-component-ToggleSlider-toggle");
  $toggle.appendTo(this.$el);
};

ToggleSlider.prototype.applyCss = function () {
  var css = this.model.get("css");
  if (css) this.$el.css(this.model.get("css"));
};

ToggleSlider.prototype.setState = function (nextState) {
  this.state = $.extend({}, this.state, nextState);
};

ToggleSlider.prototype.handleToggle = function () {
  this.setState({
    opened: !this.state.opened
  });
  this.slide(this.state.opened);
};

ToggleSlider.prototype.slide = function () {
  this.renderRightOffset();
  var api = this.api;
  if (api.inEditor()) {
    setTimeout(function () {
      api.tools.hide();
    }, 0);
    setTimeout(function () {
      api.tools.show();
    }, ANIMATION_DURATION + 5);
  }
};

ToggleSlider.prototype.showUploadPrompt = function () {
  var api = this.api;
  var model = this.model;
  api.imageUploader.show(function (url) {
    if (url) {
      model.set("css.backgroundImage", "url(" + url + ")");
    }
  });
};

module.exports = ToggleSlider;

});

define('@qubit---toggle-slider@1.3.2', ['@qubit---toggle-slider@1.3.2/index'], function (main) { return main; });

/*!
 * jQuery UI Resizable 1.11.3
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 */
(function( factory ) {
  if ( typeof define === "function" && define.amd ) {

    // AMD. Register as an anonymous module.
    define('@qubit---jquery-ui@1.11.3/resizable',[
      "jquery",
      "./core",
      "./mouse",
      "./widget"
    ], factory );
  } else {

    // Browser globals
    factory( jQuery );
  }
}(function( $ ) {

$.widget("ui.resizable", $.ui.mouse, {
  version: "1.11.3",
  widgetEventPrefix: "resize",
  options: {
    alsoResize: false,
    animate: false,
    animateDuration: "slow",
    animateEasing: "swing",
    aspectRatio: false,
    autoHide: false,
    containment: false,
    ghost: false,
    grid: false,
    handles: "e,s,se",
    helper: false,
    maxHeight: null,
    maxWidth: null,
    minHeight: 10,
    minWidth: 10,
    // See #7960
    zIndex: 90,

    // callbacks
    resize: null,
    start: null,
    stop: null
  },

  _num: function( value ) {
    return parseInt( value, 10 ) || 0;
  },

  _isNumber: function( value ) {
    return !isNaN( parseInt( value, 10 ) );
  },

  _hasScroll: function( el, a ) {

    if ( $( el ).css( "overflow" ) === "hidden") {
      return false;
    }

    var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
      has = false;

    if ( el[ scroll ] > 0 ) {
      return true;
    }

    // TODO: determine which cases actually cause this to happen
    // if the element doesn't have the scroll set, see if it's possible to
    // set the scroll
    el[ scroll ] = 1;
    has = ( el[ scroll ] > 0 );
    el[ scroll ] = 0;
    return has;
  },

  _create: function() {

    var n, i, handle, axis, hname,
      that = this,
      o = this.options;
    this.element.addClass("ui-resizable");

    $.extend(this, {
      _aspectRatio: !!(o.aspectRatio),
      aspectRatio: o.aspectRatio,
      originalElement: this.element,
      _proportionallyResizeElements: [],
      _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
    });

    // Wrap the element if it cannot hold child nodes
    if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {

      this.element.wrap(
        $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
          position: this.element.css("position"),
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          top: this.element.css("top"),
          left: this.element.css("left")
        })
      );

      this.element = this.element.parent().data(
        "ui-resizable", this.element.resizable( "instance" )
      );

      this.elementIsWrapper = true;

      this.element.css({
        marginLeft: this.originalElement.css("marginLeft"),
        marginTop: this.originalElement.css("marginTop"),
        marginRight: this.originalElement.css("marginRight"),
        marginBottom: this.originalElement.css("marginBottom")
      });
      this.originalElement.css({
        marginLeft: 0,
        marginTop: 0,
        marginRight: 0,
        marginBottom: 0
      });
      // support: Safari
      // Prevent Safari textarea resize
      this.originalResizeStyle = this.originalElement.css("resize");
      this.originalElement.css("resize", "none");

      this._proportionallyResizeElements.push( this.originalElement.css({
        position: "static",
        zoom: 1,
        display: "block"
      }) );

      // support: IE9
      // avoid IE jump (hard set the margin)
      this.originalElement.css({ margin: this.originalElement.css("margin") });

      this._proportionallyResize();
    }

    this.handles = o.handles ||
      ( !$(".ui-resizable-handle", this.element).length ?
        "e,s,se" : {
          n: ".ui-resizable-n",
          e: ".ui-resizable-e",
          s: ".ui-resizable-s",
          w: ".ui-resizable-w",
          se: ".ui-resizable-se",
          sw: ".ui-resizable-sw",
          ne: ".ui-resizable-ne",
          nw: ".ui-resizable-nw"
        } );

    if (this.handles.constructor === String) {

      if ( this.handles === "all") {
        this.handles = "n,e,s,w,se,sw,ne,nw";
      }

      n = this.handles.split(",");
      this.handles = {};

      for (i = 0; i < n.length; i++) {

        handle = $.trim(n[i]);
        hname = "ui-resizable-" + handle;
        axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

        axis.css({ zIndex: o.zIndex });

        // TODO : What's going on here?
        if ("se" === handle) {
          axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
        }

        this.handles[handle] = ".ui-resizable-" + handle;
        this.element.append(axis);
      }

    }

    this._renderAxis = function(target) {

      var i, axis, padPos, padWrapper;

      target = target || this.element;

      for (i in this.handles) {

        if (this.handles[i].constructor === String) {
          this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
        }

        if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {

          axis = $(this.handles[i], this.element);

          padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

          padPos = [ "padding",
            /ne|nw|n/.test(i) ? "Top" :
            /se|sw|s/.test(i) ? "Bottom" :
            /^e$/.test(i) ? "Right" : "Left" ].join("");

          target.css(padPos, padWrapper);

          this._proportionallyResize();

        }

        // TODO: What's that good for? There's not anything to be executed left
        if (!$(this.handles[i]).length) {
          continue;
        }
      }
    };

    // TODO: make renderAxis a prototype function
    this._renderAxis(this.element);

    this._handles = $(".ui-resizable-handle", this.element)
      .disableSelection();

    this._handles.mouseover(function() {
      if (!that.resizing) {
        if (this.className) {
          axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
        }
        that.axis = axis && axis[1] ? axis[1] : "se";
      }
    });

    if (o.autoHide) {
      this._handles.hide();
      $(this.element)
        .addClass("ui-resizable-autohide")
        .mouseenter(function() {
          if (o.disabled) {
            return;
          }
          $(this).removeClass("ui-resizable-autohide");
          that._handles.show();
        })
        .mouseleave(function() {
          if (o.disabled) {
            return;
          }
          if (!that.resizing) {
            $(this).addClass("ui-resizable-autohide");
            that._handles.hide();
          }
        });
    }

    this._mouseInit();

  },

  _destroy: function() {

    this._mouseDestroy();

    var wrapper,
      _destroy = function(exp) {
        $(exp)
          .removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
          .removeData("resizable")
          .removeData("ui-resizable")
          .unbind(".resizable")
          .find(".ui-resizable-handle")
            .remove();
      };

    // TODO: Unwrap at same DOM position
    if (this.elementIsWrapper) {
      _destroy(this.element);
      wrapper = this.element;
      this.originalElement.css({
        position: wrapper.css("position"),
        width: wrapper.outerWidth(),
        height: wrapper.outerHeight(),
        top: wrapper.css("top"),
        left: wrapper.css("left")
      }).insertAfter( wrapper );
      wrapper.remove();
    }

    this.originalElement.css("resize", this.originalResizeStyle);
    _destroy(this.originalElement);

    return this;
  },

  _mouseCapture: function(event) {
    var i, handle,
      capture = false;

    for (i in this.handles) {
      handle = $(this.handles[i])[0];
      if (handle === event.target || $.contains(handle, event.target)) {
        capture = true;
      }
    }

    return !this.options.disabled && capture;
  },

  _mouseStart: function(event) {

    var curleft, curtop, cursor,
      o = this.options,
      el = this.element;

    this.resizing = true;

    this._renderProxy();

    curleft = this._num(this.helper.css("left"));
    curtop = this._num(this.helper.css("top"));

    if (o.containment) {
      curleft += $(o.containment).scrollLeft() || 0;
      curtop += $(o.containment).scrollTop() || 0;
    }

    this.offset = this.helper.offset();
    this.position = { left: curleft, top: curtop };

    this.size = this._helper ? {
        width: this.helper.width(),
        height: this.helper.height()
      } : {
        width: el.width(),
        height: el.height()
      };

    this.originalSize = this._helper ? {
        width: el.outerWidth(),
        height: el.outerHeight()
      } : {
        width: el.width(),
        height: el.height()
      };

    this.sizeDiff = {
      width: el.outerWidth() - el.width(),
      height: el.outerHeight() - el.height()
    };

    this.originalPosition = { left: curleft, top: curtop };
    this.originalMousePosition = { left: event.pageX, top: event.pageY };

    this.aspectRatio = (typeof o.aspectRatio === "number") ?
      o.aspectRatio :
      ((this.originalSize.width / this.originalSize.height) || 1);

    cursor = $(".ui-resizable-" + this.axis).css("cursor");
    $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

    el.addClass("ui-resizable-resizing");
    this._propagate("start", event);
    return true;
  },

  _mouseDrag: function(event) {

    var data, props,
      smp = this.originalMousePosition,
      a = this.axis,
      dx = (event.pageX - smp.left) || 0,
      dy = (event.pageY - smp.top) || 0,
      trigger = this._change[a];

    this._updatePrevProperties();

    if (!trigger) {
      return false;
    }

    data = trigger.apply(this, [ event, dx, dy ]);

    this._updateVirtualBoundaries(event.shiftKey);
    if (this._aspectRatio || event.shiftKey) {
      data = this._updateRatio(data, event);
    }

    data = this._respectSize(data, event);

    this._updateCache(data);

    this._propagate("resize", event);

    props = this._applyChanges();

    if ( !this._helper && this._proportionallyResizeElements.length ) {
      this._proportionallyResize();
    }

    if ( !$.isEmptyObject( props ) ) {
      this._updatePrevProperties();
      this._trigger( "resize", event, this.ui() );
      this._applyChanges();
    }

    return false;
  },

  _mouseStop: function(event) {

    this.resizing = false;
    var pr, ista, soffseth, soffsetw, s, left, top,
      o = this.options, that = this;

    if (this._helper) {

      pr = this._proportionallyResizeElements;
      ista = pr.length && (/textarea/i).test(pr[0].nodeName);
      soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
      soffsetw = ista ? 0 : that.sizeDiff.width;

      s = {
        width: (that.helper.width()  - soffsetw),
        height: (that.helper.height() - soffseth)
      };
      left = (parseInt(that.element.css("left"), 10) +
        (that.position.left - that.originalPosition.left)) || null;
      top = (parseInt(that.element.css("top"), 10) +
        (that.position.top - that.originalPosition.top)) || null;

      if (!o.animate) {
        this.element.css($.extend(s, { top: top, left: left }));
      }

      that.helper.height(that.size.height);
      that.helper.width(that.size.width);

      if (this._helper && !o.animate) {
        this._proportionallyResize();
      }
    }

    $("body").css("cursor", "auto");

    this.element.removeClass("ui-resizable-resizing");

    this._propagate("stop", event);

    if (this._helper) {
      this.helper.remove();
    }

    return false;

  },

  _updatePrevProperties: function() {
    this.prevPosition = {
      top: this.position.top,
      left: this.position.left
    };
    this.prevSize = {
      width: this.size.width,
      height: this.size.height
    };
  },

  _applyChanges: function() {
    var props = {};

    if ( this.position.top !== this.prevPosition.top ) {
      props.top = this.position.top + "px";
    }
    if ( this.position.left !== this.prevPosition.left ) {
      props.left = this.position.left + "px";
    }
    if ( this.size.width !== this.prevSize.width ) {
      props.width = this.size.width + "px";
    }
    if ( this.size.height !== this.prevSize.height ) {
      props.height = this.size.height + "px";
    }

    this.helper.css( props );

    return props;
  },

  _updateVirtualBoundaries: function(forceAspectRatio) {
    var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
      o = this.options;

    b = {
      minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
      maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
      minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
      maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
    };

    if (this._aspectRatio || forceAspectRatio) {
      pMinWidth = b.minHeight * this.aspectRatio;
      pMinHeight = b.minWidth / this.aspectRatio;
      pMaxWidth = b.maxHeight * this.aspectRatio;
      pMaxHeight = b.maxWidth / this.aspectRatio;

      if (pMinWidth > b.minWidth) {
        b.minWidth = pMinWidth;
      }
      if (pMinHeight > b.minHeight) {
        b.minHeight = pMinHeight;
      }
      if (pMaxWidth < b.maxWidth) {
        b.maxWidth = pMaxWidth;
      }
      if (pMaxHeight < b.maxHeight) {
        b.maxHeight = pMaxHeight;
      }
    }
    this._vBoundaries = b;
  },

  _updateCache: function(data) {
    this.offset = this.helper.offset();
    if (this._isNumber(data.left)) {
      this.position.left = data.left;
    }
    if (this._isNumber(data.top)) {
      this.position.top = data.top;
    }
    if (this._isNumber(data.height)) {
      this.size.height = data.height;
    }
    if (this._isNumber(data.width)) {
      this.size.width = data.width;
    }
  },

  _updateRatio: function( data ) {

    var cpos = this.position,
      csize = this.size,
      a = this.axis;

    if (this._isNumber(data.height)) {
      data.width = (data.height * this.aspectRatio);
    } else if (this._isNumber(data.width)) {
      data.height = (data.width / this.aspectRatio);
    }

    if (a === "sw") {
      data.left = cpos.left + (csize.width - data.width);
      data.top = null;
    }
    if (a === "nw") {
      data.top = cpos.top + (csize.height - data.height);
      data.left = cpos.left + (csize.width - data.width);
    }

    return data;
  },

  _respectSize: function( data ) {

    var o = this._vBoundaries,
      a = this.axis,
      ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
      ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
      isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
      isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
      dw = this.originalPosition.left + this.originalSize.width,
      dh = this.position.top + this.size.height,
      cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
    if (isminw) {
      data.width = o.minWidth;
    }
    if (isminh) {
      data.height = o.minHeight;
    }
    if (ismaxw) {
      data.width = o.maxWidth;
    }
    if (ismaxh) {
      data.height = o.maxHeight;
    }

    if (isminw && cw) {
      data.left = dw - o.minWidth;
    }
    if (ismaxw && cw) {
      data.left = dw - o.maxWidth;
    }
    if (isminh && ch) {
      data.top = dh - o.minHeight;
    }
    if (ismaxh && ch) {
      data.top = dh - o.maxHeight;
    }

    // Fixing jump error on top/left - bug #2330
    if (!data.width && !data.height && !data.left && data.top) {
      data.top = null;
    } else if (!data.width && !data.height && !data.top && data.left) {
      data.left = null;
    }

    return data;
  },

  _getPaddingPlusBorderDimensions: function( element ) {
    var i = 0,
      widths = [],
      borders = [
        element.css( "borderTopWidth" ),
        element.css( "borderRightWidth" ),
        element.css( "borderBottomWidth" ),
        element.css( "borderLeftWidth" )
      ],
      paddings = [
        element.css( "paddingTop" ),
        element.css( "paddingRight" ),
        element.css( "paddingBottom" ),
        element.css( "paddingLeft" )
      ];

    for ( ; i < 4; i++ ) {
      widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );
      widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );
    }

    return {
      height: widths[ 0 ] + widths[ 2 ],
      width: widths[ 1 ] + widths[ 3 ]
    };
  },

  _proportionallyResize: function() {

    if (!this._proportionallyResizeElements.length) {
      return;
    }

    var prel,
      i = 0,
      element = this.helper || this.element;

    for ( ; i < this._proportionallyResizeElements.length; i++) {

      prel = this._proportionallyResizeElements[i];

      // TODO: Seems like a bug to cache this.outerDimensions
      // considering that we are in a loop.
      if (!this.outerDimensions) {
        this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
      }

      prel.css({
        height: (element.height() - this.outerDimensions.height) || 0,
        width: (element.width() - this.outerDimensions.width) || 0
      });

    }

  },

  _renderProxy: function() {

    var el = this.element, o = this.options;
    this.elementOffset = el.offset();

    if (this._helper) {

      this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

      this.helper.addClass(this._helper).css({
        width: this.element.outerWidth() - 1,
        height: this.element.outerHeight() - 1,
        position: "absolute",
        left: this.elementOffset.left + "px",
        top: this.elementOffset.top + "px",
        zIndex: ++o.zIndex //TODO: Don't modify option
      });

      this.helper
        .appendTo("body")
        .disableSelection();

    } else {
      this.helper = this.element;
    }

  },

  _change: {
    e: function(event, dx) {
      return { width: this.originalSize.width + dx };
    },
    w: function(event, dx) {
      var cs = this.originalSize, sp = this.originalPosition;
      return { left: sp.left + dx, width: cs.width - dx };
    },
    n: function(event, dx, dy) {
      var cs = this.originalSize, sp = this.originalPosition;
      return { top: sp.top + dy, height: cs.height - dy };
    },
    s: function(event, dx, dy) {
      return { height: this.originalSize.height + dy };
    },
    se: function(event, dx, dy) {
      return $.extend(this._change.s.apply(this, arguments),
        this._change.e.apply(this, [ event, dx, dy ]));
    },
    sw: function(event, dx, dy) {
      return $.extend(this._change.s.apply(this, arguments),
        this._change.w.apply(this, [ event, dx, dy ]));
    },
    ne: function(event, dx, dy) {
      return $.extend(this._change.n.apply(this, arguments),
        this._change.e.apply(this, [ event, dx, dy ]));
    },
    nw: function(event, dx, dy) {
      return $.extend(this._change.n.apply(this, arguments),
        this._change.w.apply(this, [ event, dx, dy ]));
    }
  },

  _propagate: function(n, event) {
    $.ui.plugin.call(this, n, [ event, this.ui() ]);
    (n !== "resize" && this._trigger(n, event, this.ui()));
  },

  plugins: {},

  ui: function() {
    return {
      originalElement: this.originalElement,
      element: this.element,
      helper: this.helper,
      position: this.position,
      size: this.size,
      originalSize: this.originalSize,
      originalPosition: this.originalPosition
    };
  }

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

  stop: function( event ) {
    var that = $(this).resizable( "instance" ),
      o = that.options,
      pr = that._proportionallyResizeElements,
      ista = pr.length && (/textarea/i).test(pr[0].nodeName),
      soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
      soffsetw = ista ? 0 : that.sizeDiff.width,
      style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
      left = (parseInt(that.element.css("left"), 10) +
        (that.position.left - that.originalPosition.left)) || null,
      top = (parseInt(that.element.css("top"), 10) +
        (that.position.top - that.originalPosition.top)) || null;

    that.element.animate(
      $.extend(style, top && left ? { top: top, left: left } : {}), {
        duration: o.animateDuration,
        easing: o.animateEasing,
        step: function() {

          var data = {
            width: parseInt(that.element.css("width"), 10),
            height: parseInt(that.element.css("height"), 10),
            top: parseInt(that.element.css("top"), 10),
            left: parseInt(that.element.css("left"), 10)
          };

          if (pr && pr.length) {
            $(pr[0]).css({ width: data.width, height: data.height });
          }

          // propagating resize, and updating values for each animation step
          that._updateCache(data);
          that._propagate("resize", event);

        }
      }
    );
  }

});

$.ui.plugin.add( "resizable", "containment", {

  start: function() {
    var element, p, co, ch, cw, width, height,
      that = $( this ).resizable( "instance" ),
      o = that.options,
      el = that.element,
      oc = o.containment,
      ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

    if ( !ce ) {
      return;
    }

    that.containerElement = $( ce );

    if ( /document/.test( oc ) || oc === document ) {
      that.containerOffset = {
        left: 0,
        top: 0
      };
      that.containerPosition = {
        left: 0,
        top: 0
      };

      that.parentData = {
        element: $( document ),
        left: 0,
        top: 0,
        width: $( document ).width(),
        height: $( document ).height() || document.body.parentNode.scrollHeight
      };
    } else {
      element = $( ce );
      p = [];
      $([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
        p[ i ] = that._num( element.css( "padding" + name ) );
      });

      that.containerOffset = element.offset();
      that.containerPosition = element.position();
      that.containerSize = {
        height: ( element.innerHeight() - p[ 3 ] ),
        width: ( element.innerWidth() - p[ 1 ] )
      };

      co = that.containerOffset;
      ch = that.containerSize.height;
      cw = that.containerSize.width;
      width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
      height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

      that.parentData = {
        element: ce,
        left: co.left,
        top: co.top,
        width: width,
        height: height
      };
    }
  },

  resize: function( event ) {
    var woset, hoset, isParent, isOffsetRelative,
      that = $( this ).resizable( "instance" ),
      o = that.options,
      co = that.containerOffset,
      cp = that.position,
      pRatio = that._aspectRatio || event.shiftKey,
      cop = {
        top: 0,
        left: 0
      },
      ce = that.containerElement,
      continueResize = true;

    if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
      cop = co;
    }

    if ( cp.left < ( that._helper ? co.left : 0 ) ) {
      that.size.width = that.size.width +
        ( that._helper ?
          ( that.position.left - co.left ) :
          ( that.position.left - cop.left ) );

      if ( pRatio ) {
        that.size.height = that.size.width / that.aspectRatio;
        continueResize = false;
      }
      that.position.left = o.helper ? co.left : 0;
    }

    if ( cp.top < ( that._helper ? co.top : 0 ) ) {
      that.size.height = that.size.height +
        ( that._helper ?
          ( that.position.top - co.top ) :
          that.position.top );

      if ( pRatio ) {
        that.size.width = that.size.height * that.aspectRatio;
        continueResize = false;
      }
      that.position.top = that._helper ? co.top : 0;
    }

    isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
    isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

    if ( isParent && isOffsetRelative ) {
      that.offset.left = that.parentData.left + that.position.left;
      that.offset.top = that.parentData.top + that.position.top;
    } else {
      that.offset.left = that.element.offset().left;
      that.offset.top = that.element.offset().top;
    }

    woset = Math.abs( that.sizeDiff.width +
      (that._helper ?
        that.offset.left - cop.left :
        (that.offset.left - co.left)) );

    hoset = Math.abs( that.sizeDiff.height +
      (that._helper ?
        that.offset.top - cop.top :
        (that.offset.top - co.top)) );

    if ( woset + that.size.width >= that.parentData.width ) {
      that.size.width = that.parentData.width - woset;
      if ( pRatio ) {
        that.size.height = that.size.width / that.aspectRatio;
        continueResize = false;
      }
    }

    if ( hoset + that.size.height >= that.parentData.height ) {
      that.size.height = that.parentData.height - hoset;
      if ( pRatio ) {
        that.size.width = that.size.height * that.aspectRatio;
        continueResize = false;
      }
    }

    if ( !continueResize ) {
      that.position.left = that.prevPosition.left;
      that.position.top = that.prevPosition.top;
      that.size.width = that.prevSize.width;
      that.size.height = that.prevSize.height;
    }
  },

  stop: function() {
    var that = $( this ).resizable( "instance" ),
      o = that.options,
      co = that.containerOffset,
      cop = that.containerPosition,
      ce = that.containerElement,
      helper = $( that.helper ),
      ho = helper.offset(),
      w = helper.outerWidth() - that.sizeDiff.width,
      h = helper.outerHeight() - that.sizeDiff.height;

    if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
      $( this ).css({
        left: ho.left - cop.left - co.left,
        width: w,
        height: h
      });
    }

    if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
      $( this ).css({
        left: ho.left - cop.left - co.left,
        width: w,
        height: h
      });
    }
  }
});

$.ui.plugin.add("resizable", "alsoResize", {

  start: function() {
    var that = $(this).resizable( "instance" ),
      o = that.options,
      _store = function(exp) {
        $(exp).each(function() {
          var el = $(this);
          el.data("ui-resizable-alsoresize", {
            width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
            left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
          });
        });
      };

    if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
      if (o.alsoResize.length) {
        o.alsoResize = o.alsoResize[0];
        _store(o.alsoResize);
      } else {
        $.each(o.alsoResize, function(exp) {
          _store(exp);
        });
      }
    } else {
      _store(o.alsoResize);
    }
  },

  resize: function(event, ui) {
    var that = $(this).resizable( "instance" ),
      o = that.options,
      os = that.originalSize,
      op = that.originalPosition,
      delta = {
        height: (that.size.height - os.height) || 0,
        width: (that.size.width - os.width) || 0,
        top: (that.position.top - op.top) || 0,
        left: (that.position.left - op.left) || 0
      },

      _alsoResize = function(exp, c) {
        $(exp).each(function() {
          var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
            css = c && c.length ?
              c :
              el.parents(ui.originalElement[0]).length ?
                [ "width", "height" ] :
                [ "width", "height", "top", "left" ];

          $.each(css, function(i, prop) {
            var sum = (start[prop] || 0) + (delta[prop] || 0);
            if (sum && sum >= 0) {
              style[prop] = sum || null;
            }
          });

          el.css(style);
        });
      };

    if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
      $.each(o.alsoResize, function(exp, c) {
        _alsoResize(exp, c);
      });
    } else {
      _alsoResize(o.alsoResize);
    }
  },

  stop: function() {
    $(this).removeData("resizable-alsoresize");
  }
});

$.ui.plugin.add("resizable", "ghost", {

  start: function() {

    var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;

    that.ghost = that.originalElement.clone();
    that.ghost
      .css({
        opacity: 0.25,
        display: "block",
        position: "relative",
        height: cs.height,
        width: cs.width,
        margin: 0,
        left: 0,
        top: 0
      })
      .addClass("ui-resizable-ghost")
      .addClass(typeof o.ghost === "string" ? o.ghost : "");

    that.ghost.appendTo(that.helper);

  },

  resize: function() {
    var that = $(this).resizable( "instance" );
    if (that.ghost) {
      that.ghost.css({
        position: "relative",
        height: that.size.height,
        width: that.size.width
      });
    }
  },

  stop: function() {
    var that = $(this).resizable( "instance" );
    if (that.ghost && that.helper) {
      that.helper.get(0).removeChild(that.ghost.get(0));
    }
  }

});

$.ui.plugin.add("resizable", "grid", {

  resize: function() {
    var outerDimensions,
      that = $(this).resizable( "instance" ),
      o = that.options,
      cs = that.size,
      os = that.originalSize,
      op = that.originalPosition,
      a = that.axis,
      grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
      gridX = (grid[0] || 1),
      gridY = (grid[1] || 1),
      ox = Math.round((cs.width - os.width) / gridX) * gridX,
      oy = Math.round((cs.height - os.height) / gridY) * gridY,
      newWidth = os.width + ox,
      newHeight = os.height + oy,
      isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
      isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
      isMinWidth = o.minWidth && (o.minWidth > newWidth),
      isMinHeight = o.minHeight && (o.minHeight > newHeight);

    o.grid = grid;

    if (isMinWidth) {
      newWidth += gridX;
    }
    if (isMinHeight) {
      newHeight += gridY;
    }
    if (isMaxWidth) {
      newWidth -= gridX;
    }
    if (isMaxHeight) {
      newHeight -= gridY;
    }

    if (/^(se|s|e)$/.test(a)) {
      that.size.width = newWidth;
      that.size.height = newHeight;
    } else if (/^(ne)$/.test(a)) {
      that.size.width = newWidth;
      that.size.height = newHeight;
      that.position.top = op.top - oy;
    } else if (/^(sw)$/.test(a)) {
      that.size.width = newWidth;
      that.size.height = newHeight;
      that.position.left = op.left - ox;
    } else {
      if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {
        outerDimensions = that._getPaddingPlusBorderDimensions( this );
      }

      if ( newHeight - gridY > 0 ) {
        that.size.height = newHeight;
        that.position.top = op.top - oy;
      } else {
        newHeight = gridY - outerDimensions.height;
        that.size.height = newHeight;
        that.position.top = op.top + os.height - newHeight;
      }
      if ( newWidth - gridX > 0 ) {
        that.size.width = newWidth;
        that.position.left = op.left - ox;
      } else {
        newWidth = gridX - outerDimensions.width;
        that.size.width = newWidth;
        that.position.left = op.left + os.width - newWidth;
      }
    }
  }

});

return $.ui.resizable;

}));


define('@qubit---css@0.1.6/css!@qubit---close@1.0.2/styles/close-button',[],function(){});
define('@qubit---close@1.0.2/close-button',['require','exports','module','@qubit/jquery','@qubit/jquery-ui/draggable','@qubit/jquery-ui/resizable','css!./styles/close-button'],function (require, exports, module) {var $ = require('@qubit/jquery')
require('@qubit/jquery-ui/draggable')
require('@qubit/jquery-ui/resizable')
require('css!./styles/close-button')

function render (options) {
  options = options || {}
  if (options.type === 'none') {
    return
  }
  this.create(options)
    .on('click', options.onClick)
    .appendTo(options.container)
  return {
    remove: function () {}
  }
}

function create (opts) {
  var $a = $('<a/>')
    .addClass('deliver-component-CloseButton')
    .html('<span class=\'deliver-component-CloseButton-times\'/>')
  this.update($a, opts)
  return $a
}

function update (el, opts) {
  var $el = $(el)
  $el.css(this.getContainerCss(opts))
  $el.find('.deliver-component-CloseButton-times')
    .css(this.getCss(opts))
    .html(opts.type === 'transparent' ? '' : '&times;')
  if (opts.type === 'transparent') {
    $el.addClass('deliver-component-CloseButton--transparent')
  } else {
    $el.removeClass('deliver-component-CloseButton--transparent')
  }
  return $el
}

function getContainerCss (opts) {
  return {
    width: opts.width,
    height: opts.height,
    top: opts.top,
    right: opts.right,
    bottom: opts.bottom,
    left: opts.left
  }
}

function getCss (opts) {
  var css = {
    color: opts.color,
    lineHeight: opts.width + 'px',
    fontSize: opts.width * 1.8 + 'px',
    marginLeft: -0.02 * opts.width
  }

  if (opts.type === 'thin') {
    // different positioning than the Thick button
    // due to differences in Arial and Times New Roman
    // font, but keep the same absolute dimensions
    // i.e. the same amount of overall top/bottom and left
    // margins
    css.marginBottom = 0.02 * opts.width
    css.fontFamily = 'Times New Roman, serif'
    css.fontWeight = 'normal'
  }

  if (opts.type === 'thick') {
    css.marginTop = 0.02 * opts.width
    css.fontFamily = 'Arial, sans-serif'
    css.fontWeight = 'bold'
  }

  return css
}

function isCloseButton (el) {
  return !!$(el).closest('.deliver-component-CloseButton').length
}

module.exports = {
  render: render,
  create: create,
  update: update,
  getContainerCss: getContainerCss,
  getCss: getCss,
  isCloseButton: isCloseButton
}

});

define('@qubit---close@1.0.2/settings/convert-duration-to-ms',['require','exports','module'],function (require, exports, module) {module.exports = function convertDurationToMs (durationString) {
  var map = {
    'minutes': 60 * 1000,
    'hours': 60 * 60 * 1000,
    'days': 24 * 60 * 60 * 1000,
    'weeks': 7 * 24 * 60 * 60 * 1000
  }
  var duration = parse(durationString)
  var multiplier = map[duration.unit] || 1
  return Number(duration.amount) * multiplier
}

function parse (str) {
  var parts = str.match(/([\d.]+)(\D+)/) || []
  return {
    amount: parts[1],
    unit: parts[2]
  }
}

});

define('@qubit---modal@0.1.0/lib/css',['require','exports','module','@qubit/jquery'],function (require, exports, module) {var $ = require("@qubit/jquery");

module.exports = function applyCss(el, config) {
  if (config.css) {
    $(el).css(config.css);
  }
};

});

define('@qubit---modal@0.1.0/lib/defaults',['require','exports','module'],function (require, exports, module) {module.exports = {
  overlay: {
    css: {
      background: "#141414"
    },
    autoShow: false,
    opacity: 0.8
  },
  modal: {
    overlay: true,
    animation: {
      speed: "400",
      type: "fade",
      delay: "0",
      direction: "down"
    },
    position: {
      my: "center center",
      x: "0px",
      y: "0px",
      fixed: true
    },
    css: {
      backgroundColor: "#fff",
      width: "400px",
      height: "200px",
      boxShadow: "0px 5px 20px 0px rgba(0, 0, 0, 0.2)"
    },
    closeButton: {
      type: "none",
      durationType: "forever",
      durationString: "730days",
      top: 15,
      right: 15,
      bottom: "auto",
      left: "auto",
      width: 15,
      height: 15,
      color: "#000000",
      fontSize: "32px"
    }
  }
};

});

define('@qubit---such-dom@1.1.3/such-dom',['require','@qubit/underscore','@qubit/jquery','@qubit/jquery-ui/position'],function (require) {

  var _ = require("@qubit/underscore");
  var $ = require("@qubit/jquery");
  require("@qubit/jquery-ui/position");

  var suchDom = {

    // patch jquery.fn.position by using suchDom.offset
    // and setting necessary css position based on target
    position: function ($el, options) {
      var $target = $(options.of);
      var shouldBeFixed = positionIs($target, "fixed") || suchDom.withinFixedElement($target);
      // css position MUST be set before $el.position is called!
      $el.css("position", shouldBeFixed ? "fixed" : "absolute");
      $el.position(_.extend({}, options, {
        using: function (css, ui) {
          // proposed top left values for the $el
          // after being positioned, based on the
          // options passed to the position method
          var proposedCoords = {
            top: ui.element.top,
            left: ui.element.left
          };
          $el.css(suchDom.getTopLeftCss($target, proposedCoords));
        }
      }));
    },

    // calculate the jquery offset of an $el
    // with the correct axis based on it's
    // css position and the body's position,
    // margin, padding & border
    offset: function ($el, customOffset) {
      var offset = customOffset || $el.offset();
      var bodyAdjustment = getBodyAdjustment($el);
      offset.top += bodyAdjustment.top;
      offset.left += bodyAdjustment.left;
      return offset;
    },

    // get correct (top, left) css values based
    // on whether $el is position:fixed, has
    // a position: fixed parent or otherwise
    getTopLeftCss: function ($el, customOffset) {
      var css = suchDom.offset($el, customOffset);
      var $window = $(window);
      var isFixed = positionIs($el, "fixed");
      var withinFixed = isFixed || suchDom.withinFixedElement($el);
      if (withinFixed) {
        // use top left corner of window
        // as axis (instead of document)
        css.top -= $window.scrollTop();
        css.left -= $window.scrollLeft();
      }
      return css;
    },

    // checks whether a DOM element has a
    // parent which has fixed position
    withinFixedElement: function (el) {
      var $el = $(el);
      var $fixedParent = $el.parents().filter(function (i, el) {
        return positionIs($(el), "fixed");
      });
      var hasFixedParent = !!$fixedParent.length;
      var isAbsolute = positionIs($el, "absolute");
      // if el is absolute position then it behaves
      // in a different way inside fixed elements
      return (hasFixedParent && !isAbsolute);
    },

    wow: function () {}

  };

  return suchDom;

  function positionIs($el, position) {
    return $el.css("position") === position;
  }

  function getBodyAdjustment($el) {
    var $body = $("body");
    var relative = positionIs($body, "relative");
    var top = 0;
    var left = 0;
    if (relative && !suchDom.withinFixedElement($el)) {
      // when body position is relative (e.g. after dragging in jquery-ui)
      // all position absolute elements in the body will get a new axis
      // (this top / left coordinates of the body)
      top = -parseFloat($body.css("margin-top"));
      left = -parseFloat($body.css("margin-left"));
    } else {
      // jquery offset() ignores any body borders
      // so we have to add them on
      top = parseFloat($body.css("border-top"));
      left = parseFloat($body.css("border-left"));
    }
    return {
      top: top,
      left: left
    };
  }

});

define('@qubit---such-dom@1.1.3', ['@qubit---such-dom@1.1.3/such-dom'], function (main) { return main; });

define('@qubit---modal@0.1.0/lib/position',['require','exports','module','@qubit/jquery','@qubit/such-dom','@qubit/jquery-ui/position'],function (require, exports, module) {var $ = require("@qubit/jquery");
var suchDom = require("@qubit/such-dom");
require("@qubit/jquery-ui/position");

var position;

function toFixed(el, options) {
  var $clone = $(el).clone();
  var position = suchDom.offset($(el));
  position.top -= $(window).scrollTop();
  position.left -= $(window).scrollLeft();
  $clone.css(position).css({
    position: "fixed"
  }).appendTo("body");
  var newOffset = getOffset($clone.get(0), $.extend({}, {
    fixed: true
  }, options));
  $clone.remove();
  return $.extend({}, options, newOffset);
}

function toAbsolute(el, options) {
  var $clone = $(el).clone();
  var position = $(el).position();
  $clone.css(position).css({
    position: "absolute"
  }).appendTo("body");
  var newOffset = getOffset($clone.get(0), $.extend({}, {
    fixed: false
  }, options));
  $clone.remove();
  return $.extend({}, options, newOffset);
}

function getOffset(el, options) {
  var css = getPosition(el, {
    fixed: options.fixed,
    my: options.my,
    x: 0,
    y: 0
  });
  var isRight = /right/.test(options.my);
  var isBottom = /bottom/.test(options.my);
  var currentCss = $(el).position();
  var offset = {
    x: isRight ? css.left - currentCss.left : currentCss.left - css.left,
    y: isBottom ? css.top - currentCss.top : currentCss.top - css.top
  };

  if (options.fixed) {
    var scrollLeft = $(window).scrollLeft();
    offset.x += isRight ? scrollLeft : -scrollLeft;
    var scrollTop = $(window).scrollTop();
    offset.y += isBottom ? scrollTop : -scrollTop;
  }
  return offset;
}

function getPosition(el, options) {
  var container = options.fixed ? window : document;
  var $clone = $(el).clone().css({
    "position": options.fixed ? "fixed" : "absolute"
  });
  var positionOpts = {
    my: applyOffset(options),
    at: options.my,
    of: container,
    collision: "none"
  };
  var result;
  positionOpts.using = function (css) {
    result = limit($clone, container, css);
  };
  $clone.appendTo("body").position(positionOpts);
  $clone.remove();
  return result;
}

function limit(el, container, css) {
  var $container = $(container);
  var maxLeft = $container.width() - $(el).outerWidth();
  var maxTop = $container.height() - $(el).outerHeight();
  css.left = (css.left < 0) ? 0 : css.left;
  css.left = (css.left > maxLeft) ? maxLeft : css.left;
  css.top = (css.top < 0) ? 0 : css.top;
  css.top = (css.top > maxTop) ? maxTop : css.top;
  return css;
}

function applyOffset(options) {
  var i = 0;
  return options.my.replace(/(left|right|center|top|bottom)([+-]\d+)?/gi, function (match, pos) {
    var amount = parseInt(i++ ? options.y : options.x);
    if (amount === 0) {
      return pos;
    } else if (pos === "right" || pos === "bottom") {
      amount = -amount;
    }
    return pos + (amount >= 0 ? "+" : "") + amount;
  });
}

position = {
  getPosition: getPosition,
  limit: limit,
  applyOffset: applyOffset,
  getOffset: getOffset,
  toFixed: toFixed,
  toAbsolute: toAbsolute
};

module.exports = position;

});

/*
 * overlay
 * https://bitbucket.org/QuBitProducts/overlay/overview
 * created: 19 Jul 2013
 * alan@qubitproducts.com
 * Licensed under the apache license.
 */

(function () {

  function overlay($, maxz) {

    function Overlay(element, options) {
      this.init(element, options);
      return this;
    }

    Overlay.prototype = {
      options: {
        speed: 0,
        delay: 0,
        css: {
          background: "transparent"
        },
        autoShow: true,
        opacity: 1
      },
      show: function (cb) {
        var self = this;
        this.$overlay.css({
          zIndex: maxz(this.$el) + 1,
          display: "inherit",
          opacity: 0
        });
        function onComplete() {
          self.$el.trigger("deliver-overlay-show");
          if (cb) {
            cb(self);
          }
        }
        if (this.options.speed || this.options.delay) {
          this.$overlay.delay(this.options.delay || 10).fadeTo(this.options.speed, this.options.opacity, onComplete);
        } else {
          this.$overlay.show();
          onComplete();
        }
      },
      hide: function (cb) {
        var self = this;
        this.$overlay.fadeOut(this.options.speed, function () {
          self.$el.trigger("deliver-overlay-hide");
          if (cb) {
            cb(self);
          }
        });
      },
      init: function (element, options) {
        this.$el = $(element);
        this.$overlay = (this.$overlay || $("<div/>")).addClass("deliver-overlay");
        this.options = $.extend({}, this.options, options);
        this.isBody = this.$el.is("body");
        this.$container = (this.isBody ? this.$el : $('<div/>')).addClass("deliver-overlay-container");
        this.$overlay
          .appendTo(this.$container)
          .css($.extend({}, {
            position: "fixed",
            display: "block",
            width: "100%",
            height: "100%",
            top: 0,
            left: 0,
            zIndex: this.$el.css("zIndex") + 1
          }, this.options.css))
          .hide();
        if (!this.isBody) {
          var position = this.$el.css("position") || "relative";
          this._style = this.$el.attr("style");
          this.$container
            .insertAfter(this.$el)
            .append(this.$el)
            .css({
              width: this.$el.outerWidth(),
              height: this.$el.outerHeight(),
              position: position === "static" ? "relative" : position,
              padding: 0
            });
          this.copyCss("left right top bottom margin".split(" "), this.$el, this.$container);
          this.copyCss("top left bottom right margin", [0, 0, 0, 0, 0], this.$el);
        } else {
          this.$overlay.css({
            zIndex: maxz(this.$el, true, 10000) + 1
          });
        }
        if (this.options.autoShow) {
          this.show();
        }
      },
      copyCss: function (rules, $from, $to) {
        $.each(rules, function (index, name) {
          $to.css(name, $.isArray($from) ? $from[index] : $from.css(name));
        });
      },
      destroy: function () {
        this.$overlay.stop().remove();
        if (!this.isBody) {
          this.$el.attr("style", this._style);
          this.$el.insertAfter(this.$container);
          this.$container.stop().remove();
        } else {
          this.$el.removeClass("deliver-overlay-container");
        }
        this.$el.removeData("overlay");
      }
    };

    $.fn.overlay = function (options) {
      if ($.isFunction(Overlay.prototype[options])) {
        var plugin = $(this).data("overlay");
        return plugin[options].apply(plugin, Array.prototype.slice.call(arguments, 1));
      }
      return this.each(function () {
        var plugin = $.data(this, "overlay");
        if (!plugin) {
          $.data(this, "overlay", new Overlay(this, options));
        }
      });
    };
    return Overlay;
  }

  if (typeof define === 'function' && define.amd) {
    define('@qubit---overlay@1.0.1/src/overlay',["@qubit/jquery", "@qubit/maxz"], overlay);
  } else {
    overlay(jQuery);
  }
})();

define('@qubit---overlay@1.0.1', ['@qubit---overlay@1.0.1/src/overlay'], function (main) { return main; });

define('@qubit---modal@0.1.0/lib/overlay',['require','exports','module','@qubit/overlay'],function (require, exports, module) {var Overlay = require("@qubit/overlay");

/*
 singleton overlay shared between modals
*/

var overlay;

function render(options, cb) {
  if (!overlay) {
    overlay = new Overlay(document.body, options);
  } else {
    overlay.init(document.body, options);
  }
  overlay.show(cb);
  return overlay;
}

function hide(cb) {
  if (overlay) overlay.hide(cb);
}

function destroy() {
  if (overlay) overlay.destroy();
  overlay = false;
}

module.exports = {
  render: render,
  hide: hide,
  destroy: destroy
};

});

/*! VelocityJS.org (1.2.2). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */

/*************************
   Velocity jQuery Shim
*************************/

/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */

/* This file contains the jQuery functions that Velocity relies on, thereby removing Velocity's dependency on a full copy of jQuery, and allowing it to work in any environment. */
/* These shimmed functions are only used if jQuery isn't present. If both this shim and jQuery are loaded, Velocity defaults to jQuery proper. */
/* Browser support: Using this shim instead of jQuery proper removes support for IE8. */

;(function (window) {
    /***************
         Setup
    ***************/

    /* If jQuery is already loaded, there's no point in loading this shim. */
    // if (window.jQuery) {
    //     return;
    // }

    /* jQuery base. */
    var $ = function (selector, context) {
        return new $.fn.init(selector, context);
    };

    /********************
       Private Methods
    ********************/

    /* jQuery */
    $.isWindow = function (obj) {
        /* jshint eqeqeq: false */
        return obj != null && obj == obj.window;
    };

    /* jQuery */
    $.type = function (obj) {
        if (obj == null) {
            return obj + "";
        }

        return typeof obj === "object" || typeof obj === "function" ?
            class2type[toString.call(obj)] || "object" :
            typeof obj;
    };

    /* jQuery */
    $.isArray = Array.isArray || function (obj) {
        return $.type(obj) === "array";
    };

    /* jQuery */
    function isArraylike (obj) {
        var length = obj.length,
            type = $.type(obj);

        if (type === "function" || $.isWindow(obj)) {
            return false;
        }

        if (obj.nodeType === 1 && length) {
            return true;
        }

        return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
    }

    /***************
       $ Methods
    ***************/

    /* jQuery: Support removed for IE<9. */
    $.isPlainObject = function (obj) {
        var key;

        if (!obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
            return false;
        }

        try {
            if (obj.constructor &&
                !hasOwn.call(obj, "constructor") &&
                !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
        } catch (e) {
            return false;
        }

        for (key in obj) {}

        return key === undefined || hasOwn.call(obj, key);
    };

    /* jQuery */
    $.each = function(obj, callback, args) {
        var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike(obj);

        if (args) {
            if (isArray) {
                for (; i < length; i++) {
                    value = callback.apply(obj[i], args);

                    if (value === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    value = callback.apply(obj[i], args);

                    if (value === false) {
                        break;
                    }
                }
            }

        } else {
            if (isArray) {
                for (; i < length; i++) {
                    value = callback.call(obj[i], i, obj[i]);

                    if (value === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    value = callback.call(obj[i], i, obj[i]);

                    if (value === false) {
                        break;
                    }
                }
            }
        }

        return obj;
    };

    /* Custom */
    $.data = function (node, key, value) {
        /* $.getData() */
        if (value === undefined) {
            var id = node[$.expando],
                store = id && cache[id];

            if (key === undefined) {
                return store;
            } else if (store) {
                if (key in store) {
                    return store[key];
                }
            }
        /* $.setData() */
        } else if (key !== undefined) {
            var id = node[$.expando] || (node[$.expando] = ++$.uuid);

            cache[id] = cache[id] || {};
            cache[id][key] = value;

            return value;
        }
    };

    /* Custom */
    $.removeData = function (node, keys) {
        var id = node[$.expando],
            store = id && cache[id];

        if (store) {
            $.each(keys, function(_, key) {
                delete store[key];
            });
        }
    };

    /* jQuery */
    $.extend = function () {
        var src, copyIsArray, copy, name, options, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        if (typeof target === "boolean") {
            deep = target;

            target = arguments[i] || {};
            i++;
        }

        if (typeof target !== "object" && $.type(target) !== "function") {
            target = {};
        }

        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    if (target === copy) {
                        continue;
                    }

                    if (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && $.isArray(src) ? src : [];

                        } else {
                            clone = src && $.isPlainObject(src) ? src : {};
                        }

                        target[name] = $.extend(deep, clone, copy);

                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        return target;
    };

    /* jQuery 1.4.3 */
    $.queue = function (elem, type, data) {
        function $makeArray (arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    /* $.merge */
                    (function(first, second) {
                        var len = +second.length,
                            j = 0,
                            i = first.length;

                        while (j < len) {
                            first[i++] = second[j++];
                        }

                        if (len !== len) {
                            while (second[j] !== undefined) {
                                first[i++] = second[j++];
                            }
                        }

                        first.length = i;

                        return first;
                    })(ret, typeof arr === "string" ? [arr] : arr);
                } else {
                    [].push.call(ret, arr);
                }
            }

            return ret;
        }

        if (!elem) {
            return;
        }

        type = (type || "fx") + "queue";

        var q = $.data(elem, type);

        if (!data) {
            return q || [];
        }

        if (!q || $.isArray(data)) {
            q = $.data(elem, type, $makeArray(data));
        } else {
            q.push(data);
        }

        return q;
    };

    /* jQuery 1.4.3 */
    $.dequeue = function (elems, type) {
        /* Custom: Embed element iteration. */
        $.each(elems.nodeType ? [ elems ] : elems, function(i, elem) {
            type = type || "fx";

            var queue = $.queue(elem, type),
                fn = queue.shift();

            if (fn === "inprogress") {
                fn = queue.shift();
            }

            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                fn.call(elem, function() {
                    $.dequeue(elem, type);
                });
            }
        });
    };

    /******************
       $.fn Methods
    ******************/

    /* jQuery */
    $.fn = $.prototype = {
        init: function (selector) {
            /* Just return the element wrapped inside an array; don't proceed with the actual jQuery node wrapping process. */
            if (selector.nodeType) {
                this[0] = selector;

                return this;
            } else {
                throw new Error("Not a DOM node.");
            }
        },

        offset: function () {
            /* jQuery altered code: Dropped disconnected DOM node checking. */
            var box = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : { top: 0, left: 0 };

            return {
                top: box.top + (window.pageYOffset || document.scrollTop  || 0)  - (document.clientTop  || 0),
                left: box.left + (window.pageXOffset || document.scrollLeft  || 0) - (document.clientLeft || 0)
            };
        },

        position: function () {
            /* jQuery */
            function offsetParent() {
                var offsetParent = this.offsetParent || document;

                while (offsetParent && (!offsetParent.nodeType.toLowerCase === "html" && offsetParent.style.position === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || document;
            }

            /* Zepto */
            var elem = this[0],
                offsetParent = offsetParent.apply(elem),
                offset = this.offset(),
                parentOffset = /^(?:body|html)$/i.test(offsetParent.nodeName) ? { top: 0, left: 0 } : $(offsetParent).offset()

            offset.top -= parseFloat(elem.style.marginTop) || 0;
            offset.left -= parseFloat(elem.style.marginLeft) || 0;

            if (offsetParent.style) {
                parentOffset.top += parseFloat(offsetParent.style.borderTopWidth) || 0
                parentOffset.left += parseFloat(offsetParent.style.borderLeftWidth) || 0
            }

            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        }
    };

    /**********************
       Private Variables
    **********************/

    /* For $.data() */
    var cache = {};
    $.expando = "velocity" + (new Date().getTime());
    $.uuid = 0;

    /* For $.queue() */
    var class2type = {},
        hasOwn = class2type.hasOwnProperty,
        toString = class2type.toString;

    var types = "Boolean Number String Function Array Date RegExp Object Error".split(" ");
    for (var i = 0; i < types.length; i++) {
        class2type["[object " + types[i] + "]"] = types[i].toLowerCase();
    }

    /* Makes $(node) possible, without having to call init. */
    $.fn.init.prototype = $.fn;

    /* Globalize Velocity onto the window, and assign its Utilities property. */
    window.Velocity = { Utilities: $ };
})(window);

/******************
    Velocity.js
******************/

;(function (factory) {
    /* CommonJS module. */
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory();
    /* AMD module. */
    } else if (typeof define === "function" && define.amd) {
        define('@qubit---velocity@1.2.3/velocity',factory);
    /* Browser globals. */
    } else {
        factory();
    }
}(function() {
return function (global, window, document, undefined) {

    /***************
        Summary
    ***************/

    /*
    - CSS: CSS stack that works independently from the rest of Velocity.
    - animate(): Core animation method that iterates over the targeted elements and queues the incoming call onto each element individually.
      - Pre-Queueing: Prepare the element for animation by instantiating its data cache and processing the call's options.
      - Queueing: The logic that runs once the call has reached its point of execution in the element's $.queue() stack.
                  Most logic is placed here to avoid risking it becoming stale (if the element's properties have changed).
      - Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
    - tick(): The single requestAnimationFrame loop responsible for tweening all in-progress calls.
    - completeCall(): Handles the cleanup process for each Velocity call.
    */

    /*********************
       Helper Functions
    *********************/

    /* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */
    var IE = (function() {
        if (document.documentMode) {
            return document.documentMode;
        } else {
            for (var i = 7; i > 4; i--) {
                var div = document.createElement("div");

                div.innerHTML = "<!--[if IE " + i + "]><span></span><![endif]-->";

                if (div.getElementsByTagName("span").length) {
                    div = null;

                    return i;
                }
            }
        }

        return undefined;
    })();

    /* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */
    var rAFShim = (function() {
        var timeLast = 0;

        return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
            var timeCurrent = (new Date()).getTime(),
                timeDelta;

            /* Dynamically set delay on a per-tick basis to match 60fps. */
            /* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
            timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
            timeLast = timeCurrent + timeDelta;

            return setTimeout(function() { callback(timeCurrent + timeDelta); }, timeDelta);
        };
    })();

    /* Array compacting. Copyright Lo-Dash. MIT License: https://github.com/lodash/lodash/blob/master/LICENSE.txt */
    function compactSparseArray (array) {
        var index = -1,
            length = array ? array.length : 0,
            result = [];

        while (++index < length) {
            var value = array[index];

            if (value) {
                result.push(value);
            }
        }

        return result;
    }

    function sanitizeElements (elements) {
        /* Unwrap jQuery/Zepto objects. */
        if (Type.isWrapped(elements)) {
            elements = [].slice.call(elements);
        /* Wrap a single element in an array so that $.each() can iterate with the element instead of its node's children. */
        } else if (Type.isNode(elements)) {
            elements = [ elements ];
        }

        return elements;
    }

    var Type = {
        isString: function (variable) {
            return (typeof variable === "string");
        },
        isArray: Array.isArray || function (variable) {
            return Object.prototype.toString.call(variable) === "[object Array]";
        },
        isFunction: function (variable) {
            return Object.prototype.toString.call(variable) === "[object Function]";
        },
        isNode: function (variable) {
            return variable && variable.nodeType;
        },
        /* Copyright Martin Bohm. MIT License: https://gist.github.com/Tomalak/818a78a226a0738eaade */
        isNodeList: function (variable) {
            return typeof variable === "object" &&
                /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(variable)) &&
                variable.length !== undefined &&
                (variable.length === 0 || (typeof variable[0] === "object" && variable[0].nodeType > 0));
        },
        /* Determine if variable is a wrapped jQuery or Zepto element. */
        isWrapped: function (variable) {
            return variable && (variable.jquery || (window.Zepto && window.Zepto.zepto.isZ(variable)));
        },
        isSVG: function (variable) {
            return window.SVGElement && (variable instanceof window.SVGElement);
        },
        isEmptyObject: function (variable) {
            for (var name in variable) {
                return false;
            }

            return true;
        }
    };

    /*****************
       Dependencies
    *****************/

    var $,
        isJQuery = false;

    if (global.fn && global.fn.jquery) {
        $ = global;
        isJQuery = true;
    } else {
        $ = window.Velocity.Utilities;
    }

    if (IE <= 8 && !isJQuery) {
        throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
    } else if (IE <= 7) {
        /* Revert to jQuery's $.animate(), and lose Velocity's extra features. */
        jQuery.fn.velocity = jQuery.fn.animate;

        /* Now that $.fn.velocity is aliased, abort this Velocity declaration. */
        return;
    }

    /*****************
        Constants
    *****************/

    var DURATION_DEFAULT = 400,
        EASING_DEFAULT = "swing";

    /*************
        State
    *************/

    var Velocity = {
        /* Container for page-wide Velocity state data. */
        State: {
            /* Detect mobile devices to determine if mobileHA should be turned on. */
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            /* The mobileHA option's behavior changes on older Android devices (Gingerbread, versions 2.3.3-2.3.7). */
            isAndroid: /Android/i.test(navigator.userAgent),
            isGingerbread: /Android 2\.3\.[3-7]/i.test(navigator.userAgent),
            isChrome: window.chrome,
            isFirefox: /Firefox/i.test(navigator.userAgent),
            /* Create a cached element for re-use when checking for CSS property prefixes. */
            prefixElement: document.createElement("div"),
            /* Cache every prefix match to avoid repeating lookups. */
            prefixMatches: {},
            /* Cache the anchor used for animating window scrolling. */
            scrollAnchor: null,
            /* Cache the browser-specific property names associated with the scroll anchor. */
            scrollPropertyLeft: null,
            scrollPropertyTop: null,
            /* Keep track of whether our RAF tick is running. */
            isTicking: false,
            /* Container for every in-progress call to Velocity. */
            calls: []
        },
        /* Velocity's custom CSS stack. Made global for unit testing. */
        CSS: { /* Defined below. */ },
        /* A shim of the jQuery utility functions used by Velocity -- provided by Velocity's optional jQuery shim. */
        Utilities: $,
        /* Container for the user's custom animation redirects that are referenced by name in place of the properties map argument. */
        Redirects: { /* Manually registered by the user. */ },
        Easings: { /* Defined below. */ },
        /* Attempt to use ES6 Promises by default. Users can override this with a third-party promises library. */
        Promise: window.Promise,
        /* Velocity option defaults, which can be overriden by the user. */
        defaults: {
            queue: "",
            duration: DURATION_DEFAULT,
            easing: EASING_DEFAULT,
            begin: undefined,
            complete: undefined,
            progress: undefined,
            display: undefined,
            visibility: undefined,
            loop: false,
            delay: false,
            mobileHA: true,
            /* Advanced: Set to false to prevent property values from being cached between consecutive Velocity-initiated chain calls. */
            _cacheValues: true
        },
        /* A design goal of Velocity is to cache data wherever possible in order to avoid DOM requerying. Accordingly, each element has a data cache. */
        init: function (element) {
            $.data(element, "velocity", {
                /* Store whether this is an SVG element, since its properties are retrieved and updated differently than standard HTML elements. */
                isSVG: Type.isSVG(element),
                /* Keep track of whether the element is currently being animated by Velocity.
                   This is used to ensure that property values are not transferred between non-consecutive (stale) calls. */
                isAnimating: false,
                /* A reference to the element's live computedStyle object. Learn more here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
                computedStyle: null,
                /* Tween data is cached for each animation on the element so that data can be passed across calls --
                   in particular, end values are used as subsequent start values in consecutive Velocity calls. */
                tweensContainer: null,
                /* The full root property values of each CSS hook being animated on this element are cached so that:
                   1) Concurrently-animating hooks sharing the same root can have their root values' merged into one while tweening.
                   2) Post-hook-injection root values can be transferred over to consecutively chained Velocity calls as starting root values. */
                rootPropertyValueCache: {},
                /* A cache for transform updates, which must be manually flushed via CSS.flushTransformCache(). */
                transformCache: {}
            });
        },
        /* A parallel to jQuery's $.css(), used for getting/setting Velocity's hooked CSS properties. */
        hook: null, /* Defined below. */
        /* Velocity-wide animation time remapping for testing purposes. */
        mock: false,
        version: { major: 1, minor: 2, patch: 2 },
        /* Set to 1 or 2 (most verbose) to output debug info to console. */
        debug: false
    };

    /* Retrieve the appropriate scroll anchor and property name for the browser: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY */
    if (window.pageYOffset !== undefined) {
        Velocity.State.scrollAnchor = window;
        Velocity.State.scrollPropertyLeft = "pageXOffset";
        Velocity.State.scrollPropertyTop = "pageYOffset";
    } else {
        Velocity.State.scrollAnchor = document.documentElement || document.body.parentNode || document.body;
        Velocity.State.scrollPropertyLeft = "scrollLeft";
        Velocity.State.scrollPropertyTop = "scrollTop";
    }

    /* Shorthand alias for jQuery's $.data() utility. */
    function Data (element) {
        /* Hardcode a reference to the plugin name. */
        var response = $.data(element, "velocity");

        /* jQuery <=1.4.2 returns null instead of undefined when no match is found. We normalize this behavior. */
        return response === null ? undefined : response;
    };

    /**************
        Easing
    **************/

    /* Step easing generator. */
    function generateStep (steps) {
        return function (p) {
            return Math.round(p * steps) * (1 / steps);
        };
    }

    /* Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
    function generateBezier (mX1, mY1, mX2, mY2) {
        var NEWTON_ITERATIONS = 4,
            NEWTON_MIN_SLOPE = 0.001,
            SUBDIVISION_PRECISION = 0.0000001,
            SUBDIVISION_MAX_ITERATIONS = 10,
            kSplineTableSize = 11,
            kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
            float32ArraySupported = "Float32Array" in window;

        /* Must contain four arguments. */
        if (arguments.length !== 4) {
            return false;
        }

        /* Arguments must be numbers. */
        for (var i = 0; i < 4; ++i) {
            if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
                return false;
            }
        }

        /* X values must be in the [0, 1] range. */
        mX1 = Math.min(mX1, 1);
        mX2 = Math.min(mX2, 1);
        mX1 = Math.max(mX1, 0);
        mX2 = Math.max(mX2, 0);

        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

        function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
        function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
        function C (aA1)      { return 3.0 * aA1; }

        function calcBezier (aT, aA1, aA2) {
            return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
        }

        function getSlope (aT, aA1, aA2) {
            return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
        }

        function newtonRaphsonIterate (aX, aGuessT) {
            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);

                if (currentSlope === 0.0) return aGuessT;

                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }

            return aGuessT;
        }

        function calcSampleValues () {
            for (var i = 0; i < kSplineTableSize; ++i) {
                mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
        }

        function binarySubdivide (aX, aA, aB) {
            var currentX, currentT, i = 0;

            do {
                currentT = aA + (aB - aA) / 2.0;
                currentX = calcBezier(currentT, mX1, mX2) - aX;
                if (currentX > 0.0) {
                  aB = currentT;
                } else {
                  aA = currentT;
                }
            } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

            return currentT;
        }

        function getTForX (aX) {
            var intervalStart = 0.0,
                currentSample = 1,
                lastSample = kSplineTableSize - 1;

            for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
            }

            --currentSample;

            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]),
                guessForT = intervalStart + dist * kSampleStepSize,
                initialSlope = getSlope(guessForT, mX1, mX2);

            if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT);
            } else if (initialSlope == 0.0) {
                return guessForT;
            } else {
                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
            }
        }

        var _precomputed = false;

        function precompute() {
            _precomputed = true;
            if (mX1 != mY1 || mX2 != mY2) calcSampleValues();
        }

        var f = function (aX) {
            if (!_precomputed) precompute();
            if (mX1 === mY1 && mX2 === mY2) return aX;
            if (aX === 0) return 0;
            if (aX === 1) return 1;

            return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };

        var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
        f.toString = function () { return str; };

        return f;
    }

    /* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
    var generateSpringRK4 = (function () {
        function springAccelerationForState (state) {
            return (-state.tension * state.x) - (state.friction * state.v);
        }

        function springEvaluateStateWithDerivative (initialState, dt, derivative) {
            var state = {
                x: initialState.x + derivative.dx * dt,
                v: initialState.v + derivative.dv * dt,
                tension: initialState.tension,
                friction: initialState.friction
            };

            return { dx: state.v, dv: springAccelerationForState(state) };
        }

        function springIntegrateState (state, dt) {
            var a = {
                    dx: state.v,
                    dv: springAccelerationForState(state)
                },
                b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
                c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
                d = springEvaluateStateWithDerivative(state, dt, c),
                dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
                dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

            state.x = state.x + dxdt * dt;
            state.v = state.v + dvdt * dt;

            return state;
        }

        return function springRK4Factory (tension, friction, duration) {

            var initState = {
                    x: -1,
                    v: 0,
                    tension: null,
                    friction: null
                },
                path = [0],
                time_lapsed = 0,
                tolerance = 1 / 10000,
                DT = 16 / 1000,
                have_duration, dt, last_state;

            tension = parseFloat(tension) || 500;
            friction = parseFloat(friction) || 20;
            duration = duration || null;

            initState.tension = tension;
            initState.friction = friction;

            have_duration = duration !== null;

            /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
            if (have_duration) {
                /* Run the simulation without a duration. */
                time_lapsed = springRK4Factory(tension, friction);
                /* Compute the adjusted time delta. */
                dt = time_lapsed / duration * DT;
            } else {
                dt = DT;
            }

            while (true) {
                /* Next/step function .*/
                last_state = springIntegrateState(last_state || initState, dt);
                /* Store the position. */
                path.push(1 + last_state.x);
                time_lapsed += 16;
                /* If the change threshold is reached, break. */
                if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
                    break;
                }
            }

            /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
               computed path and returns a snapshot of the position according to a given percentComplete. */
            return !have_duration ? time_lapsed : function(percentComplete) { return path[ (percentComplete * (path.length - 1)) | 0 ]; };
        };
    }());

    /* jQuery easings. */
    Velocity.Easings = {
        linear: function(p) { return p; },
        swing: function(p) { return 0.5 - Math.cos( p * Math.PI ) / 2 },
        /* Bonus "spring" easing, which is a less exaggerated version of easeInOutElastic. */
        spring: function(p) { return 1 - (Math.cos(p * 4.5 * Math.PI) * Math.exp(-p * 6)); }
    };

    /* CSS3 and Robert Penner easings. */
    $.each(
        [
            [ "ease", [ 0.25, 0.1, 0.25, 1.0 ] ],
            [ "ease-in", [ 0.42, 0.0, 1.00, 1.0 ] ],
            [ "ease-out", [ 0.00, 0.0, 0.58, 1.0 ] ],
            [ "ease-in-out", [ 0.42, 0.0, 0.58, 1.0 ] ],
            [ "easeInSine", [ 0.47, 0, 0.745, 0.715 ] ],
            [ "easeOutSine", [ 0.39, 0.575, 0.565, 1 ] ],
            [ "easeInOutSine", [ 0.445, 0.05, 0.55, 0.95 ] ],
            [ "easeInQuad", [ 0.55, 0.085, 0.68, 0.53 ] ],
            [ "easeOutQuad", [ 0.25, 0.46, 0.45, 0.94 ] ],
            [ "easeInOutQuad", [ 0.455, 0.03, 0.515, 0.955 ] ],
            [ "easeInCubic", [ 0.55, 0.055, 0.675, 0.19 ] ],
            [ "easeOutCubic", [ 0.215, 0.61, 0.355, 1 ] ],
            [ "easeInOutCubic", [ 0.645, 0.045, 0.355, 1 ] ],
            [ "easeInQuart", [ 0.895, 0.03, 0.685, 0.22 ] ],
            [ "easeOutQuart", [ 0.165, 0.84, 0.44, 1 ] ],
            [ "easeInOutQuart", [ 0.77, 0, 0.175, 1 ] ],
            [ "easeInQuint", [ 0.755, 0.05, 0.855, 0.06 ] ],
            [ "easeOutQuint", [ 0.23, 1, 0.32, 1 ] ],
            [ "easeInOutQuint", [ 0.86, 0, 0.07, 1 ] ],
            [ "easeInExpo", [ 0.95, 0.05, 0.795, 0.035 ] ],
            [ "easeOutExpo", [ 0.19, 1, 0.22, 1 ] ],
            [ "easeInOutExpo", [ 1, 0, 0, 1 ] ],
            [ "easeInCirc", [ 0.6, 0.04, 0.98, 0.335 ] ],
            [ "easeOutCirc", [ 0.075, 0.82, 0.165, 1 ] ],
            [ "easeInOutCirc", [ 0.785, 0.135, 0.15, 0.86 ] ]
        ], function(i, easingArray) {
            Velocity.Easings[easingArray[0]] = generateBezier.apply(null, easingArray[1]);
        });

    /* Determine the appropriate easing type given an easing input. */
    function getEasing(value, duration) {
        var easing = value;

        /* The easing option can either be a string that references a pre-registered easing,
           or it can be a two-/four-item array of integers to be converted into a bezier/spring function. */
        if (Type.isString(value)) {
            /* Ensure that the easing has been assigned to jQuery's Velocity.Easings object. */
            if (!Velocity.Easings[value]) {
                easing = false;
            }
        } else if (Type.isArray(value) && value.length === 1) {
            easing = generateStep.apply(null, value);
        } else if (Type.isArray(value) && value.length === 2) {
            /* springRK4 must be passed the animation's duration. */
            /* Note: If the springRK4 array contains non-numbers, generateSpringRK4() returns an easing
               function generated with default tension and friction values. */
            easing = generateSpringRK4.apply(null, value.concat([ duration ]));
        } else if (Type.isArray(value) && value.length === 4) {
            /* Note: If the bezier array contains non-numbers, generateBezier() returns false. */
            easing = generateBezier.apply(null, value);
        } else {
            easing = false;
        }

        /* Revert to the Velocity-wide default easing type, or fall back to "swing" (which is also jQuery's default)
           if the Velocity-wide default has been incorrectly modified. */
        if (easing === false) {
            if (Velocity.Easings[Velocity.defaults.easing]) {
                easing = Velocity.defaults.easing;
            } else {
                easing = EASING_DEFAULT;
            }
        }

        return easing;
    }

    /*****************
        CSS Stack
    *****************/

    /* The CSS object is a highly condensed and performant CSS stack that fully replaces jQuery's.
       It handles the validation, getting, and setting of both standard CSS properties and CSS property hooks. */
    /* Note: A "CSS" shorthand is aliased so that our code is easier to read. */
    var CSS = Velocity.CSS = {

        /*************
            RegEx
        *************/

        RegEx: {
            isHex: /^#([A-f\d]{3}){1,2}$/i,
            /* Unwrap a property value's surrounding text, e.g. "rgba(4, 3, 2, 1)" ==> "4, 3, 2, 1" and "rect(4px 3px 2px 1px)" ==> "4px 3px 2px 1px". */
            valueUnwrap: /^[A-z]+\((.*)\)$/i,
            wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
            /* Split a multi-value property into an array of subvalues, e.g. "rgba(4, 3, 2, 1) 4px 3px 2px 1px" ==> [ "rgba(4, 3, 2, 1)", "4px", "3px", "2px", "1px" ]. */
            valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/ig
        },

        /************
            Lists
        ************/

        Lists: {
            colors: [ "fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor" ],
            transformsBase: [ "translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ" ],
            transforms3D: [ "transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY" ]
        },

        /************
            Hooks
        ************/

        /* Hooks allow a subproperty (e.g. "boxShadowBlur") of a compound-value CSS property
           (e.g. "boxShadow: X Y Blur Spread Color") to be animated as if it were a discrete property. */
        /* Note: Beyond enabling fine-grained property animation, hooking is necessary since Velocity only
           tweens properties with single numeric values; unlike CSS transitions, Velocity does not interpolate compound-values. */
        Hooks: {
            /********************
                Registration
            ********************/

            /* Templates are a concise way of indicating which subproperties must be individually registered for each compound-value CSS property. */
            /* Each template consists of the compound-value's base name, its constituent subproperty names, and those subproperties' default values. */
            templates: {
                "textShadow": [ "Color X Y Blur", "black 0px 0px 0px" ],
                "boxShadow": [ "Color X Y Blur Spread", "black 0px 0px 0px 0px" ],
                "clip": [ "Top Right Bottom Left", "0px 0px 0px 0px" ],
                "backgroundPosition": [ "X Y", "0% 0%" ],
                "transformOrigin": [ "X Y Z", "50% 50% 0px" ],
                "perspectiveOrigin": [ "X Y", "50% 50%" ]
            },

            /* A "registered" hook is one that has been converted from its template form into a live,
               tweenable property. It contains data to associate it with its root property. */
            registered: {
                /* Note: A registered hook looks like this ==> textShadowBlur: [ "textShadow", 3 ],
                   which consists of the subproperty's name, the associated root property's name,
                   and the subproperty's position in the root's value. */
            },
            /* Convert the templates into individual hooks then append them to the registered object above. */
            register: function () {
                /* Color hooks registration: Colors are defaulted to white -- as opposed to black -- since colors that are
                   currently set to "transparent" default to their respective template below when color-animated,
                   and white is typically a closer match to transparent than black is. An exception is made for text ("color"),
                   which is almost always set closer to black than white. */
                for (var i = 0; i < CSS.Lists.colors.length; i++) {
                    var rgbComponents = (CSS.Lists.colors[i] === "color") ? "0 0 0 1" : "255 255 255 1";
                    CSS.Hooks.templates[CSS.Lists.colors[i]] = [ "Red Green Blue Alpha", rgbComponents ];
                }

                var rootProperty,
                    hookTemplate,
                    hookNames;

                /* In IE, color values inside compound-value properties are positioned at the end the value instead of at the beginning.
                   Thus, we re-arrange the templates accordingly. */
                if (IE) {
                    for (rootProperty in CSS.Hooks.templates) {
                        hookTemplate = CSS.Hooks.templates[rootProperty];
                        hookNames = hookTemplate[0].split(" ");

                        var defaultValues = hookTemplate[1].match(CSS.RegEx.valueSplit);

                        if (hookNames[0] === "Color") {
                            /* Reposition both the hook's name and its default value to the end of their respective strings. */
                            hookNames.push(hookNames.shift());
                            defaultValues.push(defaultValues.shift());

                            /* Replace the existing template for the hook's root property. */
                            CSS.Hooks.templates[rootProperty] = [ hookNames.join(" "), defaultValues.join(" ") ];
                        }
                    }
                }

                /* Hook registration. */
                for (rootProperty in CSS.Hooks.templates) {
                    hookTemplate = CSS.Hooks.templates[rootProperty];
                    hookNames = hookTemplate[0].split(" ");

                    for (var i in hookNames) {
                        var fullHookName = rootProperty + hookNames[i],
                            hookPosition = i;

                        /* For each hook, register its full name (e.g. textShadowBlur) with its root property (e.g. textShadow)
                           and the hook's position in its template's default value string. */
                        CSS.Hooks.registered[fullHookName] = [ rootProperty, hookPosition ];
                    }
                }
            },

            /*****************************
               Injection and Extraction
            *****************************/

            /* Look up the root property associated with the hook (e.g. return "textShadow" for "textShadowBlur"). */
            /* Since a hook cannot be set directly (the browser won't recognize it), style updating for hooks is routed through the hook's root property. */
            getRoot: function (property) {
                var hookData = CSS.Hooks.registered[property];

                if (hookData) {
                    return hookData[0];
                } else {
                    /* If there was no hook match, return the property name untouched. */
                    return property;
                }
            },
            /* Convert any rootPropertyValue, null or otherwise, into a space-delimited list of hook values so that
               the targeted hook can be injected or extracted at its standard position. */
            cleanRootPropertyValue: function(rootProperty, rootPropertyValue) {
                /* If the rootPropertyValue is wrapped with "rgb()", "clip()", etc., remove the wrapping to normalize the value before manipulation. */
                if (CSS.RegEx.valueUnwrap.test(rootPropertyValue)) {
                    rootPropertyValue = rootPropertyValue.match(CSS.RegEx.valueUnwrap)[1];
                }

                /* If rootPropertyValue is a CSS null-value (from which there's inherently no hook value to extract),
                   default to the root's default value as defined in CSS.Hooks.templates. */
                /* Note: CSS null-values include "none", "auto", and "transparent". They must be converted into their
                   zero-values (e.g. textShadow: "none" ==> textShadow: "0px 0px 0px black") for hook manipulation to proceed. */
                if (CSS.Values.isCSSNullValue(rootPropertyValue)) {
                    rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
                }

                return rootPropertyValue;
            },
            /* Extracted the hook's value from its root property's value. This is used to get the starting value of an animating hook. */
            extractValue: function (fullHookName, rootPropertyValue) {
                var hookData = CSS.Hooks.registered[fullHookName];

                if (hookData) {
                    var hookRoot = hookData[0],
                        hookPosition = hookData[1];

                    rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);

                    /* Split rootPropertyValue into its constituent hook values then grab the desired hook at its standard position. */
                    return rootPropertyValue.toString().match(CSS.RegEx.valueSplit)[hookPosition];
                } else {
                    /* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
                    return rootPropertyValue;
                }
            },
            /* Inject the hook's value into its root property's value. This is used to piece back together the root property
               once Velocity has updated one of its individually hooked values through tweening. */
            injectValue: function (fullHookName, hookValue, rootPropertyValue) {
                var hookData = CSS.Hooks.registered[fullHookName];

                if (hookData) {
                    var hookRoot = hookData[0],
                        hookPosition = hookData[1],
                        rootPropertyValueParts,
                        rootPropertyValueUpdated;

                    rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);

                    /* Split rootPropertyValue into its individual hook values, replace the targeted value with hookValue,
                       then reconstruct the rootPropertyValue string. */
                    rootPropertyValueParts = rootPropertyValue.toString().match(CSS.RegEx.valueSplit);
                    rootPropertyValueParts[hookPosition] = hookValue;
                    rootPropertyValueUpdated = rootPropertyValueParts.join(" ");

                    return rootPropertyValueUpdated;
                } else {
                    /* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
                    return rootPropertyValue;
                }
            }
        },

        /*******************
           Normalizations
        *******************/

        /* Normalizations standardize CSS property manipulation by pollyfilling browser-specific implementations (e.g. opacity)
           and reformatting special properties (e.g. clip, rgba) to look like standard ones. */
        Normalizations: {
            /* Normalizations are passed a normalization target (either the property's name, its extracted value, or its injected value),
               the targeted element (which may need to be queried), and the targeted property value. */
            registered: {
                clip: function (type, element, propertyValue) {
                    switch (type) {
                        case "name":
                            return "clip";
                        /* Clip needs to be unwrapped and stripped of its commas during extraction. */
                        case "extract":
                            var extracted;

                            /* If Velocity also extracted this value, skip extraction. */
                            if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
                                extracted = propertyValue;
                            } else {
                                /* Remove the "rect()" wrapper. */
                                extracted = propertyValue.toString().match(CSS.RegEx.valueUnwrap);

                                /* Strip off commas. */
                                extracted = extracted ? extracted[1].replace(/,(\s+)?/g, " ") : propertyValue;
                            }

                            return extracted;
                        /* Clip needs to be re-wrapped during injection. */
                        case "inject":
                            return "rect(" + propertyValue + ")";
                    }
                },

                blur: function(type, element, propertyValue) {
                    switch (type) {
                        case "name":
                            return Velocity.State.isFirefox ? "filter" : "-webkit-filter";
                        case "extract":
                            var extracted = parseFloat(propertyValue);

                            /* If extracted is NaN, meaning the value isn't already extracted. */
                            if (!(extracted || extracted === 0)) {
                                var blurComponent = propertyValue.toString().match(/blur\(([0-9]+[A-z]+)\)/i);

                                /* If the filter string had a blur component, return just the blur value and unit type. */
                                if (blurComponent) {
                                    extracted = blurComponent[1];
                                /* If the component doesn't exist, default blur to 0. */
                                } else {
                                    extracted = 0;
                                }
                            }

                            return extracted;
                        /* Blur needs to be re-wrapped during injection. */
                        case "inject":
                            /* For the blur effect to be fully de-applied, it needs to be set to "none" instead of 0. */
                            if (!parseFloat(propertyValue)) {
                                return "none";
                            } else {
                                return "blur(" + propertyValue + ")";
                            }
                    }
                },

                /* <=IE8 do not support the standard opacity property. They use filter:alpha(opacity=INT) instead. */
                opacity: function (type, element, propertyValue) {
                    if (IE <= 8) {
                        switch (type) {
                            case "name":
                                return "filter";
                            case "extract":
                                /* <=IE8 return a "filter" value of "alpha(opacity=\d{1,3})".
                                   Extract the value and convert it to a decimal value to match the standard CSS opacity property's formatting. */
                                var extracted = propertyValue.toString().match(/alpha\(opacity=(.*)\)/i);

                                if (extracted) {
                                    /* Convert to decimal value. */
                                    propertyValue = extracted[1] / 100;
                                } else {
                                    /* When extracting opacity, default to 1 since a null value means opacity hasn't been set. */
                                    propertyValue = 1;
                                }

                                return propertyValue;
                            case "inject":
                                /* Opacified elements are required to have their zoom property set to a non-zero value. */
                                element.style.zoom = 1;

                                /* Setting the filter property on elements with certain font property combinations can result in a
                                   highly unappealing ultra-bolding effect. There's no way to remedy this throughout a tween, but dropping the
                                   value altogether (when opacity hits 1) at leasts ensures that the glitch is gone post-tweening. */
                                if (parseFloat(propertyValue) >= 1) {
                                    return "";
                                } else {
                                  /* As per the filter property's spec, convert the decimal value to a whole number and wrap the value. */
                                  return "alpha(opacity=" + parseInt(parseFloat(propertyValue) * 100, 10) + ")";
                                }
                        }
                    /* With all other browsers, normalization is not required; return the same values that were passed in. */
                    } else {
                        switch (type) {
                            case "name":
                                return "opacity";
                            case "extract":
                                return propertyValue;
                            case "inject":
                                return propertyValue;
                        }
                    }
                }
            },

            /*****************************
                Batched Registrations
            *****************************/

            /* Note: Batched normalizations extend the CSS.Normalizations.registered object. */
            register: function () {

                /*****************
                    Transforms
                *****************/

                /* Transforms are the subproperties contained by the CSS "transform" property. Transforms must undergo normalization
                   so that they can be referenced in a properties map by their individual names. */
                /* Note: When transforms are "set", they are actually assigned to a per-element transformCache. When all transform
                   setting is complete complete, CSS.flushTransformCache() must be manually called to flush the values to the DOM.
                   Transform setting is batched in this way to improve performance: the transform style only needs to be updated
                   once when multiple transform subproperties are being animated simultaneously. */
                /* Note: IE9 and Android Gingerbread have support for 2D -- but not 3D -- transforms. Since animating unsupported
                   transform properties results in the browser ignoring the *entire* transform string, we prevent these 3D values
                   from being normalized for these browsers so that tweening skips these properties altogether
                   (since it will ignore them as being unsupported by the browser.) */
                if (!(IE <= 9) && !Velocity.State.isGingerbread) {
                    /* Note: Since the standalone CSS "perspective" property and the CSS transform "perspective" subproperty
                    share the same name, the latter is given a unique token within Velocity: "transformPerspective". */
                    CSS.Lists.transformsBase = CSS.Lists.transformsBase.concat(CSS.Lists.transforms3D);
                }

                for (var i = 0; i < CSS.Lists.transformsBase.length; i++) {
                    /* Wrap the dynamically generated normalization function in a new scope so that transformName's value is
                    paired with its respective function. (Otherwise, all functions would take the final for loop's transformName.) */
                    (function() {
                        var transformName = CSS.Lists.transformsBase[i];

                        CSS.Normalizations.registered[transformName] = function (type, element, propertyValue) {
                            switch (type) {
                                /* The normalized property name is the parent "transform" property -- the property that is actually set in CSS. */
                                case "name":
                                    return "transform";
                                /* Transform values are cached onto a per-element transformCache object. */
                                case "extract":
                                    /* If this transform has yet to be assigned a value, return its null value. */
                                    if (Data(element) === undefined || Data(element).transformCache[transformName] === undefined) {
                                        /* Scale CSS.Lists.transformsBase default to 1 whereas all other transform properties default to 0. */
                                        return /^scale/i.test(transformName) ? 1 : 0;
                                    /* When transform values are set, they are wrapped in parentheses as per the CSS spec.
                                       Thus, when extracting their values (for tween calculations), we strip off the parentheses. */
                                    } else {
                                        return Data(element).transformCache[transformName].replace(/[()]/g, "");
                                    }
                                case "inject":
                                    var invalid = false;

                                    /* If an individual transform property contains an unsupported unit type, the browser ignores the *entire* transform property.
                                       Thus, protect users from themselves by skipping setting for transform values supplied with invalid unit types. */
                                    /* Switch on the base transform type; ignore the axis by removing the last letter from the transform's name. */
                                    switch (transformName.substr(0, transformName.length - 1)) {
                                        /* Whitelist unit types for each transform. */
                                        case "translate":
                                            invalid = !/(%|px|em|rem|vw|vh|\d)$/i.test(propertyValue);
                                            break;
                                        /* Since an axis-free "scale" property is supported as well, a little hack is used here to detect it by chopping off its last letter. */
                                        case "scal":
                                        case "scale":
                                            /* Chrome on Android has a bug in which scaled elements blur if their initial scale
                                               value is below 1 (which can happen with forcefeeding). Thus, we detect a yet-unset scale property
                                               and ensure that its first value is always 1. More info: http://stackoverflow.com/questions/10417890/css3-animations-with-transform-causes-blurred-elements-on-webkit/10417962#10417962 */
                                            if (Velocity.State.isAndroid && Data(element).transformCache[transformName] === undefined && propertyValue < 1) {
                                                propertyValue = 1;
                                            }

                                            invalid = !/(\d)$/i.test(propertyValue);
                                            break;
                                        case "skew":
                                            invalid = !/(deg|\d)$/i.test(propertyValue);
                                            break;
                                        case "rotate":
                                            invalid = !/(deg|\d)$/i.test(propertyValue);
                                            break;
                                    }

                                    if (!invalid) {
                                        /* As per the CSS spec, wrap the value in parentheses. */
                                        Data(element).transformCache[transformName] = "(" + propertyValue + ")";
                                    }

                                    /* Although the value is set on the transformCache object, return the newly-updated value for the calling code to process as normal. */
                                    return Data(element).transformCache[transformName];
                            }
                        };
                    })();
                }

                /*************
                    Colors
                *************/

                /* Since Velocity only animates a single numeric value per property, color animation is achieved by hooking the individual RGBA components of CSS color properties.
                   Accordingly, color values must be normalized (e.g. "#ff0000", "red", and "rgb(255, 0, 0)" ==> "255 0 0 1") so that their components can be injected/extracted by CSS.Hooks logic. */
                for (var i = 0; i < CSS.Lists.colors.length; i++) {
                    /* Wrap the dynamically generated normalization function in a new scope so that colorName's value is paired with its respective function.
                       (Otherwise, all functions would take the final for loop's colorName.) */
                    (function () {
                        var colorName = CSS.Lists.colors[i];

                        /* Note: In IE<=8, which support rgb but not rgba, color properties are reverted to rgb by stripping off the alpha component. */
                        CSS.Normalizations.registered[colorName] = function(type, element, propertyValue) {
                            switch (type) {
                                case "name":
                                    return colorName;
                                /* Convert all color values into the rgb format. (Old IE can return hex values and color names instead of rgb/rgba.) */
                                case "extract":
                                    var extracted;

                                    /* If the color is already in its hookable form (e.g. "255 255 255 1") due to having been previously extracted, skip extraction. */
                                    if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
                                        extracted = propertyValue;
                                    } else {
                                        var converted,
                                            colorNames = {
                                                black: "rgb(0, 0, 0)",
                                                blue: "rgb(0, 0, 255)",
                                                gray: "rgb(128, 128, 128)",
                                                green: "rgb(0, 128, 0)",
                                                red: "rgb(255, 0, 0)",
                                                white: "rgb(255, 255, 255)"
                                            };

                                        /* Convert color names to rgb. */
                                        if (/^[A-z]+$/i.test(propertyValue)) {
                                            if (colorNames[propertyValue] !== undefined) {
                                                converted = colorNames[propertyValue]
                                            } else {
                                                /* If an unmatched color name is provided, default to black. */
                                                converted = colorNames.black;
                                            }
                                        /* Convert hex values to rgb. */
                                        } else if (CSS.RegEx.isHex.test(propertyValue)) {
                                            converted = "rgb(" + CSS.Values.hexToRgb(propertyValue).join(" ") + ")";
                                        /* If the provided color doesn't match any of the accepted color formats, default to black. */
                                        } else if (!(/^rgba?\(/i.test(propertyValue))) {
                                            converted = colorNames.black;
                                        }

                                        /* Remove the surrounding "rgb/rgba()" string then replace commas with spaces and strip
                                           repeated spaces (in case the value included spaces to begin with). */
                                        extracted = (converted || propertyValue).toString().match(CSS.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
                                    }

                                    /* So long as this isn't <=IE8, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
                                    if (!(IE <= 8) && extracted.split(" ").length === 3) {
                                        extracted += " 1";
                                    }

                                    return extracted;
                                case "inject":
                                    /* If this is IE<=8 and an alpha component exists, strip it off. */
                                    if (IE <= 8) {
                                        if (propertyValue.split(" ").length === 4) {
                                            propertyValue = propertyValue.split(/\s+/).slice(0, 3).join(" ");
                                        }
                                    /* Otherwise, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
                                    } else if (propertyValue.split(" ").length === 3) {
                                        propertyValue += " 1";
                                    }

                                    /* Re-insert the browser-appropriate wrapper("rgb/rgba()"), insert commas, and strip off decimal units
                                       on all values but the fourth (R, G, and B only accept whole numbers). */
                                    return (IE <= 8 ? "rgb" : "rgba") + "(" + propertyValue.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")";
                            }
                        };
                    })();
                }
            }
        },

        /************************
           CSS Property Names
        ************************/

        Names: {
            /* Camelcase a property name into its JavaScript notation (e.g. "background-color" ==> "backgroundColor").
               Camelcasing is used to normalize property names between and across calls. */
            camelCase: function (property) {
                return property.replace(/-(\w)/g, function (match, subMatch) {
                    return subMatch.toUpperCase();
                });
            },

            /* For SVG elements, some properties (namely, dimensional ones) are GET/SET via the element's HTML attributes (instead of via CSS styles). */
            SVGAttribute: function (property) {
                var SVGAttributes = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";

                /* Certain browsers require an SVG transform to be applied as an attribute. (Otherwise, application via CSS is preferable due to 3D support.) */
                if (IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) {
                    SVGAttributes += "|transform";
                }

                return new RegExp("^(" + SVGAttributes + ")$", "i").test(property);
            },

            /* Determine whether a property should be set with a vendor prefix. */
            /* If a prefixed version of the property exists, return it. Otherwise, return the original property name.
               If the property is not at all supported by the browser, return a false flag. */
            prefixCheck: function (property) {
                /* If this property has already been checked, return the cached value. */
                if (Velocity.State.prefixMatches[property]) {
                    return [ Velocity.State.prefixMatches[property], true ];
                } else {
                    var vendors = [ "", "Webkit", "Moz", "ms", "O" ];

                    for (var i = 0, vendorsLength = vendors.length; i < vendorsLength; i++) {
                        var propertyPrefixed;

                        if (i === 0) {
                            propertyPrefixed = property;
                        } else {
                            /* Capitalize the first letter of the property to conform to JavaScript vendor prefix notation (e.g. webkitFilter). */
                            propertyPrefixed = vendors[i] + property.replace(/^\w/, function(match) { return match.toUpperCase(); });
                        }

                        /* Check if the browser supports this property as prefixed. */
                        if (Type.isString(Velocity.State.prefixElement.style[propertyPrefixed])) {
                            /* Cache the match. */
                            Velocity.State.prefixMatches[property] = propertyPrefixed;

                            return [ propertyPrefixed, true ];
                        }
                    }

                    /* If the browser doesn't support this property in any form, include a false flag so that the caller can decide how to proceed. */
                    return [ property, false ];
                }
            }
        },

        /************************
           CSS Property Values
        ************************/

        Values: {
            /* Hex to RGB conversion. Copyright Tim Down: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb */
            hexToRgb: function (hex) {
                var shortformRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                    longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
                    rgbParts;

                hex = hex.replace(shortformRegex, function (m, r, g, b) {
                    return r + r + g + g + b + b;
                });

                rgbParts = longformRegex.exec(hex);

                return rgbParts ? [ parseInt(rgbParts[1], 16), parseInt(rgbParts[2], 16), parseInt(rgbParts[3], 16) ] : [ 0, 0, 0 ];
            },

            isCSSNullValue: function (value) {
                /* The browser defaults CSS values that have not been set to either 0 or one of several possible null-value strings.
                   Thus, we check for both falsiness and these special strings. */
                /* Null-value checking is performed to default the special strings to 0 (for the sake of tweening) or their hook
                   templates as defined as CSS.Hooks (for the sake of hook injection/extraction). */
                /* Note: Chrome returns "rgba(0, 0, 0, 0)" for an undefined color whereas IE returns "transparent". */
                return (value == 0 || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(value));
            },

            /* Retrieve a property's default unit type. Used for assigning a unit type when one is not supplied by the user. */
            getUnitType: function (property) {
                if (/^(rotate|skew)/i.test(property)) {
                    return "deg";
                } else if (/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(property)) {
                    /* The above properties are unitless. */
                    return "";
                } else {
                    /* Default to px for all other properties. */
                    return "px";
                }
            },

            /* HTML elements default to an associated display type when they're not set to display:none. */
            /* Note: This function is used for correctly setting the non-"none" display value in certain Velocity redirects, such as fadeIn/Out. */
            getDisplayType: function (element) {
                var tagName = element && element.tagName.toString().toLowerCase();

                if (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(tagName)) {
                    return "inline";
                } else if (/^(li)$/i.test(tagName)) {
                    return "list-item";
                } else if (/^(tr)$/i.test(tagName)) {
                    return "table-row";
                } else if (/^(table)$/i.test(tagName)) {
                    return "table";
                } else if (/^(tbody)$/i.test(tagName)) {
                    return "table-row-group";
                /* Default to "block" when no match is found. */
                } else {
                    return "block";
                }
            },

            /* The class add/remove functions are used to temporarily apply a "velocity-animating" class to elements while they're animating. */
            addClass: function (element, className) {
                if (element.classList) {
                    element.classList.add(className);
                } else {
                    element.className += (element.className.length ? " " : "") + className;
                }
            },

            removeClass: function (element, className) {
                if (element.classList) {
                    element.classList.remove(className);
                } else {
                    element.className = element.className.toString().replace(new RegExp("(^|\\s)" + className.split(" ").join("|") + "(\\s|$)", "gi"), " ");
                }
            }
        },

        /****************************
           Style Getting & Setting
        ****************************/

        /* The singular getPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
        getPropertyValue: function (element, property, rootPropertyValue, forceStyleLookup) {
            /* Get an element's computed property value. */
            /* Note: Retrieving the value of a CSS property cannot simply be performed by checking an element's
               style attribute (which only reflects user-defined values). Instead, the browser must be queried for a property's
               *computed* value. You can read more about getComputedStyle here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
            function computePropertyValue (element, property) {
                /* When box-sizing isn't set to border-box, height and width style values are incorrectly computed when an
                   element's scrollbars are visible (which expands the element's dimensions). Thus, we defer to the more accurate
                   offsetHeight/Width property, which includes the total dimensions for interior, border, padding, and scrollbar.
                   We subtract border and padding to get the sum of interior + scrollbar. */
                var computedValue = 0;

                /* IE<=8 doesn't support window.getComputedStyle, thus we defer to jQuery, which has an extensive array
                   of hacks to accurately retrieve IE8 property values. Re-implementing that logic here is not worth bloating the
                   codebase for a dying browser. The performance repercussions of using jQuery here are minimal since
                   Velocity is optimized to rarely (and sometimes never) query the DOM. Further, the $.css() codepath isn't that slow. */
                if (IE <= 8) {
                    computedValue = $.css(element, property); /* GET */
                /* All other browsers support getComputedStyle. The returned live object reference is cached onto its
                   associated element so that it does not need to be refetched upon every GET. */
                } else {
                    /* Browsers do not return height and width values for elements that are set to display:"none". Thus, we temporarily
                       toggle display to the element type's default value. */
                    var toggleDisplay = false;

                    if (/^(width|height)$/.test(property) && CSS.getPropertyValue(element, "display") === 0) {
                        toggleDisplay = true;
                        CSS.setPropertyValue(element, "display", CSS.Values.getDisplayType(element));
                    }

                    function revertDisplay () {
                        if (toggleDisplay) {
                            CSS.setPropertyValue(element, "display", "none");
                        }
                    }

                    if (!forceStyleLookup) {
                        if (property === "height" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
                            var contentBoxHeight = element.offsetHeight - (parseFloat(CSS.getPropertyValue(element, "borderTopWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderBottomWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingTop")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingBottom")) || 0);
                            revertDisplay();

                            return contentBoxHeight;
                        } else if (property === "width" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
                            var contentBoxWidth = element.offsetWidth - (parseFloat(CSS.getPropertyValue(element, "borderLeftWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderRightWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingLeft")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingRight")) || 0);
                            revertDisplay();

                            return contentBoxWidth;
                        }
                    }

                    var computedStyle;

                    /* For elements that Velocity hasn't been called on directly (e.g. when Velocity queries the DOM on behalf
                       of a parent of an element its animating), perform a direct getComputedStyle lookup since the object isn't cached. */
                    if (Data(element) === undefined) {
                        computedStyle = window.getComputedStyle(element, null); /* GET */
                    /* If the computedStyle object has yet to be cached, do so now. */
                    } else if (!Data(element).computedStyle) {
                        computedStyle = Data(element).computedStyle = window.getComputedStyle(element, null); /* GET */
                    /* If computedStyle is cached, use it. */
                    } else {
                        computedStyle = Data(element).computedStyle;
                    }

                    /* IE and Firefox do not return a value for the generic borderColor -- they only return individual values for each border side's color.
                       Also, in all browsers, when border colors aren't all the same, a compound value is returned that Velocity isn't setup to parse.
                       So, as a polyfill for querying individual border side colors, we just return the top border's color and animate all borders from that value. */
                    if (property === "borderColor") {
                        property = "borderTopColor";
                    }

                    /* IE9 has a bug in which the "filter" property must be accessed from computedStyle using the getPropertyValue method
                       instead of a direct property lookup. The getPropertyValue method is slower than a direct lookup, which is why we avoid it by default. */
                    if (IE === 9 && property === "filter") {
                        computedValue = computedStyle.getPropertyValue(property); /* GET */
                    } else {
                        computedValue = computedStyle[property];
                    }

                    /* Fall back to the property's style value (if defined) when computedValue returns nothing,
                       which can happen when the element hasn't been painted. */
                    if (computedValue === "" || computedValue === null) {
                        computedValue = element.style[property];
                    }

                    revertDisplay();
                }

                /* For top, right, bottom, and left (TRBL) values that are set to "auto" on elements of "fixed" or "absolute" position,
                   defer to jQuery for converting "auto" to a numeric value. (For elements with a "static" or "relative" position, "auto" has the same
                   effect as being set to 0, so no conversion is necessary.) */
                /* An example of why numeric conversion is necessary: When an element with "position:absolute" has an untouched "left"
                   property, which reverts to "auto", left's value is 0 relative to its parent element, but is often non-zero relative
                   to its *containing* (not parent) element, which is the nearest "position:relative" ancestor or the viewport (and always the viewport in the case of "position:fixed"). */
                if (computedValue === "auto" && /^(top|right|bottom|left)$/i.test(property)) {
                    var position = computePropertyValue(element, "position"); /* GET */

                    /* For absolute positioning, jQuery's $.position() only returns values for top and left;
                       right and bottom will have their "auto" value reverted to 0. */
                    /* Note: A jQuery object must be created here since jQuery doesn't have a low-level alias for $.position().
                       Not a big deal since we're currently in a GET batch anyway. */
                    if (position === "fixed" || (position === "absolute" && /top|left/i.test(property))) {
                        /* Note: jQuery strips the pixel unit from its returned values; we re-add it here to conform with computePropertyValue's behavior. */
                        computedValue = $(element).position()[property] + "px"; /* GET */
                    }
                }

                return computedValue;
            }

            var propertyValue;

            /* If this is a hooked property (e.g. "clipLeft" instead of the root property of "clip"),
               extract the hook's value from a normalized rootPropertyValue using CSS.Hooks.extractValue(). */
            if (CSS.Hooks.registered[property]) {
                var hook = property,
                    hookRoot = CSS.Hooks.getRoot(hook);

                /* If a cached rootPropertyValue wasn't passed in (which Velocity always attempts to do in order to avoid requerying the DOM),
                   query the DOM for the root property's value. */
                if (rootPropertyValue === undefined) {
                    /* Since the browser is now being directly queried, use the official post-prefixing property name for this lookup. */
                    rootPropertyValue = CSS.getPropertyValue(element, CSS.Names.prefixCheck(hookRoot)[0]); /* GET */
                }

                /* If this root has a normalization registered, peform the associated normalization extraction. */
                if (CSS.Normalizations.registered[hookRoot]) {
                    rootPropertyValue = CSS.Normalizations.registered[hookRoot]("extract", element, rootPropertyValue);
                }

                /* Extract the hook's value. */
                propertyValue = CSS.Hooks.extractValue(hook, rootPropertyValue);

            /* If this is a normalized property (e.g. "opacity" becomes "filter" in <=IE8) or "translateX" becomes "transform"),
               normalize the property's name and value, and handle the special case of transforms. */
            /* Note: Normalizing a property is mutually exclusive from hooking a property since hook-extracted values are strictly
               numerical and therefore do not require normalization extraction. */
            } else if (CSS.Normalizations.registered[property]) {
                var normalizedPropertyName,
                    normalizedPropertyValue;

                normalizedPropertyName = CSS.Normalizations.registered[property]("name", element);

                /* Transform values are calculated via normalization extraction (see below), which checks against the element's transformCache.
                   At no point do transform GETs ever actually query the DOM; initial stylesheet values are never processed.
                   This is because parsing 3D transform matrices is not always accurate and would bloat our codebase;
                   thus, normalization extraction defaults initial transform values to their zero-values (e.g. 1 for scaleX and 0 for translateX). */
                if (normalizedPropertyName !== "transform") {
                    normalizedPropertyValue = computePropertyValue(element, CSS.Names.prefixCheck(normalizedPropertyName)[0]); /* GET */

                    /* If the value is a CSS null-value and this property has a hook template, use that zero-value template so that hooks can be extracted from it. */
                    if (CSS.Values.isCSSNullValue(normalizedPropertyValue) && CSS.Hooks.templates[property]) {
                        normalizedPropertyValue = CSS.Hooks.templates[property][1];
                    }
                }

                propertyValue = CSS.Normalizations.registered[property]("extract", element, normalizedPropertyValue);
            }

            /* If a (numeric) value wasn't produced via hook extraction or normalization, query the DOM. */
            if (!/^[\d-]/.test(propertyValue)) {
                /* For SVG elements, dimensional properties (which SVGAttribute() detects) are tweened via
                   their HTML attribute values instead of their CSS style values. */
                if (Data(element) && Data(element).isSVG && CSS.Names.SVGAttribute(property)) {
                    /* Since the height/width attribute values must be set manually, they don't reflect computed values.
                       Thus, we use use getBBox() to ensure we always get values for elements with undefined height/width attributes. */
                    if (/^(height|width)$/i.test(property)) {
                        /* Firefox throws an error if .getBBox() is called on an SVG that isn't attached to the DOM. */
                        try {
                            propertyValue = element.getBBox()[property];
                        } catch (error) {
                            propertyValue = 0;
                        }
                    /* Otherwise, access the attribute value directly. */
                    } else {
                        propertyValue = element.getAttribute(property);
                    }
                } else {
                    propertyValue = computePropertyValue(element, CSS.Names.prefixCheck(property)[0]); /* GET */
                }
            }

            /* Since property lookups are for animation purposes (which entails computing the numeric delta between start and end values),
               convert CSS null-values to an integer of value 0. */
            if (CSS.Values.isCSSNullValue(propertyValue)) {
                propertyValue = 0;
            }

            if (Velocity.debug >= 2) console.log("Get " + property + ": " + propertyValue);

            return propertyValue;
        },

        /* The singular setPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
        setPropertyValue: function(element, property, propertyValue, rootPropertyValue, scrollData) {
            var propertyName = property;

            /* In order to be subjected to call options and element queueing, scroll animation is routed through Velocity as if it were a standard CSS property. */
            if (property === "scroll") {
                /* If a container option is present, scroll the container instead of the browser window. */
                if (scrollData.container) {
                    scrollData.container["scroll" + scrollData.direction] = propertyValue;
                /* Otherwise, Velocity defaults to scrolling the browser window. */
                } else {
                    if (scrollData.direction === "Left") {
                        window.scrollTo(propertyValue, scrollData.alternateValue);
                    } else {
                        window.scrollTo(scrollData.alternateValue, propertyValue);
                    }
                }
            } else {
                /* Transforms (translateX, rotateZ, etc.) are applied to a per-element transformCache object, which is manually flushed via flushTransformCache().
                   Thus, for now, we merely cache transforms being SET. */
                if (CSS.Normalizations.registered[property] && CSS.Normalizations.registered[property]("name", element) === "transform") {
                    /* Perform a normalization injection. */
                    /* Note: The normalization logic handles the transformCache updating. */
                    CSS.Normalizations.registered[property]("inject", element, propertyValue);

                    propertyName = "transform";
                    propertyValue = Data(element).transformCache[property];
                } else {
                    /* Inject hooks. */
                    if (CSS.Hooks.registered[property]) {
                        var hookName = property,
                            hookRoot = CSS.Hooks.getRoot(property);

                        /* If a cached rootPropertyValue was not provided, query the DOM for the hookRoot's current value. */
                        rootPropertyValue = rootPropertyValue || CSS.getPropertyValue(element, hookRoot); /* GET */

                        propertyValue = CSS.Hooks.injectValue(hookName, propertyValue, rootPropertyValue);
                        property = hookRoot;
                    }

                    /* Normalize names and values. */
                    if (CSS.Normalizations.registered[property]) {
                        propertyValue = CSS.Normalizations.registered[property]("inject", element, propertyValue);
                        property = CSS.Normalizations.registered[property]("name", element);
                    }

                    /* Assign the appropriate vendor prefix before performing an official style update. */
                    propertyName = CSS.Names.prefixCheck(property)[0];

                    /* A try/catch is used for IE<=8, which throws an error when "invalid" CSS values are set, e.g. a negative width.
                       Try/catch is avoided for other browsers since it incurs a performance overhead. */
                    if (IE <= 8) {
                        try {
                            element.style[propertyName] = propertyValue;
                        } catch (error) { if (Velocity.debug) console.log("Browser does not support [" + propertyValue + "] for [" + propertyName + "]"); }
                    /* SVG elements have their dimensional properties (width, height, x, y, cx, etc.) applied directly as attributes instead of as styles. */
                    /* Note: IE8 does not support SVG elements, so it's okay that we skip it for SVG animation. */
                    } else if (Data(element) && Data(element).isSVG && CSS.Names.SVGAttribute(property)) {
                        /* Note: For SVG attributes, vendor-prefixed property names are never used. */
                        /* Note: Not all CSS properties can be animated via attributes, but the browser won't throw an error for unsupported properties. */
                        element.setAttribute(property, propertyValue);
                    } else {
                        element.style[propertyName] = propertyValue;
                    }

                    if (Velocity.debug >= 2) console.log("Set " + property + " (" + propertyName + "): " + propertyValue);
                }
            }

            /* Return the normalized property name and value in case the caller wants to know how these values were modified before being applied to the DOM. */
            return [ propertyName, propertyValue ];
        },

        /* To increase performance by batching transform updates into a single SET, transforms are not directly applied to an element until flushTransformCache() is called. */
        /* Note: Velocity applies transform properties in the same order that they are chronogically introduced to the element's CSS styles. */
        flushTransformCache: function(element) {
            var transformString = "";

            /* Certain browsers require that SVG transforms be applied as an attribute. However, the SVG transform attribute takes a modified version of CSS's transform string
               (units are dropped and, except for skewX/Y, subproperties are merged into their master property -- e.g. scaleX and scaleY are merged into scale(X Y). */
            if ((IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) && Data(element).isSVG) {
                /* Since transform values are stored in their parentheses-wrapped form, we use a helper function to strip out their numeric values.
                   Further, SVG transform properties only take unitless (representing pixels) values, so it's okay that parseFloat() strips the unit suffixed to the float value. */
                function getTransformFloat (transformProperty) {
                    return parseFloat(CSS.getPropertyValue(element, transformProperty));
                }

                /* Create an object to organize all the transforms that we'll apply to the SVG element. To keep the logic simple,
                   we process *all* transform properties -- even those that may not be explicitly applied (since they default to their zero-values anyway). */
                var SVGTransforms = {
                    translate: [ getTransformFloat("translateX"), getTransformFloat("translateY") ],
                    skewX: [ getTransformFloat("skewX") ], skewY: [ getTransformFloat("skewY") ],
                    /* If the scale property is set (non-1), use that value for the scaleX and scaleY values
                       (this behavior mimics the result of animating all these properties at once on HTML elements). */
                    scale: getTransformFloat("scale") !== 1 ? [ getTransformFloat("scale"), getTransformFloat("scale") ] : [ getTransformFloat("scaleX"), getTransformFloat("scaleY") ],
                    /* Note: SVG's rotate transform takes three values: rotation degrees followed by the X and Y values
                       defining the rotation's origin point. We ignore the origin values (default them to 0). */
                    rotate: [ getTransformFloat("rotateZ"), 0, 0 ]
                };

                /* Iterate through the transform properties in the user-defined property map order.
                   (This mimics the behavior of non-SVG transform animation.) */
                $.each(Data(element).transformCache, function(transformName) {
                    /* Except for with skewX/Y, revert the axis-specific transform subproperties to their axis-free master
                       properties so that they match up with SVG's accepted transform properties. */
                    if (/^translate/i.test(transformName)) {
                        transformName = "translate";
                    } else if (/^scale/i.test(transformName)) {
                        transformName = "scale";
                    } else if (/^rotate/i.test(transformName)) {
                        transformName = "rotate";
                    }

                    /* Check that we haven't yet deleted the property from the SVGTransforms container. */
                    if (SVGTransforms[transformName]) {
                        /* Append the transform property in the SVG-supported transform format. As per the spec, surround the space-delimited values in parentheses. */
                        transformString += transformName + "(" + SVGTransforms[transformName].join(" ") + ")" + " ";

                        /* After processing an SVG transform property, delete it from the SVGTransforms container so we don't
                           re-insert the same master property if we encounter another one of its axis-specific properties. */
                        delete SVGTransforms[transformName];
                    }
                });
            } else {
                var transformValue,
                    perspective;

                /* Transform properties are stored as members of the transformCache object. Concatenate all the members into a string. */
                $.each(Data(element).transformCache, function(transformName) {
                    transformValue = Data(element).transformCache[transformName];

                    /* Transform's perspective subproperty must be set first in order to take effect. Store it temporarily. */
                    if (transformName === "transformPerspective") {
                        perspective = transformValue;
                        return true;
                    }

                    /* IE9 only supports one rotation type, rotateZ, which it refers to as "rotate". */
                    if (IE === 9 && transformName === "rotateZ") {
                        transformName = "rotate";
                    }

                    transformString += transformName + transformValue + " ";
                });

                /* If present, set the perspective subproperty first. */
                if (perspective) {
                    transformString = "perspective" + perspective + " " + transformString;
                }
            }

            CSS.setPropertyValue(element, "transform", transformString);
        }
    };

    /* Register hooks and normalizations. */
    CSS.Hooks.register();
    CSS.Normalizations.register();

    /* Allow hook setting in the same fashion as jQuery's $.css(). */
    Velocity.hook = function (elements, arg2, arg3) {
        var value = undefined;

        elements = sanitizeElements(elements);

        $.each(elements, function(i, element) {
            /* Initialize Velocity's per-element data cache if this element hasn't previously been animated. */
            if (Data(element) === undefined) {
                Velocity.init(element);
            }

            /* Get property value. If an element set was passed in, only return the value for the first element. */
            if (arg3 === undefined) {
                if (value === undefined) {
                    value = Velocity.CSS.getPropertyValue(element, arg2);
                }
            /* Set property value. */
            } else {
                /* sPV returns an array of the normalized propertyName/propertyValue pair used to update the DOM. */
                var adjustedSet = Velocity.CSS.setPropertyValue(element, arg2, arg3);

                /* Transform properties don't automatically set. They have to be flushed to the DOM. */
                if (adjustedSet[0] === "transform") {
                    Velocity.CSS.flushTransformCache(element);
                }

                value = adjustedSet;
            }
        });

        return value;
    };

    /*****************
        Animation
    *****************/

    var animate = function() {

        /******************
            Call Chain
        ******************/

        /* Logic for determining what to return to the call stack when exiting out of Velocity. */
        function getChain () {
            /* If we are using the utility function, attempt to return this call's promise. If no promise library was detected,
               default to null instead of returning the targeted elements so that utility function's return value is standardized. */
            if (isUtility) {
                return promiseData.promise || null;
            /* Otherwise, if we're using $.fn, return the jQuery-/Zepto-wrapped element set. */
            } else {
                return elementsWrapped;
            }
        }

        /*************************
           Arguments Assignment
        *************************/

        /* To allow for expressive CoffeeScript code, Velocity supports an alternative syntax in which "elements" (or "e"), "properties" (or "p"), and "options" (or "o")
           objects are defined on a container object that's passed in as Velocity's sole argument. */
        /* Note: Some browsers automatically populate arguments with a "properties" object. We detect it by checking for its default "names" property. */
        var syntacticSugar = (arguments[0] && (arguments[0].p || (($.isPlainObject(arguments[0].properties) && !arguments[0].properties.names) || Type.isString(arguments[0].properties)))),
            /* Whether Velocity was called via the utility function (as opposed to on a jQuery/Zepto object). */
            isUtility,
            /* When Velocity is called via the utility function ($.Velocity()/Velocity()), elements are explicitly
               passed in as the first parameter. Thus, argument positioning varies. We normalize them here. */
            elementsWrapped,
            argumentIndex;

        var elements,
            propertiesMap,
            options;

        /* Detect jQuery/Zepto elements being animated via the $.fn method. */
        if (Type.isWrapped(this)) {
            isUtility = false;

            argumentIndex = 0;
            elements = this;
            elementsWrapped = this;
        /* Otherwise, raw elements are being animated via the utility function. */
        } else {
            isUtility = true;

            argumentIndex = 1;
            elements = syntacticSugar ? (arguments[0].elements || arguments[0].e) : arguments[0];
        }

        elements = sanitizeElements(elements);

        if (!elements) {
            return;
        }

        if (syntacticSugar) {
            propertiesMap = arguments[0].properties || arguments[0].p;
            options = arguments[0].options || arguments[0].o;
        } else {
            propertiesMap = arguments[argumentIndex];
            options = arguments[argumentIndex + 1];
        }

        /* The length of the element set (in the form of a nodeList or an array of elements) is defaulted to 1 in case a
           single raw DOM element is passed in (which doesn't contain a length property). */
        var elementsLength = elements.length,
            elementsIndex = 0;

        /***************************
            Argument Overloading
        ***************************/

        /* Support is included for jQuery's argument overloading: $.animate(propertyMap [, duration] [, easing] [, complete]).
           Overloading is detected by checking for the absence of an object being passed into options. */
        /* Note: The stop and finish actions do not accept animation options, and are therefore excluded from this check. */
        if (!/^(stop|finish)$/i.test(propertiesMap) && !$.isPlainObject(options)) {
            /* The utility function shifts all arguments one position to the right, so we adjust for that offset. */
            var startingArgumentPosition = argumentIndex + 1;

            options = {};

            /* Iterate through all options arguments */
            for (var i = startingArgumentPosition; i < arguments.length; i++) {
                /* Treat a number as a duration. Parse it out. */
                /* Note: The following RegEx will return true if passed an array with a number as its first item.
                   Thus, arrays are skipped from this check. */
                if (!Type.isArray(arguments[i]) && (/^(fast|normal|slow)$/i.test(arguments[i]) || /^\d/.test(arguments[i]))) {
                    options.duration = arguments[i];
                /* Treat strings and arrays as easings. */
                } else if (Type.isString(arguments[i]) || Type.isArray(arguments[i])) {
                    options.easing = arguments[i];
                /* Treat a function as a complete callback. */
                } else if (Type.isFunction(arguments[i])) {
                    options.complete = arguments[i];
                }
            }
        }

        /***************
            Promises
        ***************/

        var promiseData = {
                promise: null,
                resolver: null,
                rejecter: null
            };

        /* If this call was made via the utility function (which is the default method of invocation when jQuery/Zepto are not being used), and if
           promise support was detected, create a promise object for this call and store references to its resolver and rejecter methods. The resolve
           method is used when a call completes naturally or is prematurely stopped by the user. In both cases, completeCall() handles the associated
           call cleanup and promise resolving logic. The reject method is used when an invalid set of arguments is passed into a Velocity call. */
        /* Note: Velocity employs a call-based queueing architecture, which means that stopping an animating element actually stops the full call that
           triggered it -- not that one element exclusively. Similarly, there is one promise per call, and all elements targeted by a Velocity call are
           grouped together for the purposes of resolving and rejecting a promise. */
        if (isUtility && Velocity.Promise) {
            promiseData.promise = new Velocity.Promise(function (resolve, reject) {
                promiseData.resolver = resolve;
                promiseData.rejecter = reject;
            });
        }

        /*********************
           Action Detection
        *********************/

        /* Velocity's behavior is categorized into "actions": Elements can either be specially scrolled into view,
           or they can be started, stopped, or reversed. If a literal or referenced properties map is passed in as Velocity's
           first argument, the associated action is "start". Alternatively, "scroll", "reverse", or "stop" can be passed in instead of a properties map. */
        var action;

        switch (propertiesMap) {
            case "scroll":
                action = "scroll";
                break;

            case "reverse":
                action = "reverse";
                break;

            case "finish":
            case "stop":
                /*******************
                    Action: Stop
                *******************/

                /* Clear the currently-active delay on each targeted element. */
                $.each(elements, function(i, element) {
                    if (Data(element) && Data(element).delayTimer) {
                        /* Stop the timer from triggering its cached next() function. */
                        clearTimeout(Data(element).delayTimer.setTimeout);

                        /* Manually call the next() function so that the subsequent queue items can progress. */
                        if (Data(element).delayTimer.next) {
                            Data(element).delayTimer.next();
                        }

                        delete Data(element).delayTimer;
                    }
                });

                var callsToStop = [];

                /* When the stop action is triggered, the elements' currently active call is immediately stopped. The active call might have
                   been applied to multiple elements, in which case all of the call's elements will be stopped. When an element
                   is stopped, the next item in its animation queue is immediately triggered. */
                /* An additional argument may be passed in to clear an element's remaining queued calls. Either true (which defaults to the "fx" queue)
                   or a custom queue string can be passed in. */
                /* Note: The stop command runs prior to Velocity's Queueing phase since its behavior is intended to take effect *immediately*,
                   regardless of the element's current queue state. */

                /* Iterate through every active call. */
                $.each(Velocity.State.calls, function(i, activeCall) {
                    /* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
                    if (activeCall) {
                        /* Iterate through the active call's targeted elements. */
                        $.each(activeCall[1], function(k, activeElement) {
                            /* If true was passed in as a secondary argument, clear absolutely all calls on this element. Otherwise, only
                               clear calls associated with the relevant queue. */
                            /* Call stopping logic works as follows:
                               - options === true --> stop current default queue calls (and queue:false calls), including remaining queued ones.
                               - options === undefined --> stop current queue:"" call and all queue:false calls.
                               - options === false --> stop only queue:false calls.
                               - options === "custom" --> stop current queue:"custom" call, including remaining queued ones (there is no functionality to only clear the currently-running queue:"custom" call). */
                            var queueName = (options === undefined) ? "" : options;

                            if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
                                return true;
                            }

                            /* Iterate through the calls targeted by the stop command. */
                            $.each(elements, function(l, element) {                                
                                /* Check that this call was applied to the target element. */
                                if (element === activeElement) {
                                    /* Optionally clear the remaining queued calls. */
                                    if (options === true || Type.isString(options)) {
                                        /* Iterate through the items in the element's queue. */
                                        $.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
                                            /* The queue array can contain an "inprogress" string, which we skip. */
                                            if (Type.isFunction(item)) {
                                                /* Pass the item's callback a flag indicating that we want to abort from the queue call.
                                                   (Specifically, the queue will resolve the call's associated promise then abort.)  */
                                                item(null, true);
                                            }
                                        });

                                        /* Clearing the $.queue() array is achieved by resetting it to []. */
                                        $.queue(element, Type.isString(options) ? options : "", []);
                                    }

                                    if (propertiesMap === "stop") {
                                        /* Since "reverse" uses cached start values (the previous call's endValues), these values must be
                                           changed to reflect the final value that the elements were actually tweened to. */
                                        /* Note: If only queue:false animations are currently running on an element, it won't have a tweensContainer
                                           object. Also, queue:false animations can't be reversed. */
                                        if (Data(element) && Data(element).tweensContainer && queueName !== false) {
                                            $.each(Data(element).tweensContainer, function(m, activeTween) {
                                                activeTween.endValue = activeTween.currentValue;
                                            });
                                        }

                                        callsToStop.push(i);
                                    } else if (propertiesMap === "finish") {
                                        /* To get active tweens to finish immediately, we forcefully shorten their durations to 1ms so that
                                        they finish upon the next rAf tick then proceed with normal call completion logic. */
                                        activeCall[2].duration = 1;
                                    }
                                }
                            });
                        });
                    }
                });

                /* Prematurely call completeCall() on each matched active call. Pass an additional flag for "stop" to indicate
                   that the complete callback and display:none setting should be skipped since we're completing prematurely. */
                if (propertiesMap === "stop") {
                    $.each(callsToStop, function(i, j) {
                        completeCall(j, true);
                    });

                    if (promiseData.promise) {
                        /* Immediately resolve the promise associated with this stop call since stop runs synchronously. */
                        promiseData.resolver(elements);
                    }
                }

                /* Since we're stopping, and not proceeding with queueing, exit out of Velocity. */
                return getChain();

            default:
                /* Treat a non-empty plain object as a literal properties map. */
                if ($.isPlainObject(propertiesMap) && !Type.isEmptyObject(propertiesMap)) {
                    action = "start";

                /****************
                    Redirects
                ****************/

                /* Check if a string matches a registered redirect (see Redirects above). */
                } else if (Type.isString(propertiesMap) && Velocity.Redirects[propertiesMap]) {
                    var opts = $.extend({}, options),
                        durationOriginal = opts.duration,
                        delayOriginal = opts.delay || 0;

                    /* If the backwards option was passed in, reverse the element set so that elements animate from the last to the first. */
                    if (opts.backwards === true) {
                        elements = $.extend(true, [], elements).reverse();
                    }

                    /* Individually trigger the redirect for each element in the set to prevent users from having to handle iteration logic in their redirect. */
                    $.each(elements, function(elementIndex, element) {
                        /* If the stagger option was passed in, successively delay each element by the stagger value (in ms). Retain the original delay value. */
                        if (parseFloat(opts.stagger)) {
                            opts.delay = delayOriginal + (parseFloat(opts.stagger) * elementIndex);
                        } else if (Type.isFunction(opts.stagger)) {
                            opts.delay = delayOriginal + opts.stagger.call(element, elementIndex, elementsLength);
                        }

                        /* If the drag option was passed in, successively increase/decrease (depending on the presense of opts.backwards)
                           the duration of each element's animation, using floors to prevent producing very short durations. */
                        if (opts.drag) {
                            /* Default the duration of UI pack effects (callouts and transitions) to 1000ms instead of the usual default duration of 400ms. */
                            opts.duration = parseFloat(durationOriginal) || (/^(callout|transition)/.test(propertiesMap) ? 1000 : DURATION_DEFAULT);

                            /* For each element, take the greater duration of: A) animation completion percentage relative to the original duration,
                               B) 75% of the original duration, or C) a 200ms fallback (in case duration is already set to a low value).
                               The end result is a baseline of 75% of the redirect's duration that increases/decreases as the end of the element set is approached. */
                            opts.duration = Math.max(opts.duration * (opts.backwards ? 1 - elementIndex/elementsLength : (elementIndex + 1) / elementsLength), opts.duration * 0.75, 200);
                        }

                        /* Pass in the call's opts object so that the redirect can optionally extend it. It defaults to an empty object instead of null to
                           reduce the opts checking logic required inside the redirect. */
                        Velocity.Redirects[propertiesMap].call(element, element, opts || {}, elementIndex, elementsLength, elements, promiseData.promise ? promiseData : undefined);
                    });

                    /* Since the animation logic resides within the redirect's own code, abort the remainder of this call.
                       (The performance overhead up to this point is virtually non-existant.) */
                    /* Note: The jQuery call chain is kept intact by returning the complete element set. */
                    return getChain();
                } else {
                    var abortError = "Velocity: First argument (" + propertiesMap + ") was not a property map, a known action, or a registered redirect. Aborting.";

                    if (promiseData.promise) {
                        promiseData.rejecter(new Error(abortError));
                    } else {
                        console.log(abortError);
                    }

                    return getChain();
                }
        }

        /**************************
            Call-Wide Variables
        **************************/

        /* A container for CSS unit conversion ratios (e.g. %, rem, and em ==> px) that is used to cache ratios across all elements
           being animated in a single Velocity call. Calculating unit ratios necessitates DOM querying and updating, and is therefore
           avoided (via caching) wherever possible. This container is call-wide instead of page-wide to avoid the risk of using stale
           conversion metrics across Velocity animations that are not immediately consecutively chained. */
        var callUnitConversionData = {
                lastParent: null,
                lastPosition: null,
                lastFontSize: null,
                lastPercentToPxWidth: null,
                lastPercentToPxHeight: null,
                lastEmToPx: null,
                remToPx: null,
                vwToPx: null,
                vhToPx: null
            };

        /* A container for all the ensuing tween data and metadata associated with this call. This container gets pushed to the page-wide
           Velocity.State.calls array that is processed during animation ticking. */
        var call = [];

        /************************
           Element Processing
        ************************/

        /* Element processing consists of three parts -- data processing that cannot go stale and data processing that *can* go stale (i.e. third-party style modifications):
           1) Pre-Queueing: Element-wide variables, including the element's data storage, are instantiated. Call options are prepared. If triggered, the Stop action is executed.
           2) Queueing: The logic that runs once this call has reached its point of execution in the element's $.queue() stack. Most logic is placed here to avoid risking it becoming stale.
           3) Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
        */

        function processElement () {

            /*************************
               Part I: Pre-Queueing
            *************************/

            /***************************
               Element-Wide Variables
            ***************************/

            var element = this,
                /* The runtime opts object is the extension of the current call's options and Velocity's page-wide option defaults. */
                opts = $.extend({}, Velocity.defaults, options),
                /* A container for the processed data associated with each property in the propertyMap.
                   (Each property in the map produces its own "tween".) */
                tweensContainer = {},
                elementUnitConversionData;

            /******************
               Element Init
            ******************/

            if (Data(element) === undefined) {
                Velocity.init(element);
            }

            /******************
               Option: Delay
            ******************/

            /* Since queue:false doesn't respect the item's existing queue, we avoid injecting its delay here (it's set later on). */
            /* Note: Velocity rolls its own delay function since jQuery doesn't have a utility alias for $.fn.delay()
               (and thus requires jQuery element creation, which we avoid since its overhead includes DOM querying). */
            if (parseFloat(opts.delay) && opts.queue !== false) {
                $.queue(element, opts.queue, function(next) {
                    /* This is a flag used to indicate to the upcoming completeCall() function that this queue entry was initiated by Velocity. See completeCall() for further details. */
                    Velocity.velocityQueueEntryFlag = true;

                    /* The ensuing queue item (which is assigned to the "next" argument that $.queue() automatically passes in) will be triggered after a setTimeout delay.
                       The setTimeout is stored so that it can be subjected to clearTimeout() if this animation is prematurely stopped via Velocity's "stop" command. */
                    Data(element).delayTimer = {
                        setTimeout: setTimeout(next, parseFloat(opts.delay)),
                        next: next
                    };
                });
            }

            /*********************
               Option: Duration
            *********************/

            /* Support for jQuery's named durations. */
            switch (opts.duration.toString().toLowerCase()) {
                case "fast":
                    opts.duration = 200;
                    break;

                case "normal":
                    opts.duration = DURATION_DEFAULT;
                    break;

                case "slow":
                    opts.duration = 600;
                    break;

                default:
                    /* Remove the potential "ms" suffix and default to 1 if the user is attempting to set a duration of 0 (in order to produce an immediate style change). */
                    opts.duration = parseFloat(opts.duration) || 1;
            }

            /************************
               Global Option: Mock
            ************************/

            if (Velocity.mock !== false) {
                /* In mock mode, all animations are forced to 1ms so that they occur immediately upon the next rAF tick.
                   Alternatively, a multiplier can be passed in to time remap all delays and durations. */
                if (Velocity.mock === true) {
                    opts.duration = opts.delay = 1;
                } else {
                    opts.duration *= parseFloat(Velocity.mock) || 1;
                    opts.delay *= parseFloat(Velocity.mock) || 1;
                }
            }

            /*******************
               Option: Easing
            *******************/

            opts.easing = getEasing(opts.easing, opts.duration);

            /**********************
               Option: Callbacks
            **********************/

            /* Callbacks must functions. Otherwise, default to null. */
            if (opts.begin && !Type.isFunction(opts.begin)) {
                opts.begin = null;
            }

            if (opts.progress && !Type.isFunction(opts.progress)) {
                opts.progress = null;
            }

            if (opts.complete && !Type.isFunction(opts.complete)) {
                opts.complete = null;
            }

            /*********************************
               Option: Display & Visibility
            *********************************/

            /* Refer to Velocity's documentation (VelocityJS.org/#displayAndVisibility) for a description of the display and visibility options' behavior. */
            /* Note: We strictly check for undefined instead of falsiness because display accepts an empty string value. */
            if (opts.display !== undefined && opts.display !== null) {
                opts.display = opts.display.toString().toLowerCase();

                /* Users can pass in a special "auto" value to instruct Velocity to set the element to its default display value. */
                if (opts.display === "auto") {
                    opts.display = Velocity.CSS.Values.getDisplayType(element);
                }
            }

            if (opts.visibility !== undefined && opts.visibility !== null) {
                opts.visibility = opts.visibility.toString().toLowerCase();
            }

            /**********************
               Option: mobileHA
            **********************/

            /* When set to true, and if this is a mobile device, mobileHA automatically enables hardware acceleration (via a null transform hack)
               on animating elements. HA is removed from the element at the completion of its animation. */
            /* Note: Android Gingerbread doesn't support HA. If a null transform hack (mobileHA) is in fact set, it will prevent other tranform subproperties from taking effect. */
            /* Note: You can read more about the use of mobileHA in Velocity's documentation: VelocityJS.org/#mobileHA. */
            opts.mobileHA = (opts.mobileHA && Velocity.State.isMobile && !Velocity.State.isGingerbread);

            /***********************
               Part II: Queueing
            ***********************/

            /* When a set of elements is targeted by a Velocity call, the set is broken up and each element has the current Velocity call individually queued onto it.
               In this way, each element's existing queue is respected; some elements may already be animating and accordingly should not have this current Velocity call triggered immediately. */
            /* In each queue, tween data is processed for each animating property then pushed onto the call-wide calls array. When the last element in the set has had its tweens processed,
               the call array is pushed to Velocity.State.calls for live processing by the requestAnimationFrame tick. */
            function buildQueue (next) {

                /*******************
                   Option: Begin
                *******************/

                /* The begin callback is fired once per call -- not once per elemenet -- and is passed the full raw DOM element set as both its context and its first argument. */
                if (opts.begin && elementsIndex === 0) {
                    /* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
                    try {
                        opts.begin.call(elements, elements);
                    } catch (error) {
                        setTimeout(function() { throw error; }, 1);
                    }
                }

                /*****************************************
                   Tween Data Construction (for Scroll)
                *****************************************/

                /* Note: In order to be subjected to chaining and animation options, scroll's tweening is routed through Velocity as if it were a standard CSS property animation. */
                if (action === "scroll") {
                    /* The scroll action uniquely takes an optional "offset" option -- specified in pixels -- that offsets the targeted scroll position. */
                    var scrollDirection = (/^x$/i.test(opts.axis) ? "Left" : "Top"),
                        scrollOffset = parseFloat(opts.offset) || 0,
                        scrollPositionCurrent,
                        scrollPositionCurrentAlternate,
                        scrollPositionEnd;

                    /* Scroll also uniquely takes an optional "container" option, which indicates the parent element that should be scrolled --
                       as opposed to the browser window itself. This is useful for scrolling toward an element that's inside an overflowing parent element. */
                    if (opts.container) {
                        /* Ensure that either a jQuery object or a raw DOM element was passed in. */
                        if (Type.isWrapped(opts.container) || Type.isNode(opts.container)) {
                            /* Extract the raw DOM element from the jQuery wrapper. */
                            opts.container = opts.container[0] || opts.container;
                            /* Note: Unlike other properties in Velocity, the browser's scroll position is never cached since it so frequently changes
                               (due to the user's natural interaction with the page). */
                            scrollPositionCurrent = opts.container["scroll" + scrollDirection]; /* GET */

                            /* $.position() values are relative to the container's currently viewable area (without taking into account the container's true dimensions
                               -- say, for example, if the container was not overflowing). Thus, the scroll end value is the sum of the child element's position *and*
                               the scroll container's current scroll position. */
                            scrollPositionEnd = (scrollPositionCurrent + $(element).position()[scrollDirection.toLowerCase()]) + scrollOffset; /* GET */
                        /* If a value other than a jQuery object or a raw DOM element was passed in, default to null so that this option is ignored. */
                        } else {
                            opts.container = null;
                        }
                    } else {
                        /* If the window itself is being scrolled -- not a containing element -- perform a live scroll position lookup using
                           the appropriate cached property names (which differ based on browser type). */
                        scrollPositionCurrent = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + scrollDirection]]; /* GET */
                        /* When scrolling the browser window, cache the alternate axis's current value since window.scrollTo() doesn't let us change only one value at a time. */
                        scrollPositionCurrentAlternate = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + (scrollDirection === "Left" ? "Top" : "Left")]]; /* GET */

                        /* Unlike $.position(), $.offset() values are relative to the browser window's true dimensions -- not merely its currently viewable area --
                           and therefore end values do not need to be compounded onto current values. */
                        scrollPositionEnd = $(element).offset()[scrollDirection.toLowerCase()] + scrollOffset; /* GET */
                    }

                    /* Since there's only one format that scroll's associated tweensContainer can take, we create it manually. */
                    tweensContainer = {
                        scroll: {
                            rootPropertyValue: false,
                            startValue: scrollPositionCurrent,
                            currentValue: scrollPositionCurrent,
                            endValue: scrollPositionEnd,
                            unitType: "",
                            easing: opts.easing,
                            scrollData: {
                                container: opts.container,
                                direction: scrollDirection,
                                alternateValue: scrollPositionCurrentAlternate
                            }
                        },
                        element: element
                    };

                    if (Velocity.debug) console.log("tweensContainer (scroll): ", tweensContainer.scroll, element);

                /******************************************
                   Tween Data Construction (for Reverse)
                ******************************************/

                /* Reverse acts like a "start" action in that a property map is animated toward. The only difference is
                   that the property map used for reverse is the inverse of the map used in the previous call. Thus, we manipulate
                   the previous call to construct our new map: use the previous map's end values as our new map's start values. Copy over all other data. */
                /* Note: Reverse can be directly called via the "reverse" parameter, or it can be indirectly triggered via the loop option. (Loops are composed of multiple reverses.) */
                /* Note: Reverse calls do not need to be consecutively chained onto a currently-animating element in order to operate on cached values;
                   there is no harm to reverse being called on a potentially stale data cache since reverse's behavior is simply defined
                   as reverting to the element's values as they were prior to the previous *Velocity* call. */
                } else if (action === "reverse") {
                    /* Abort if there is no prior animation data to reverse to. */
                    if (!Data(element).tweensContainer) {
                        /* Dequeue the element so that this queue entry releases itself immediately, allowing subsequent queue entries to run. */
                        $.dequeue(element, opts.queue);

                        return;
                    } else {
                        /*********************
                           Options Parsing
                        *********************/

                        /* If the element was hidden via the display option in the previous call,
                           revert display to "auto" prior to reversal so that the element is visible again. */
                        if (Data(element).opts.display === "none") {
                            Data(element).opts.display = "auto";
                        }

                        if (Data(element).opts.visibility === "hidden") {
                            Data(element).opts.visibility = "visible";
                        }

                        /* If the loop option was set in the previous call, disable it so that "reverse" calls aren't recursively generated.
                           Further, remove the previous call's callback options; typically, users do not want these to be refired. */
                        Data(element).opts.loop = false;
                        Data(element).opts.begin = null;
                        Data(element).opts.complete = null;

                        /* Since we're extending an opts object that has already been extended with the defaults options object,
                           we remove non-explicitly-defined properties that are auto-assigned values. */
                        if (!options.easing) {
                            delete opts.easing;
                        }

                        if (!options.duration) {
                            delete opts.duration;
                        }

                        /* The opts object used for reversal is an extension of the options object optionally passed into this
                           reverse call plus the options used in the previous Velocity call. */
                        opts = $.extend({}, Data(element).opts, opts);

                        /*************************************
                           Tweens Container Reconstruction
                        *************************************/

                        /* Create a deepy copy (indicated via the true flag) of the previous call's tweensContainer. */
                        var lastTweensContainer = $.extend(true, {}, Data(element).tweensContainer);

                        /* Manipulate the previous tweensContainer by replacing its end values and currentValues with its start values. */
                        for (var lastTween in lastTweensContainer) {
                            /* In addition to tween data, tweensContainers contain an element property that we ignore here. */
                            if (lastTween !== "element") {
                                var lastStartValue = lastTweensContainer[lastTween].startValue;

                                lastTweensContainer[lastTween].startValue = lastTweensContainer[lastTween].currentValue = lastTweensContainer[lastTween].endValue;
                                lastTweensContainer[lastTween].endValue = lastStartValue;

                                /* Easing is the only option that embeds into the individual tween data (since it can be defined on a per-property basis).
                                   Accordingly, every property's easing value must be updated when an options object is passed in with a reverse call.
                                   The side effect of this extensibility is that all per-property easing values are forcefully reset to the new value. */
                                if (!Type.isEmptyObject(options)) {
                                    lastTweensContainer[lastTween].easing = opts.easing;
                                }

                                if (Velocity.debug) console.log("reverse tweensContainer (" + lastTween + "): " + JSON.stringify(lastTweensContainer[lastTween]), element);
                            }
                        }

                        tweensContainer = lastTweensContainer;
                    }

                /*****************************************
                   Tween Data Construction (for Start)
                *****************************************/

                } else if (action === "start") {

                    /*************************
                        Value Transferring
                    *************************/

                    /* If this queue entry follows a previous Velocity-initiated queue entry *and* if this entry was created
                       while the element was in the process of being animated by Velocity, then this current call is safe to use
                       the end values from the prior call as its start values. Velocity attempts to perform this value transfer
                       process whenever possible in order to avoid requerying the DOM. */
                    /* If values aren't transferred from a prior call and start values were not forcefed by the user (more on this below),
                       then the DOM is queried for the element's current values as a last resort. */
                    /* Note: Conversely, animation reversal (and looping) *always* perform inter-call value transfers; they never requery the DOM. */
                    var lastTweensContainer;

                    /* The per-element isAnimating flag is used to indicate whether it's safe (i.e. the data isn't stale)
                       to transfer over end values to use as start values. If it's set to true and there is a previous
                       Velocity call to pull values from, do so. */
                    if (Data(element).tweensContainer && Data(element).isAnimating === true) {
                        lastTweensContainer = Data(element).tweensContainer;
                    }

                    /***************************
                       Tween Data Calculation
                    ***************************/

                    /* This function parses property data and defaults endValue, easing, and startValue as appropriate. */
                    /* Property map values can either take the form of 1) a single value representing the end value,
                       or 2) an array in the form of [ endValue, [, easing] [, startValue] ].
                       The optional third parameter is a forcefed startValue to be used instead of querying the DOM for
                       the element's current value. Read Velocity's docmentation to learn more about forcefeeding: VelocityJS.org/#forcefeeding */
                    function parsePropertyValue (valueData, skipResolvingEasing) {
                        var endValue = undefined,
                            easing = undefined,
                            startValue = undefined;

                        /* Handle the array format, which can be structured as one of three potential overloads:
                           A) [ endValue, easing, startValue ], B) [ endValue, easing ], or C) [ endValue, startValue ] */
                        if (Type.isArray(valueData)) {
                            /* endValue is always the first item in the array. Don't bother validating endValue's value now
                               since the ensuing property cycling logic does that. */
                            endValue = valueData[0];

                            /* Two-item array format: If the second item is a number, function, or hex string, treat it as a
                               start value since easings can only be non-hex strings or arrays. */
                            if ((!Type.isArray(valueData[1]) && /^[\d-]/.test(valueData[1])) || Type.isFunction(valueData[1]) || CSS.RegEx.isHex.test(valueData[1])) {
                                startValue = valueData[1];
                            /* Two or three-item array: If the second item is a non-hex string or an array, treat it as an easing. */
                            } else if ((Type.isString(valueData[1]) && !CSS.RegEx.isHex.test(valueData[1])) || Type.isArray(valueData[1])) {
                                easing = skipResolvingEasing ? valueData[1] : getEasing(valueData[1], opts.duration);

                                /* Don't bother validating startValue's value now since the ensuing property cycling logic inherently does that. */
                                if (valueData[2] !== undefined) {
                                    startValue = valueData[2];
                                }
                            }
                        /* Handle the single-value format. */
                        } else {
                            endValue = valueData;
                        }

                        /* Default to the call's easing if a per-property easing type was not defined. */
                        if (!skipResolvingEasing) {
                            easing = easing || opts.easing;
                        }

                        /* If functions were passed in as values, pass the function the current element as its context,
                           plus the element's index and the element set's size as arguments. Then, assign the returned value. */
                        if (Type.isFunction(endValue)) {
                            endValue = endValue.call(element, elementsIndex, elementsLength);
                        }

                        if (Type.isFunction(startValue)) {
                            startValue = startValue.call(element, elementsIndex, elementsLength);
                        }

                        /* Allow startValue to be left as undefined to indicate to the ensuing code that its value was not forcefed. */
                        return [ endValue || 0, easing, startValue ];
                    }

                    /* Cycle through each property in the map, looking for shorthand color properties (e.g. "color" as opposed to "colorRed"). Inject the corresponding
                       colorRed, colorGreen, and colorBlue RGB component tweens into the propertiesMap (which Velocity understands) and remove the shorthand property. */
                    $.each(propertiesMap, function(property, value) {
                        /* Find shorthand color properties that have been passed a hex string. */
                        if (RegExp("^" + CSS.Lists.colors.join("$|^") + "$").test(property)) {
                            /* Parse the value data for each shorthand. */
                            var valueData = parsePropertyValue(value, true),
                                endValue = valueData[0],
                                easing = valueData[1],
                                startValue = valueData[2];

                            if (CSS.RegEx.isHex.test(endValue)) {
                                /* Convert the hex strings into their RGB component arrays. */
                                var colorComponents = [ "Red", "Green", "Blue" ],
                                    endValueRGB = CSS.Values.hexToRgb(endValue),
                                    startValueRGB = startValue ? CSS.Values.hexToRgb(startValue) : undefined;

                                /* Inject the RGB component tweens into propertiesMap. */
                                for (var i = 0; i < colorComponents.length; i++) {
                                    var dataArray = [ endValueRGB[i] ];

                                    if (easing) {
                                        dataArray.push(easing);
                                    }

                                    if (startValueRGB !== undefined) {
                                        dataArray.push(startValueRGB[i]);
                                    }

                                    propertiesMap[property + colorComponents[i]] = dataArray;
                                }

                                /* Remove the intermediary shorthand property entry now that we've processed it. */
                                delete propertiesMap[property];
                            }
                        }
                    });

                    /* Create a tween out of each property, and append its associated data to tweensContainer. */
                    for (var property in propertiesMap) {

                        /**************************
                           Start Value Sourcing
                        **************************/

                        /* Parse out endValue, easing, and startValue from the property's data. */
                        var valueData = parsePropertyValue(propertiesMap[property]),
                            endValue = valueData[0],
                            easing = valueData[1],
                            startValue = valueData[2];

                        /* Now that the original property name's format has been used for the parsePropertyValue() lookup above,
                           we force the property to its camelCase styling to normalize it for manipulation. */
                        property = CSS.Names.camelCase(property);

                        /* In case this property is a hook, there are circumstances where we will intend to work on the hook's root property and not the hooked subproperty. */
                        var rootProperty = CSS.Hooks.getRoot(property),
                            rootPropertyValue = false;

                        /* Other than for the dummy tween property, properties that are not supported by the browser (and do not have an associated normalization) will
                           inherently produce no style changes when set, so they are skipped in order to decrease animation tick overhead.
                           Property support is determined via prefixCheck(), which returns a false flag when no supported is detected. */
                        /* Note: Since SVG elements have some of their properties directly applied as HTML attributes,
                           there is no way to check for their explicit browser support, and so we skip skip this check for them. */
                        if (!Data(element).isSVG && rootProperty !== "tween" && CSS.Names.prefixCheck(rootProperty)[1] === false && CSS.Normalizations.registered[rootProperty] === undefined) {
                            if (Velocity.debug) console.log("Skipping [" + rootProperty + "] due to a lack of browser support.");

                            continue;
                        }

                        /* If the display option is being set to a non-"none" (e.g. "block") and opacity (filter on IE<=8) is being
                           animated to an endValue of non-zero, the user's intention is to fade in from invisible, thus we forcefeed opacity
                           a startValue of 0 if its startValue hasn't already been sourced by value transferring or prior forcefeeding. */
                        if (((opts.display !== undefined && opts.display !== null && opts.display !== "none") || (opts.visibility !== undefined && opts.visibility !== "hidden")) && /opacity|filter/.test(property) && !startValue && endValue !== 0) {
                            startValue = 0;
                        }

                        /* If values have been transferred from the previous Velocity call, extract the endValue and rootPropertyValue
                           for all of the current call's properties that were *also* animated in the previous call. */
                        /* Note: Value transferring can optionally be disabled by the user via the _cacheValues option. */
                        if (opts._cacheValues && lastTweensContainer && lastTweensContainer[property]) {
                            if (startValue === undefined) {
                                startValue = lastTweensContainer[property].endValue + lastTweensContainer[property].unitType;
                            }

                            /* The previous call's rootPropertyValue is extracted from the element's data cache since that's the
                               instance of rootPropertyValue that gets freshly updated by the tweening process, whereas the rootPropertyValue
                               attached to the incoming lastTweensContainer is equal to the root property's value prior to any tweening. */
                            rootPropertyValue = Data(element).rootPropertyValueCache[rootProperty];
                        /* If values were not transferred from a previous Velocity call, query the DOM as needed. */
                        } else {
                            /* Handle hooked properties. */
                            if (CSS.Hooks.registered[property]) {
                               if (startValue === undefined) {
                                    rootPropertyValue = CSS.getPropertyValue(element, rootProperty); /* GET */
                                    /* Note: The following getPropertyValue() call does not actually trigger a DOM query;
                                       getPropertyValue() will extract the hook from rootPropertyValue. */
                                    startValue = CSS.getPropertyValue(element, property, rootPropertyValue);
                                /* If startValue is already defined via forcefeeding, do not query the DOM for the root property's value;
                                   just grab rootProperty's zero-value template from CSS.Hooks. This overwrites the element's actual
                                   root property value (if one is set), but this is acceptable since the primary reason users forcefeed is
                                   to avoid DOM queries, and thus we likewise avoid querying the DOM for the root property's value. */
                                } else {
                                    /* Grab this hook's zero-value template, e.g. "0px 0px 0px black". */
                                    rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
                                }
                            /* Handle non-hooked properties that haven't already been defined via forcefeeding. */
                            } else if (startValue === undefined) {
                                startValue = CSS.getPropertyValue(element, property); /* GET */
                            }
                        }

                        /**************************
                           Value Data Extraction
                        **************************/

                        var separatedValue,
                            endValueUnitType,
                            startValueUnitType,
                            operator = false;

                        /* Separates a property value into its numeric value and its unit type. */
                        function separateValue (property, value) {
                            var unitType,
                                numericValue;

                            numericValue = (value || "0")
                                .toString()
                                .toLowerCase()
                                /* Match the unit type at the end of the value. */
                                .replace(/[%A-z]+$/, function(match) {
                                    /* Grab the unit type. */
                                    unitType = match;

                                    /* Strip the unit type off of value. */
                                    return "";
                                });

                            /* If no unit type was supplied, assign one that is appropriate for this property (e.g. "deg" for rotateZ or "px" for width). */
                            if (!unitType) {
                                unitType = CSS.Values.getUnitType(property);
                            }

                            return [ numericValue, unitType ];
                        }

                        /* Separate startValue. */
                        separatedValue = separateValue(property, startValue);
                        startValue = separatedValue[0];
                        startValueUnitType = separatedValue[1];

                        /* Separate endValue, and extract a value operator (e.g. "+=", "-=") if one exists. */
                        separatedValue = separateValue(property, endValue);
                        endValue = separatedValue[0].replace(/^([+-\/*])=/, function(match, subMatch) {
                            operator = subMatch;

                            /* Strip the operator off of the value. */
                            return "";
                        });
                        endValueUnitType = separatedValue[1];

                        /* Parse float values from endValue and startValue. Default to 0 if NaN is returned. */
                        startValue = parseFloat(startValue) || 0;
                        endValue = parseFloat(endValue) || 0;

                        /***************************************
                           Property-Specific Value Conversion
                        ***************************************/

                        /* Custom support for properties that don't actually accept the % unit type, but where pollyfilling is trivial and relatively foolproof. */
                        if (endValueUnitType === "%") {
                            /* A %-value fontSize/lineHeight is relative to the parent's fontSize (as opposed to the parent's dimensions),
                               which is identical to the em unit's behavior, so we piggyback off of that. */
                            if (/^(fontSize|lineHeight)$/.test(property)) {
                                /* Convert % into an em decimal value. */
                                endValue = endValue / 100;
                                endValueUnitType = "em";
                            /* For scaleX and scaleY, convert the value into its decimal format and strip off the unit type. */
                            } else if (/^scale/.test(property)) {
                                endValue = endValue / 100;
                                endValueUnitType = "";
                            /* For RGB components, take the defined percentage of 255 and strip off the unit type. */
                            } else if (/(Red|Green|Blue)$/i.test(property)) {
                                endValue = (endValue / 100) * 255;
                                endValueUnitType = "";
                            }
                        }

                        /***************************
                           Unit Ratio Calculation
                        ***************************/

                        /* When queried, the browser returns (most) CSS property values in pixels. Therefore, if an endValue with a unit type of
                           %, em, or rem is animated toward, startValue must be converted from pixels into the same unit type as endValue in order
                           for value manipulation logic (increment/decrement) to proceed. Further, if the startValue was forcefed or transferred
                           from a previous call, startValue may also not be in pixels. Unit conversion logic therefore consists of two steps:
                           1) Calculating the ratio of %/em/rem/vh/vw relative to pixels
                           2) Converting startValue into the same unit of measurement as endValue based on these ratios. */
                        /* Unit conversion ratios are calculated by inserting a sibling node next to the target node, copying over its position property,
                           setting values with the target unit type then comparing the returned pixel value. */
                        /* Note: Even if only one of these unit types is being animated, all unit ratios are calculated at once since the overhead
                           of batching the SETs and GETs together upfront outweights the potential overhead
                           of layout thrashing caused by re-querying for uncalculated ratios for subsequently-processed properties. */
                        /* Todo: Shift this logic into the calls' first tick instance so that it's synced with RAF. */
                        function calculateUnitRatios () {

                            /************************
                                Same Ratio Checks
                            ************************/

                            /* The properties below are used to determine whether the element differs sufficiently from this call's
                               previously iterated element to also differ in its unit conversion ratios. If the properties match up with those
                               of the prior element, the prior element's conversion ratios are used. Like most optimizations in Velocity,
                               this is done to minimize DOM querying. */
                            var sameRatioIndicators = {
                                    myParent: element.parentNode || document.body, /* GET */
                                    position: CSS.getPropertyValue(element, "position"), /* GET */
                                    fontSize: CSS.getPropertyValue(element, "fontSize") /* GET */
                                },
                                /* Determine if the same % ratio can be used. % is based on the element's position value and its parent's width and height dimensions. */
                                samePercentRatio = ((sameRatioIndicators.position === callUnitConversionData.lastPosition) && (sameRatioIndicators.myParent === callUnitConversionData.lastParent)),
                                /* Determine if the same em ratio can be used. em is relative to the element's fontSize. */
                                sameEmRatio = (sameRatioIndicators.fontSize === callUnitConversionData.lastFontSize);

                            /* Store these ratio indicators call-wide for the next element to compare against. */
                            callUnitConversionData.lastParent = sameRatioIndicators.myParent;
                            callUnitConversionData.lastPosition = sameRatioIndicators.position;
                            callUnitConversionData.lastFontSize = sameRatioIndicators.fontSize;

                            /***************************
                               Element-Specific Units
                            ***************************/

                            /* Note: IE8 rounds to the nearest pixel when returning CSS values, thus we perform conversions using a measurement
                               of 100 (instead of 1) to give our ratios a precision of at least 2 decimal values. */
                            var measurement = 100,
                                unitRatios = {};

                            if (!sameEmRatio || !samePercentRatio) {
                                var dummy = Data(element).isSVG ? document.createElementNS("http://www.w3.org/2000/svg", "rect") : document.createElement("div");

                                Velocity.init(dummy);
                                sameRatioIndicators.myParent.appendChild(dummy);

                                /* To accurately and consistently calculate conversion ratios, the element's cascaded overflow and box-sizing are stripped.
                                   Similarly, since width/height can be artificially constrained by their min-/max- equivalents, these are controlled for as well. */
                                /* Note: Overflow must be also be controlled for per-axis since the overflow property overwrites its per-axis values. */
                                $.each([ "overflow", "overflowX", "overflowY" ], function(i, property) {
                                    Velocity.CSS.setPropertyValue(dummy, property, "hidden");
                                });
                                Velocity.CSS.setPropertyValue(dummy, "position", sameRatioIndicators.position);
                                Velocity.CSS.setPropertyValue(dummy, "fontSize", sameRatioIndicators.fontSize);
                                Velocity.CSS.setPropertyValue(dummy, "boxSizing", "content-box");

                                /* width and height act as our proxy properties for measuring the horizontal and vertical % ratios. */
                                $.each([ "minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height" ], function(i, property) {
                                    Velocity.CSS.setPropertyValue(dummy, property, measurement + "%");
                                });
                                /* paddingLeft arbitrarily acts as our proxy property for the em ratio. */
                                Velocity.CSS.setPropertyValue(dummy, "paddingLeft", measurement + "em");

                                /* Divide the returned value by the measurement to get the ratio between 1% and 1px. Default to 1 since working with 0 can produce Infinite. */
                                unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth = (parseFloat(CSS.getPropertyValue(dummy, "width", null, true)) || 1) / measurement; /* GET */
                                unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight = (parseFloat(CSS.getPropertyValue(dummy, "height", null, true)) || 1) / measurement; /* GET */
                                unitRatios.emToPx = callUnitConversionData.lastEmToPx = (parseFloat(CSS.getPropertyValue(dummy, "paddingLeft")) || 1) / measurement; /* GET */

                                sameRatioIndicators.myParent.removeChild(dummy);
                            } else {
                                unitRatios.emToPx = callUnitConversionData.lastEmToPx;
                                unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth;
                                unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight;
                            }

                            /***************************
                               Element-Agnostic Units
                            ***************************/

                            /* Whereas % and em ratios are determined on a per-element basis, the rem unit only needs to be checked
                               once per call since it's exclusively dependant upon document.body's fontSize. If this is the first time
                               that calculateUnitRatios() is being run during this call, remToPx will still be set to its default value of null,
                               so we calculate it now. */
                            if (callUnitConversionData.remToPx === null) {
                                /* Default to browsers' default fontSize of 16px in the case of 0. */
                                callUnitConversionData.remToPx = parseFloat(CSS.getPropertyValue(document.body, "fontSize")) || 16; /* GET */
                            }

                            /* Similarly, viewport units are %-relative to the window's inner dimensions. */
                            if (callUnitConversionData.vwToPx === null) {
                                callUnitConversionData.vwToPx = parseFloat(window.innerWidth) / 100; /* GET */
                                callUnitConversionData.vhToPx = parseFloat(window.innerHeight) / 100; /* GET */
                            }

                            unitRatios.remToPx = callUnitConversionData.remToPx;
                            unitRatios.vwToPx = callUnitConversionData.vwToPx;
                            unitRatios.vhToPx = callUnitConversionData.vhToPx;

                            if (Velocity.debug >= 1) console.log("Unit ratios: " + JSON.stringify(unitRatios), element);

                            return unitRatios;
                        }

                        /********************
                           Unit Conversion
                        ********************/

                        /* The * and / operators, which are not passed in with an associated unit, inherently use startValue's unit. Skip value and unit conversion. */
                        if (/[\/*]/.test(operator)) {
                            endValueUnitType = startValueUnitType;
                        /* If startValue and endValue differ in unit type, convert startValue into the same unit type as endValue so that if endValueUnitType
                           is a relative unit (%, em, rem), the values set during tweening will continue to be accurately relative even if the metrics they depend
                           on are dynamically changing during the course of the animation. Conversely, if we always normalized into px and used px for setting values, the px ratio
                           would become stale if the original unit being animated toward was relative and the underlying metrics change during the animation. */
                        /* Since 0 is 0 in any unit type, no conversion is necessary when startValue is 0 -- we just start at 0 with endValueUnitType. */
                        } else if ((startValueUnitType !== endValueUnitType) && startValue !== 0) {
                            /* Unit conversion is also skipped when endValue is 0, but *startValueUnitType* must be used for tween values to remain accurate. */
                            /* Note: Skipping unit conversion here means that if endValueUnitType was originally a relative unit, the animation won't relatively
                               match the underlying metrics if they change, but this is acceptable since we're animating toward invisibility instead of toward visibility,
                               which remains past the point of the animation's completion. */
                            if (endValue === 0) {
                                endValueUnitType = startValueUnitType;
                            } else {
                                /* By this point, we cannot avoid unit conversion (it's undesirable since it causes layout thrashing).
                                   If we haven't already, we trigger calculateUnitRatios(), which runs once per element per call. */
                                elementUnitConversionData = elementUnitConversionData || calculateUnitRatios();

                                /* The following RegEx matches CSS properties that have their % values measured relative to the x-axis. */
                                /* Note: W3C spec mandates that all of margin and padding's properties (even top and bottom) are %-relative to the *width* of the parent element. */
                                var axis = (/margin|padding|left|right|width|text|word|letter/i.test(property) || /X$/.test(property) || property === "x") ? "x" : "y";

                                /* In order to avoid generating n^2 bespoke conversion functions, unit conversion is a two-step process:
                                   1) Convert startValue into pixels. 2) Convert this new pixel value into endValue's unit type. */
                                switch (startValueUnitType) {
                                    case "%":
                                        /* Note: translateX and translateY are the only properties that are %-relative to an element's own dimensions -- not its parent's dimensions.
                                           Velocity does not include a special conversion process to account for this behavior. Therefore, animating translateX/Y from a % value
                                           to a non-% value will produce an incorrect start value. Fortunately, this sort of cross-unit conversion is rarely done by users in practice. */
                                        startValue *= (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
                                        break;

                                    case "px":
                                        /* px acts as our midpoint in the unit conversion process; do nothing. */
                                        break;

                                    default:
                                        startValue *= elementUnitConversionData[startValueUnitType + "ToPx"];
                                }

                                /* Invert the px ratios to convert into to the target unit. */
                                switch (endValueUnitType) {
                                    case "%":
                                        startValue *= 1 / (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
                                        break;

                                    case "px":
                                        /* startValue is already in px, do nothing; we're done. */
                                        break;

                                    default:
                                        startValue *= 1 / elementUnitConversionData[endValueUnitType + "ToPx"];
                                }
                            }
                        }

                        /*********************
                           Relative Values
                        *********************/

                        /* Operator logic must be performed last since it requires unit-normalized start and end values. */
                        /* Note: Relative *percent values* do not behave how most people think; while one would expect "+=50%"
                           to increase the property 1.5x its current value, it in fact increases the percent units in absolute terms:
                           50 points is added on top of the current % value. */
                        switch (operator) {
                            case "+":
                                endValue = startValue + endValue;
                                break;

                            case "-":
                                endValue = startValue - endValue;
                                break;

                            case "*":
                                endValue = startValue * endValue;
                                break;

                            case "/":
                                endValue = startValue / endValue;
                                break;
                        }

                        /**************************
                           tweensContainer Push
                        **************************/

                        /* Construct the per-property tween object, and push it to the element's tweensContainer. */
                        tweensContainer[property] = {
                            rootPropertyValue: rootPropertyValue,
                            startValue: startValue,
                            currentValue: startValue,
                            endValue: endValue,
                            unitType: endValueUnitType,
                            easing: easing
                        };

                        if (Velocity.debug) console.log("tweensContainer (" + property + "): " + JSON.stringify(tweensContainer[property]), element);
                    }

                    /* Along with its property data, store a reference to the element itself onto tweensContainer. */
                    tweensContainer.element = element;
                }

                /*****************
                    Call Push
                *****************/

                /* Note: tweensContainer can be empty if all of the properties in this call's property map were skipped due to not
                   being supported by the browser. The element property is used for checking that the tweensContainer has been appended to. */
                if (tweensContainer.element) {
                    /* Apply the "velocity-animating" indicator class. */
                    CSS.Values.addClass(element, "velocity-animating");

                    /* The call array houses the tweensContainers for each element being animated in the current call. */
                    call.push(tweensContainer);

                    /* Store the tweensContainer and options if we're working on the default effects queue, so that they can be used by the reverse command. */
                    if (opts.queue === "") {
                        Data(element).tweensContainer = tweensContainer;
                        Data(element).opts = opts;
                    }

                    /* Switch on the element's animating flag. */
                    Data(element).isAnimating = true;

                    /* Once the final element in this call's element set has been processed, push the call array onto
                       Velocity.State.calls for the animation tick to immediately begin processing. */
                    if (elementsIndex === elementsLength - 1) {
                        /* Add the current call plus its associated metadata (the element set and the call's options) onto the global call container.
                           Anything on this call container is subjected to tick() processing. */
                        Velocity.State.calls.push([ call, elements, opts, null, promiseData.resolver ]);

                        /* If the animation tick isn't running, start it. (Velocity shuts it off when there are no active calls to process.) */
                        if (Velocity.State.isTicking === false) {
                            Velocity.State.isTicking = true;

                            /* Start the tick loop. */
                            tick();
                        }
                    } else {
                        elementsIndex++;
                    }
                }
            }

            /* When the queue option is set to false, the call skips the element's queue and fires immediately. */
            if (opts.queue === false) {
                /* Since this buildQueue call doesn't respect the element's existing queue (which is where a delay option would have been appended),
                   we manually inject the delay property here with an explicit setTimeout. */
                if (opts.delay) {
                    setTimeout(buildQueue, opts.delay);
                } else {
                    buildQueue();
                }
            /* Otherwise, the call undergoes element queueing as normal. */
            /* Note: To interoperate with jQuery, Velocity uses jQuery's own $.queue() stack for queuing logic. */
            } else {
                $.queue(element, opts.queue, function(next, clearQueue) {
                    /* If the clearQueue flag was passed in by the stop command, resolve this call's promise. (Promises can only be resolved once,
                       so it's fine if this is repeatedly triggered for each element in the associated call.) */
                    if (clearQueue === true) {
                        if (promiseData.promise) {
                            promiseData.resolver(elements);
                        }

                        /* Do not continue with animation queueing. */
                        return true;
                    }

                    /* This flag indicates to the upcoming completeCall() function that this queue entry was initiated by Velocity.
                       See completeCall() for further details. */
                    Velocity.velocityQueueEntryFlag = true;

                    buildQueue(next);
                });
            }

            /*********************
                Auto-Dequeuing
            *********************/

            /* As per jQuery's $.queue() behavior, to fire the first non-custom-queue entry on an element, the element
               must be dequeued if its queue stack consists *solely* of the current call. (This can be determined by checking
               for the "inprogress" item that jQuery prepends to active queue stack arrays.) Regardless, whenever the element's
               queue is further appended with additional items -- including $.delay()'s or even $.animate() calls, the queue's
               first entry is automatically fired. This behavior contrasts that of custom queues, which never auto-fire. */
            /* Note: When an element set is being subjected to a non-parallel Velocity call, the animation will not begin until
               each one of the elements in the set has reached the end of its individually pre-existing queue chain. */
            /* Note: Unfortunately, most people don't fully grasp jQuery's powerful, yet quirky, $.queue() function.
               Lean more here: http://stackoverflow.com/questions/1058158/can-somebody-explain-jquery-queue-to-me */
            if ((opts.queue === "" || opts.queue === "fx") && $.queue(element)[0] !== "inprogress") {
                $.dequeue(element);
            }
        }

        /**************************
           Element Set Iteration
        **************************/

        /* If the "nodeType" property exists on the elements variable, we're animating a single element.
           Place it in an array so that $.each() can iterate over it. */
        $.each(elements, function(i, element) {
            /* Ensure each element in a set has a nodeType (is a real element) to avoid throwing errors. */
            if (Type.isNode(element)) {
                processElement.call(element);
            }
        });

        /******************
           Option: Loop
        ******************/

        /* The loop option accepts an integer indicating how many times the element should loop between the values in the
           current call's properties map and the element's property values prior to this call. */
        /* Note: The loop option's logic is performed here -- after element processing -- because the current call needs
           to undergo its queue insertion prior to the loop option generating its series of constituent "reverse" calls,
           which chain after the current call. Two reverse calls (two "alternations") constitute one loop. */
        var opts = $.extend({}, Velocity.defaults, options),
            reverseCallsCount;

        opts.loop = parseInt(opts.loop);
        reverseCallsCount = (opts.loop * 2) - 1;

        if (opts.loop) {
            /* Double the loop count to convert it into its appropriate number of "reverse" calls.
               Subtract 1 from the resulting value since the current call is included in the total alternation count. */
            for (var x = 0; x < reverseCallsCount; x++) {
                /* Since the logic for the reverse action occurs inside Queueing and therefore this call's options object
                   isn't parsed until then as well, the current call's delay option must be explicitly passed into the reverse
                   call so that the delay logic that occurs inside *Pre-Queueing* can process it. */
                var reverseOptions = {
                    delay: opts.delay,
                    progress: opts.progress
                };

                /* If a complete callback was passed into this call, transfer it to the loop redirect's final "reverse" call
                   so that it's triggered when the entire redirect is complete (and not when the very first animation is complete). */
                if (x === reverseCallsCount - 1) {
                    reverseOptions.display = opts.display;
                    reverseOptions.visibility = opts.visibility;
                    reverseOptions.complete = opts.complete;
                }

                animate(elements, "reverse", reverseOptions);
            }
        }

        /***************
            Chaining
        ***************/

        /* Return the elements back to the call chain, with wrapped elements taking precedence in case Velocity was called via the $.fn. extension. */
        return getChain();
    };

    /* Turn Velocity into the animation function, extended with the pre-existing Velocity object. */
    Velocity = $.extend(animate, Velocity);
    /* For legacy support, also expose the literal animate method. */
    Velocity.animate = animate;

    /**************
        Timing
    **************/

    /* Ticker function. */
    var ticker = window.requestAnimationFrame || rAFShim;

    /* Inactive browser tabs pause rAF, which results in all active animations immediately sprinting to their completion states when the tab refocuses.
       To get around this, we dynamically switch rAF to setTimeout (which the browser *doesn't* pause) when the tab loses focus. We skip this for mobile
       devices to avoid wasting battery power on inactive tabs. */
    /* Note: Tab focus detection doesn't work on older versions of IE, but that's okay since they don't support rAF to begin with. */
    if (!Velocity.State.isMobile && document.hidden !== undefined) {
        document.addEventListener("visibilitychange", function() {
            /* Reassign the rAF function (which the global tick() function uses) based on the tab's focus state. */
            if (document.hidden) {
                ticker = function(callback) {
                    /* The tick function needs a truthy first argument in order to pass its internal timestamp check. */
                    return setTimeout(function() { callback(true) }, 16);
                };

                /* The rAF loop has been paused by the browser, so we manually restart the tick. */
                tick();
            } else {
                ticker = window.requestAnimationFrame || rAFShim;
            }
        });
    }

    /************
        Tick
    ************/

    /* Note: All calls to Velocity are pushed to the Velocity.State.calls array, which is fully iterated through upon each tick. */
    function tick (timestamp) {
        /* An empty timestamp argument indicates that this is the first tick occurence since ticking was turned on.
           We leverage this metadata to fully ignore the first tick pass since RAF's initial pass is fired whenever
           the browser's next tick sync time occurs, which results in the first elements subjected to Velocity
           calls being animated out of sync with any elements animated immediately thereafter. In short, we ignore
           the first RAF tick pass so that elements being immediately consecutively animated -- instead of simultaneously animated
           by the same Velocity call -- are properly batched into the same initial RAF tick and consequently remain in sync thereafter. */
        if (timestamp) {
            /* We ignore RAF's high resolution timestamp since it can be significantly offset when the browser is
               under high stress; we opt for choppiness over allowing the browser to drop huge chunks of frames. */
            var timeCurrent = (new Date).getTime();

            /********************
               Call Iteration
            ********************/

            var callsLength = Velocity.State.calls.length;

            /* To speed up iterating over this array, it is compacted (falsey items -- calls that have completed -- are removed)
               when its length has ballooned to a point that can impact tick performance. This only becomes necessary when animation
               has been continuous with many elements over a long period of time; whenever all active calls are completed, completeCall() clears Velocity.State.calls. */
            if (callsLength > 10000) {
                Velocity.State.calls = compactSparseArray(Velocity.State.calls);
            }

            /* Iterate through each active call. */
            for (var i = 0; i < callsLength; i++) {
                /* When a Velocity call is completed, its Velocity.State.calls entry is set to false. Continue on to the next call. */
                if (!Velocity.State.calls[i]) {
                    continue;
                }

                /************************
                   Call-Wide Variables
                ************************/

                var callContainer = Velocity.State.calls[i],
                    call = callContainer[0],
                    opts = callContainer[2],
                    timeStart = callContainer[3],
                    firstTick = !!timeStart,
                    tweenDummyValue = null;

                /* If timeStart is undefined, then this is the first time that this call has been processed by tick().
                   We assign timeStart now so that its value is as close to the real animation start time as possible.
                   (Conversely, had timeStart been defined when this call was added to Velocity.State.calls, the delay
                   between that time and now would cause the first few frames of the tween to be skipped since
                   percentComplete is calculated relative to timeStart.) */
                /* Further, subtract 16ms (the approximate resolution of RAF) from the current time value so that the
                   first tick iteration isn't wasted by animating at 0% tween completion, which would produce the
                   same style value as the element's current value. */
                if (!timeStart) {
                    timeStart = Velocity.State.calls[i][3] = timeCurrent - 16;
                }

                /* The tween's completion percentage is relative to the tween's start time, not the tween's start value
                   (which would result in unpredictable tween durations since JavaScript's timers are not particularly accurate).
                   Accordingly, we ensure that percentComplete does not exceed 1. */
                var percentComplete = Math.min((timeCurrent - timeStart) / opts.duration, 1);

                /**********************
                   Element Iteration
                **********************/

                /* For every call, iterate through each of the elements in its set. */
                for (var j = 0, callLength = call.length; j < callLength; j++) {
                    var tweensContainer = call[j],
                        element = tweensContainer.element;

                    /* Check to see if this element has been deleted midway through the animation by checking for the
                       continued existence of its data cache. If it's gone, skip animating this element. */
                    if (!Data(element)) {
                        continue;
                    }

                    var transformPropertyExists = false;

                    /**********************************
                       Display & Visibility Toggling
                    **********************************/

                    /* If the display option is set to non-"none", set it upfront so that the element can become visible before tweening begins.
                       (Otherwise, display's "none" value is set in completeCall() once the animation has completed.) */
                    if (opts.display !== undefined && opts.display !== null && opts.display !== "none") {
                        if (opts.display === "flex") {
                            var flexValues = [ "-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex" ];

                            $.each(flexValues, function(i, flexValue) {
                                CSS.setPropertyValue(element, "display", flexValue);
                            });
                        }

                        CSS.setPropertyValue(element, "display", opts.display);
                    }

                    /* Same goes with the visibility option, but its "none" equivalent is "hidden". */
                    if (opts.visibility !== undefined && opts.visibility !== "hidden") {
                        CSS.setPropertyValue(element, "visibility", opts.visibility);
                    }

                    /************************
                       Property Iteration
                    ************************/

                    /* For every element, iterate through each property. */
                    for (var property in tweensContainer) {
                        /* Note: In addition to property tween data, tweensContainer contains a reference to its associated element. */
                        if (property !== "element") {
                            var tween = tweensContainer[property],
                                currentValue,
                                /* Easing can either be a pre-genereated function or a string that references a pre-registered easing
                                   on the Velocity.Easings object. In either case, return the appropriate easing *function*. */
                                easing = Type.isString(tween.easing) ? Velocity.Easings[tween.easing] : tween.easing;

                            /******************************
                               Current Value Calculation
                            ******************************/

                            /* If this is the last tick pass (if we've reached 100% completion for this tween),
                               ensure that currentValue is explicitly set to its target endValue so that it's not subjected to any rounding. */
                            if (percentComplete === 1) {
                                currentValue = tween.endValue;
                            /* Otherwise, calculate currentValue based on the current delta from startValue. */
                            } else {
                                var tweenDelta = tween.endValue - tween.startValue;
                                currentValue = tween.startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));

                                /* If no value change is occurring, don't proceed with DOM updating. */
                                if (!firstTick && (currentValue === tween.currentValue)) {
                                    continue;
                                }
                            }

                            tween.currentValue = currentValue;

                            /* If we're tweening a fake 'tween' property in order to log transition values, update the one-per-call variable so that
                               it can be passed into the progress callback. */ 
                            if (property === "tween") {
                                tweenDummyValue = currentValue;
                            } else {
                                /******************
                                   Hooks: Part I
                                ******************/

                                /* For hooked properties, the newly-updated rootPropertyValueCache is cached onto the element so that it can be used
                                   for subsequent hooks in this call that are associated with the same root property. If we didn't cache the updated
                                   rootPropertyValue, each subsequent update to the root property in this tick pass would reset the previous hook's
                                   updates to rootPropertyValue prior to injection. A nice performance byproduct of rootPropertyValue caching is that
                                   subsequently chained animations using the same hookRoot but a different hook can use this cached rootPropertyValue. */
                                if (CSS.Hooks.registered[property]) {
                                    var hookRoot = CSS.Hooks.getRoot(property),
                                        rootPropertyValueCache = Data(element).rootPropertyValueCache[hookRoot];

                                    if (rootPropertyValueCache) {
                                        tween.rootPropertyValue = rootPropertyValueCache;
                                    }
                                }

                                /*****************
                                    DOM Update
                                *****************/

                                /* setPropertyValue() returns an array of the property name and property value post any normalization that may have been performed. */
                                /* Note: To solve an IE<=8 positioning bug, the unit type is dropped when setting a property value of 0. */
                                var adjustedSetData = CSS.setPropertyValue(element, /* SET */
                                                                           property,
                                                                           tween.currentValue + (parseFloat(currentValue) === 0 ? "" : tween.unitType),
                                                                           tween.rootPropertyValue,
                                                                           tween.scrollData);

                                /*******************
                                   Hooks: Part II
                                *******************/

                                /* Now that we have the hook's updated rootPropertyValue (the post-processed value provided by adjustedSetData), cache it onto the element. */
                                if (CSS.Hooks.registered[property]) {
                                    /* Since adjustedSetData contains normalized data ready for DOM updating, the rootPropertyValue needs to be re-extracted from its normalized form. ?? */
                                    if (CSS.Normalizations.registered[hookRoot]) {
                                        Data(element).rootPropertyValueCache[hookRoot] = CSS.Normalizations.registered[hookRoot]("extract", null, adjustedSetData[1]);
                                    } else {
                                        Data(element).rootPropertyValueCache[hookRoot] = adjustedSetData[1];
                                    }
                                }

                                /***************
                                   Transforms
                                ***************/

                                /* Flag whether a transform property is being animated so that flushTransformCache() can be triggered once this tick pass is complete. */
                                if (adjustedSetData[0] === "transform") {
                                    transformPropertyExists = true;
                                }

                            }
                        }
                    }

                    /****************
                        mobileHA
                    ****************/

                    /* If mobileHA is enabled, set the translate3d transform to null to force hardware acceleration.
                       It's safe to override this property since Velocity doesn't actually support its animation (hooks are used in its place). */
                    if (opts.mobileHA) {
                        /* Don't set the null transform hack if we've already done so. */
                        if (Data(element).transformCache.translate3d === undefined) {
                            /* All entries on the transformCache object are later concatenated into a single transform string via flushTransformCache(). */
                            Data(element).transformCache.translate3d = "(0px, 0px, 0px)";

                            transformPropertyExists = true;
                        }
                    }

                    if (transformPropertyExists) {
                        CSS.flushTransformCache(element);
                    }
                }

                /* The non-"none" display value is only applied to an element once -- when its associated call is first ticked through.
                   Accordingly, it's set to false so that it isn't re-processed by this call in the next tick. */
                if (opts.display !== undefined && opts.display !== "none") {
                    Velocity.State.calls[i][2].display = false;
                }
                if (opts.visibility !== undefined && opts.visibility !== "hidden") {
                    Velocity.State.calls[i][2].visibility = false;
                }

                /* Pass the elements and the timing data (percentComplete, msRemaining, timeStart, tweenDummyValue) into the progress callback. */
                if (opts.progress) {
                    opts.progress.call(callContainer[1],
                                       callContainer[1],
                                       percentComplete,
                                       Math.max(0, (timeStart + opts.duration) - timeCurrent),
                                       timeStart,
                                       tweenDummyValue);
                }

                /* If this call has finished tweening, pass its index to completeCall() to handle call cleanup. */
                if (percentComplete === 1) {
                    completeCall(i);
                }
            }
        }

        /* Note: completeCall() sets the isTicking flag to false when the last call on Velocity.State.calls has completed. */
        if (Velocity.State.isTicking) {
            ticker(tick);
        }
    }

    /**********************
        Call Completion
    **********************/

    /* Note: Unlike tick(), which processes all active calls at once, call completion is handled on a per-call basis. */
    function completeCall (callIndex, isStopped) {
        /* Ensure the call exists. */
        if (!Velocity.State.calls[callIndex]) {
            return false;
        }

        /* Pull the metadata from the call. */
        var call = Velocity.State.calls[callIndex][0],
            elements = Velocity.State.calls[callIndex][1],
            opts = Velocity.State.calls[callIndex][2],
            resolver = Velocity.State.calls[callIndex][4];

        var remainingCallsExist = false;

        /*************************
           Element Finalization
        *************************/

        for (var i = 0, callLength = call.length; i < callLength; i++) {
            var element = call[i].element;

            /* If the user set display to "none" (intending to hide the element), set it now that the animation has completed. */
            /* Note: display:none isn't set when calls are manually stopped (via Velocity("stop"). */
            /* Note: Display gets ignored with "reverse" calls and infinite loops, since this behavior would be undesirable. */
            if (!isStopped && !opts.loop) {
                if (opts.display === "none") {
                    CSS.setPropertyValue(element, "display", opts.display);
                }

                if (opts.visibility === "hidden") {
                    CSS.setPropertyValue(element, "visibility", opts.visibility);
                }
            }

            /* If the element's queue is empty (if only the "inprogress" item is left at position 0) or if its queue is about to run
               a non-Velocity-initiated entry, turn off the isAnimating flag. A non-Velocity-initiatied queue entry's logic might alter
               an element's CSS values and thereby cause Velocity's cached value data to go stale. To detect if a queue entry was initiated by Velocity,
               we check for the existence of our special Velocity.queueEntryFlag declaration, which minifiers won't rename since the flag
               is assigned to jQuery's global $ object and thus exists out of Velocity's own scope. */
            if (opts.loop !== true && ($.queue(element)[1] === undefined || !/\.velocityQueueEntryFlag/i.test($.queue(element)[1]))) {
                /* The element may have been deleted. Ensure that its data cache still exists before acting on it. */
                if (Data(element)) {
                    Data(element).isAnimating = false;
                    /* Clear the element's rootPropertyValueCache, which will become stale. */
                    Data(element).rootPropertyValueCache = {};

                    var transformHAPropertyExists = false;
                    /* If any 3D transform subproperty is at its default value (regardless of unit type), remove it. */
                    $.each(CSS.Lists.transforms3D, function(i, transformName) {
                        var defaultValue = /^scale/.test(transformName) ? 1 : 0,
                            currentValue = Data(element).transformCache[transformName];

                        if (Data(element).transformCache[transformName] !== undefined && new RegExp("^\\(" + defaultValue + "[^.]").test(currentValue)) {
                            transformHAPropertyExists = true;

                            delete Data(element).transformCache[transformName];
                        }
                    });

                    /* Mobile devices have hardware acceleration removed at the end of the animation in order to avoid hogging the GPU's memory. */
                    if (opts.mobileHA) {
                        transformHAPropertyExists = true;
                        delete Data(element).transformCache.translate3d;
                    }

                    /* Flush the subproperty removals to the DOM. */
                    if (transformHAPropertyExists) {
                        CSS.flushTransformCache(element);
                    }

                    /* Remove the "velocity-animating" indicator class. */
                    CSS.Values.removeClass(element, "velocity-animating");
                }
            }

            /*********************
               Option: Complete
            *********************/

            /* Complete is fired once per call (not once per element) and is passed the full raw DOM element set as both its context and its first argument. */
            /* Note: Callbacks aren't fired when calls are manually stopped (via Velocity("stop"). */
            if (!isStopped && opts.complete && !opts.loop && (i === callLength - 1)) {
                /* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
                try {
                    opts.complete.call(elements, elements);
                } catch (error) {
                    setTimeout(function() { throw error; }, 1);
                }
            }

            /**********************
               Promise Resolving
            **********************/

            /* Note: Infinite loops don't return promises. */
            if (resolver && opts.loop !== true) {
                resolver(elements);
            }

            /****************************
               Option: Loop (Infinite)
            ****************************/

            if (Data(element) && opts.loop === true && !isStopped) {
                /* If a rotateX/Y/Z property is being animated to 360 deg with loop:true, swap tween start/end values to enable
                   continuous iterative rotation looping. (Otherise, the element would just rotate back and forth.) */
                $.each(Data(element).tweensContainer, function(propertyName, tweenContainer) {
                    if (/^rotate/.test(propertyName) && parseFloat(tweenContainer.endValue) === 360) {
                        tweenContainer.endValue = 0;
                        tweenContainer.startValue = 360;
                    }

                    if (/^backgroundPosition/.test(propertyName) && parseFloat(tweenContainer.endValue) === 100 && tweenContainer.unitType === "%") {
                        tweenContainer.endValue = 0;
                        tweenContainer.startValue = 100;
                    }
                });

                Velocity(element, "reverse", { loop: true, delay: opts.delay });
            }

            /***************
               Dequeueing
            ***************/

            /* Fire the next call in the queue so long as this call's queue wasn't set to false (to trigger a parallel animation),
               which would have already caused the next call to fire. Note: Even if the end of the animation queue has been reached,
               $.dequeue() must still be called in order to completely clear jQuery's animation queue. */
            if (opts.queue !== false) {
                $.dequeue(element, opts.queue);
            }
        }

        /************************
           Calls Array Cleanup
        ************************/

        /* Since this call is complete, set it to false so that the rAF tick skips it. This array is later compacted via compactSparseArray().
          (For performance reasons, the call is set to false instead of being deleted from the array: http://www.html5rocks.com/en/tutorials/speed/v8/) */
        Velocity.State.calls[callIndex] = false;

        /* Iterate through the calls array to determine if this was the final in-progress animation.
           If so, set a flag to end ticking and clear the calls array. */
        for (var j = 0, callsLength = Velocity.State.calls.length; j < callsLength; j++) {
            if (Velocity.State.calls[j] !== false) {
                remainingCallsExist = true;

                break;
            }
        }

        if (remainingCallsExist === false) {
            /* tick() will detect this flag upon its next iteration and subsequently turn itself off. */
            Velocity.State.isTicking = false;

            /* Clear the calls array so that its length is reset. */
            delete Velocity.State.calls;
            Velocity.State.calls = [];
        }
    }

    /******************
        Frameworks
    ******************/

    /* Both jQuery and Zepto allow their $.fn object to be extended to allow wrapped elements to be subjected to plugin calls.
       If either framework is loaded, register a "velocity" extension pointing to Velocity's core animate() method.  Velocity
       also registers itself onto a global container (window.jQuery || window.Zepto || window) so that certain features are
       accessible beyond just a per-element scope. This master object contains an .animate() method, which is later assigned to $.fn
       (if jQuery or Zepto are present). Accordingly, Velocity can both act on wrapped DOM elements and stand alone for targeting raw DOM elements. */
    global.Velocity = Velocity;

    if (global !== window) {
        /* Assign the element function to Velocity's core animate() method. */
        global.fn.velocity = animate;
        /* Assign the object function's defaults to Velocity's global defaults object. */
        global.fn.velocity.defaults = Velocity.defaults;
    }

    /***********************
       Packaged Redirects
    ***********************/

    /* slideUp, slideDown */
    $.each([ "Down", "Up" ], function(i, direction) {
        Velocity.Redirects["slide" + direction] = function (element, options, elementsIndex, elementsSize, elements, promiseData) {
            var opts = $.extend({}, options),
                begin = opts.begin,
                complete = opts.complete,
                computedValues = { height: "", marginTop: "", marginBottom: "", paddingTop: "", paddingBottom: "" },
                inlineValues = {};

            if (opts.display === undefined) {
                /* Show the element before slideDown begins and hide the element after slideUp completes. */
                /* Note: Inline elements cannot have dimensions animated, so they're reverted to inline-block. */
                opts.display = (direction === "Down" ? (Velocity.CSS.Values.getDisplayType(element) === "inline" ? "inline-block" : "block") : "none");
            }

            opts.begin = function() {
                /* If the user passed in a begin callback, fire it now. */
                begin && begin.call(elements, elements);

                /* Cache the elements' original vertical dimensional property values so that we can animate back to them. */
                for (var property in computedValues) {
                    inlineValues[property] = element.style[property];

                    /* For slideDown, use forcefeeding to animate all vertical properties from 0. For slideUp,
                       use forcefeeding to start from computed values and animate down to 0. */
                    var propertyValue = Velocity.CSS.getPropertyValue(element, property);
                    computedValues[property] = (direction === "Down") ? [ propertyValue, 0 ] : [ 0, propertyValue ];
                }

                /* Force vertical overflow content to clip so that sliding works as expected. */
                inlineValues.overflow = element.style.overflow;
                element.style.overflow = "hidden";
            }

            opts.complete = function() {
                /* Reset element to its pre-slide inline values once its slide animation is complete. */
                for (var property in inlineValues) {
                    element.style[property] = inlineValues[property];
                }

                /* If the user passed in a complete callback, fire it now. */
                complete && complete.call(elements, elements);
                promiseData && promiseData.resolver(elements);
            };

            Velocity(element, computedValues, opts);
        };
    });

    /* fadeIn, fadeOut */
    $.each([ "In", "Out" ], function(i, direction) {
        Velocity.Redirects["fade" + direction] = function (element, options, elementsIndex, elementsSize, elements, promiseData) {
            var opts = $.extend({}, options),
                propertiesMap = { opacity: (direction === "In") ? 1 : 0 },
                originalComplete = opts.complete;

            /* Since redirects are triggered individually for each element in the animated set, avoid repeatedly triggering
               callbacks by firing them only when the final element has been reached. */
            if (elementsIndex !== elementsSize - 1) {
                opts.complete = opts.begin = null;
            } else {
                opts.complete = function() {
                    if (originalComplete) {
                        originalComplete.call(elements, elements);
                    }

                    promiseData && promiseData.resolver(elements);
                }
            }

            /* If a display was passed in, use it. Otherwise, default to "none" for fadeOut or the element-specific default for fadeIn. */
            /* Note: We allow users to pass in "null" to skip display setting altogether. */
            if (opts.display === undefined) {
                opts.display = (direction === "In" ? "auto" : "none");
            }

            Velocity(this, propertiesMap, opts);
        };
    });

    return Velocity;
}((window.jQuery || window.Zepto || window), window, document);
}));

/******************
   Known Issues
******************/

/* The CSS spec mandates that the translateX/Y/Z transforms are %-relative to the element itself -- not its parent.
Velocity, however, doesn't make this distinction. Thus, converting to or from the % unit with these subproperties
will produce an inaccurate conversion value. The same issue exists with the cx/cy attributes of SVG circles and ellipses. */;
define('@qubit---velocity@1.2.3', ['@qubit---velocity@1.2.3/velocity'], function (main) { return main; });

define('@qubit---modal@0.1.0/lib/animation',['require','exports','module','@qubit/jquery','@qubit/velocity'],function (require, exports, module) {var $ = require("@qubit/jquery");
var velocity = require("@qubit/velocity");
var animation;

function render(el, opts, cb) {
  if (opts.type === "slide") {
    animation.slide(el, opts, fixOverflow(el, cb));
  } else if (opts.type === "fade") {
    animation.fade(el, opts, fixOverflow(el, cb));
  } else {
    $(el).hide(0);
    $(el).delay(parseInt(opts.delay || 0)).show(0, fixOverflow(el, cb));
  }
}

function fixOverflow(el, cb) {
  return function () {
    $(el).css("overflow", "");
    cb();
  };
}

function fade(el, opts, cb) {
  $(el).hide(0).delay(parseInt(opts.delay || 0)).fadeIn(parseInt(opts.speed), function () {
    return cb && cb();
  });
}

function slide(el, opts, cb) {
  var start = {};
  var end = $(el).position();
  var $container = $(document);
  var containerHeight = $container.height();
  var containerWidth = $container.width();
  switch (opts.direction) {
  case "down":
    start.top = -el.offsetHeight;
    start.left = end.left;
    break;
  case "up":
    start.top = containerHeight + el.offsetHeight;
    start.left = end.left;
    break;
  case "right":
    start.top = end.top;
    start.left = -el.offsetWidth;
    break;
  default:
    start.top = end.top;
    start.left = containerWidth + el.offsetWidth;
    break;
  }
  $(el)
    .css(start)
    .delay(parseInt(opts.delay || 0))
    .queue(function() {
      var self = this;
      velocity(el, end, {
        easing: "swing",
        duration: parseInt(opts.speed),
        complete: function () {
          $(self).dequeue();
          return cb && cb();
        }
      });
    });
}

animation = {
  fade: fade,
  slide: slide,
  render: render
};

module.exports = animation;

});

define('@qubit---modal@0.1.0/lib/render',['require','exports','module','@qubit/jquery','@qubit/maxz','./css','./defaults','./position','./overlay','./animation'],function (require, exports, module) {var $ = require("@qubit/jquery");
var maxz = require("@qubit/maxz");
var applyCss = require("./css");
var defaults = require("./defaults");
var position = require("./position");
var overlay = require("./overlay");
var animation = require("./animation");

var maxzCache, overlayInstance;

function showTools(api) {
  return api && api.tools && api.tools.show();
}

function hideTools(api) {
  return api && api.tools && api.tools.hide();
}

function applyPosition(el, positionOpts) {
  $(el).css({ position: positionOpts.fixed ? "fixed" : "absolute", top: 0, left: 0});
  if (positionOpts.my) {
    $(el).css(position.getPosition(el, positionOpts));
  }
}

function getCallback(todo, cb) {
  return function callback() {
    if (!--todo) cb();
  };
}

function renderModal(el, config, options) {
  options = options || {};
  config = config || {};
  hideTools(options.api);

  // These lines are important because we want
  // the existing modal to stay in the DOM
  // so that event propagation doesn't get
  // destroyed
  if ($(el).parents("body").length) {
    $(el).show();
  } else {
    $(el).appendTo(document.body);
  }

  applyCss(el, config);

  if (config.position) {
    applyPosition(el, config.position);
  }

  if (!options.sync && (config.overlay || config.animation)) {
    var todo = !!config.animation + !!config.overlay;
    var cb = getCallback(todo, function () {
      $(el).hasClass("deliver-is-selected") && showTools(options.api);
    });
    var overlayOpts = $.extend({}, defaults.overlay, {
      speed: config.animation && config.animation.speed && parseInt(config.animation.speed),
      delay: options.minDelay
    });
    if (config.overlay) {
      overlayInstance = overlay.render(overlayOpts, cb);
    }
    if (config.animation) animation.render(el, config.animation, cb);
  } else {
    showTools(options.api);
  }
  maxzCache = maxzCache || maxz();
  var zIndex = overlayInstance ? overlayInstance.$overlay.css("zIndex") + 1 : maxzCache;
  $(".deliver-component-Modal").css("zIndex", zIndex);
}

module.exports = renderModal;

});

define('@qubit---modal@0.1.0/modal',['require','exports','module','@qubit/jquery','@qubit/close/close-button','@qubit/close/settings/convert-duration-to-ms','./lib/render','./lib/overlay'],function (require, exports, module) {var $ = require("@qubit/jquery");
var closeButton = require("@qubit/close/close-button");
var convertDurationToMs = require("@qubit/close/settings/convert-duration-to-ms");
var renderModal = require("./lib/render");
var overlay = require("./lib/overlay");

var modals = [];
var closeButtonHelper;

function Modal(options) {
  this.init(options);
  this.modals = modals;
}

function init(options) {
  this.options = options || {};
  this.model = this.options.model;
  this.api = this.options.api;
  this.el = document.createElement("div");
  if (modals.indexOf(this) < 0) modals.push(this);
  $(this.el).addClass("deliver-component-Modal deliver-allowChildren");
  this.closeButton = closeButton;
}

function render() {
  this.bindEvents();
  this.removeModal();
  this.renderModalWithOptions();
  return this.el;
}

function renderModalWithOptions(options) {
  options = options || {};
  var closeButtonOnly = options.closeButtonOnly === true;
  var sync = options.sync === true;
  var api = this.api;
  var model = this.model;

  if (!closeButtonOnly) {
    this.renderModal(this.el, model && model.toJSON(), {
      uiState: this.uiState,
      api: api,
      sync: sync,
      minDelay: getMinDelay()
    });
  }

  if (model && model.get("closeButton")) {
    this.renderCloseButton();
  }
}

function renderCloseButton() {
  var model = this.model;
  var options = this.options;
  closeButtonHelper = this.closeButton.render($.extend({}, model.get("closeButton"), {
    container: this.el,
    onChange: function (nextConfig) {
      model.set("closeButton", $.extend(true, {}, model.get("closeButton"), nextConfig));
    },
    onClick: onCloseButtonClick(this),
    uiState: options.uiState
  }));
}

function onCloseButtonClick(context) {
  return function () {
    var durationString = context.model.get("closeButton.durationString");
    context.api.close(convertDurationToMs(durationString));
  };
}

function modalsWithActiveOverlay() {
  return $.grep(modals, function (modal) {
    return !!modal.activeOverlay;
  }).length;
}

function removeOverlay() {
  if (this.activeOverlay) {
    delete this.activeOverlay;
    if (!modalsWithActiveOverlay()) overlay.destroy();
  }
}

function removeModal() {
  closeButtonHelper && closeButtonHelper.remove();
  $(this.el).stop().detach();
  this.removeOverlay();
}

function remove() {
  this.unbindEvents();
  var i = modals.indexOf(this);
  if (i >= 0) modals.splice(i, 1);
  this.removeModal();
  closeButtonHelper && closeButtonHelper.remove();
}

function getMinDelay() {
  return Math.min.apply(Math, $.map(modals, function (modal) {
    var delay = modal.model && modal.model.get("animation.delay");
    return delay && parseInt(delay) || 0;
  }));
}

function onClick() {
  this.remove();
}

function bindEvents() {
  var self = this;
  this.unbindEvents();
  this.boundRenderOnResize = this.boundRenderOnResize || function (e) {
    if (e.target !== window) return;
    $(self.el).detach();
    return self.renderModal(self.el, self.model && self.model.toJSON(), {
      api: self.api,
      sync: true,
      minDelay: getMinDelay()
    });
  };
  $(window).on("resize", this.boundRenderOnResize);

  if (this.model && this.model.get("overlay")) {
    this.boundRemoveOnOverlayClick = this.boundRemoveOnOverlayClick || function (e) {
      if (self.el === e.target || $.contains(self.el, e.target)) {
        return;
      }
      onCloseButtonClick(self)();
    };
    $(document.body).on("click", this.boundRemoveOnOverlayClick);
  }
}

function unbindEvents() {
  if (this.boundRenderOnResize) {
    $(window).off("resize", this.boundRenderOnResize);
    delete this.boundRenderOnResize;
  }
  if (this.boundRemoveOnOverlayClick) {
    $(document.body).off("click", this.boundRemoveOnOverlayClick);
    delete this.boundRemoveOnOverlayClick;
  }
}

function renderModalWrapper() {
  this.activeOverlay = !!(this.model && this.model.get("overlay"));
  renderModal.apply(this, arguments);
}

Modal.prototype = {
  init: init,
  render: render,
  removeModal: removeModal,
  renderModal: renderModalWrapper,
  renderModalWithOptions: renderModalWithOptions,
  renderCloseButton: renderCloseButton,
  removeOverlay: removeOverlay,
  onClick: onClick,
  onCloseButtonClick: onCloseButtonClick,
  bindEvents: bindEvents,
  unbindEvents: unbindEvents,
  getMinDelay: getMinDelay,
  remove: remove
};

module.exports = Modal;

});

define('@qubit---modal@0.1.0', ['@qubit---modal@0.1.0/modal'], function (main) { return main; });

define('@qubit---url-smoothie@1.0.2/src/types',['require','exports','module'],function (require, exports, module) {var typeLib = {
  is: {
    anchor: function isAnchor (url) {
      return /^#/.test(url);
    },
    relative: function isRelative (url) {
      return /^\//.test(url);
    },
    protocol: function isProtocol (url) {
      return /^\w+:/.test(url);
    },
    unprefixed: function isUnprefixed(url) {
      return !(/^(#|\/|(\w+:))/).test(url);
    }
  },
  get: function getType (url) {
    var type;
    for (type in typeLib.is) {
      if (typeLib.is.hasOwnProperty(type)) {
        if (typeLib.is[type](url)) {
          // lets not differentiate between http and https protocols when url santitising
          return type === "protocol" ? url.replace(/:.*/, "").replace("https", "http") : type;
        }
      }
    }
  }
};

module.exports = typeLib;
});

define('@qubit---url-smoothie@1.0.2/src/smoothies',['require','exports','module'],function (require, exports, module) {var smoothies = {
  unprefixed: function (url) {
    return "http://" + url;
  }
};
module.exports = smoothies;
});

define('@qubit---url-smoothie@1.0.2/src/index',['require','exports','module','./types','./smoothies'],function (require, exports, module) {var types = require("./types");
var smoothies = require("./smoothies");
function smoothie(url) {
  var type = types.get(url);
  return smoothies[type] ? smoothies[type](url) : url;
}
module.exports = smoothie;
});

define('@qubit---url-smoothie@1.0.2', ['@qubit---url-smoothie@1.0.2/src/index'], function (main) { return main; });


define('@qubit---css@0.1.6/css!@qubit---image@2.7.16/styles/click_region',[],function(){});
define('@qubit---image@2.7.16/lib/regions/click_region',['require','css!../../styles/click_region','@qubit/jquery','@qubit/underscore','@qubit/url-smoothie'],function (require) {

  require("css!../../styles/click_region");
  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");
  var urlSmoothie = require("@qubit/url-smoothie");

  function ClickRegion() {
    this.initialize.apply(this, arguments);
  }

  ClickRegion.prototype.initialize = function (options) {
    this.options = options;
    this.el = document.createElement("a");
    this.$el = $(this.el).addClass("deliver-component-Image-region");
  };

  ClickRegion.prototype.remove = function () {
    if (this.$el && this.$el.length) {
      this.$el.remove();
    }
  };

  /**
   * Rendering methods
   */
  ClickRegion.prototype.render = function () {
    var options = this.options;
    this.$el.data("image-region-id", options.id);
    this.applySizeAndPosition();
    this.$el.attr({
      "href": urlSmoothie(options.actionLink),
      "target": options.newTab ? "_blank" : "_self"
    });
    return this;
  };

  ClickRegion.prototype.applySizeAndPosition = function () {
    var options = this.options;
    this.$el.width(options.widthRatio * options.imageWidth);
    this.$el.height(options.heightRatio * options.imageHeight);
    this.$el.css("top", options.topRatio * options.imageHeight);
    this.$el.css("left", options.leftRatio * options.imageWidth);
  };

  /**
   * Rerender the region with new config
   * (only reacts to new ratios for perf, ignores
   * the other attributes)
   */
  ClickRegion.prototype.update = function (newConfig) {
    _.extend(this.options, newConfig);
    this.applySizeAndPosition();
    return this;
  };

  return ClickRegion;

});

define('@qubit---image@2.7.16/lib/regions/calculate_ratios',['require','exports','module'],function (require, exports, module) {/**
 * Takes region dimensions and calculates a ratio with
 * the image components dimensions
 */
module.exports = function calculateRatios(imageDimensions, regionDimensions) {
  return {
    widthRatio: regionDimensions.width / imageDimensions.imageWidth,
    heightRatio: regionDimensions.height / imageDimensions.imageHeight,
    topRatio: regionDimensions.top / imageDimensions.imageHeight,
    leftRatio: regionDimensions.left / imageDimensions.imageWidth
  };
};
});

define('@qubit---image@2.7.16/lib/regions/regions',['require','@qubit/jquery','@qubit/underscore','./click_region','./calculate_ratios'],function (require) {

  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");
  var ClickRegion = require("./click_region");
  var calculateRatios = require("./calculate_ratios");
  var windowHeight = $(window).height();
  var windowWidth = $(window).width();

  function Regions() {
    this.initialize.apply(this, arguments);
  }

  Regions.prototype.initialize = function (options) {
    this.options = options;
    this.regionViews = {};
    this.onWindowResize = _.bind(this.onWindowResize, this);
  };

  Regions.prototype.remove = function () {
    this.unbindEvents();
    _.invoke(this.regionViews, "remove");
  };

  Regions.prototype.render = function () {
    this.bindEvents();
    this.removeGhostRegions();
    _.each(this.options.model.get("regions"), this.renderClickRegion, this);
  };

  /**
   * This can be used by the parent view if it wants to temporarily
   * remove the regions from the DOM in order to preserve the DOM
   * event bindings. Call `regions.render` to reattach.
   */
  Regions.prototype.detach = function () {
    _.each(this.regionViews, function (region) {
      region.$el.detach();
    });
  };

  Regions.prototype.getRegionViews = function () {
    return this.regionViews;
  };

  Regions.prototype.getRegionView = function (id) {
    return this.regionViews[id];
  };

  Regions.prototype.bindEvents = function () {
    if (!this._bound) {
      $(window).on("resize.image-regions", this.onWindowResize);
      this._bound = true;
    }
  };

  Regions.prototype.unbindEvents = function () {
    $(window).off("resize.image-regions", this.onWindowResize);
    this._bound = false;
  };

  Regions.prototype.renderClickRegion = function (configFromModel) {
    var region;
    // Pass current image width / height for
    // calculation of new region size / position
    // based on ratios calculated at initial
    var config = _.extend({}, this.defaultRatios(), configFromModel, this.getImageDimensions());
    if (this.regionViews[config.id]) {
      region = this.regionViews[config.id].update(config);
    } else {
      region = this.createClickRegion(config).render();
      this.regionViews[config.id] = region;
    }
    this.options.$container.append(region.el);
  };

  /**
   * Keeps the 'image.regions' store and the
   * regions collection (on the model) in sync
   */
  Regions.prototype.removeGhostRegions = function () {
    var modelRegions = this.options.model.get("regions");
    var remainingIds = _.pluck(modelRegions, "id");
    var toRemove = _.filter(this.regionViews, function (region) {
      return !_.contains(remainingIds, region.options.id);
    });
    _.each(toRemove, function (region) {
      region.remove();
      delete this.regionViews[region.options.id];
    }, this);
  };

  Regions.prototype.createClickRegion = function (config) {
    return new ClickRegion(config);
  };

  Regions.prototype.getImageDimensions = function () {
    return {
      imageWidth: this.options.$container.width(),
      imageHeight: this.options.$container.height()
    };
  };

  Regions.prototype.defaultRatios = function () {
    // we always fallback to default ratios when model has no specific
    // configuration. In production, we want to always keep the same
    // ratios if the window is resized instead of recomputing them.
    if (!this._ratiosCache) {
      this._ratiosCache = calculateRatios(this.getImageDimensions(), {
        top: 10,
        left: 10,
        width: 100,
        height: 30
      });
    }
    return this._ratiosCache;
  };

  Regions.prototype.onWindowResize = function () {
    var newWindowHeight = $(window).height();
    var newWindowWidth = $(window).width();
    // make sure it's actually window that has had 'resize'
    // triggered, and not something inside window bubbling
    if (newWindowHeight === windowHeight && newWindowWidth === windowWidth) {
      return;
    }
    windowHeight = newWindowHeight;
    windowWidth = newWindowWidth;
    this.render();
  };

  return Regions;

});


define('@qubit---css@0.1.6/css!@qubit---image@2.7.16/styles/image',[],function(){});
define('@qubit---image@2.7.16/image',['require','@qubit/jquery','@qubit/underscore','@qubit/url-smoothie','./lib/regions/regions','css!./styles/image'],function (require) {

  var $ = require("@qubit/jquery");
  var _ = require("@qubit/underscore");
  var urlSmoothie = require("@qubit/url-smoothie");
  var Regions = require("./lib/regions/regions");
  require("css!./styles/image");

  function Image() {
    this.initialize.apply(this, arguments);
  }

  Image.prototype.initialize = function (options) {
    this.options = options || {};
    this.model = options.model;
    this.el = document.createElement("div");
    this.$el = $(this.el).addClass("deliver-component-Image");
    this.$el.css("position", "relative");

    this.model.on("change:url", this.updateHeightAndWidth, this);
  }

  Image.prototype.remove = function () {
    this.regions && this.regions.remove();
    this.$el && this.$el.remove();
  };

  Image.prototype.render = function () {
    var model = this.model;

    // Don't show image placeholder in production
    if (!model.get("url")) {
      return this;
    }

    var $el = this.$el;
    var $content = this.createImage();
    if (model.get("action") === "link" && model.get("actionLink")) {
      $content = this.createLink().html($content);
    }
    if (model.get("action") === "regions") {
      if (!this.regions) {
        this.regions = this.createRegions();
      }
      // tricky. we don't want to wipe out
      // regions from the DOM and lose all events
      // bound in there. So we detach here,
      // because we'll soon rerender in this.afterLoad
      this.regions.detach();
    }

    $el.html($content);

    this.applyCss();
    return this;
  };

  Image.prototype.createImage = function () {
    var model = this.model.toJSON();
    return $("<img/>", {
      "class": "deliver-component-Image-img",
      "alt": model.altText,
      "src": model.url
    }).on("load", _.bind(this.afterLoad, this));
  };

  Image.prototype.createLink = function () {
    var model = this.model.toJSON();
    var $a = $("<a/>", {
      "href": urlSmoothie(model.actionLink),
      "class": "deliver-component-Image-link"
    });
    if (model.newTab) {
      $a.attr("target", "_blank");
    } else {
      $a.removeAttr("target");
    }
    return $a;
  };

  Image.prototype.applyCss = function () {
    var css = this.model.get("css");
    // apply the sizing to the wrapper div
    if (css) {
      $(this.el).css(css);
      // also set the same width/height to the image itself
      this.$("img").css({
        width: css.width || "auto",
        height: css.height || "auto"
      });
      // finally, if we set % width, only set that on the outer container
      if ((css.width || "").indexOf("%") > -1) {
        this.$("img").css("width", "100%");
      }
    }
  };

  Image.prototype.updateHeightAndWidth = function () {
    var dimensions = this.model.get("url") && this.model.get("url").match(/_(\d+)_(\d+)\./);
    if (dimensions && dimensions[1] && dimensions[2]) {
      if (dimensions[1] > this.$el.width()) {
        this.model.set("css.width", "100%");
      } else if (!this.model.get("css.width") && !this.model.get("css.height")) {
        this.model.set("css.width", dimensions[1] + "px");
        this.model.set("css.height", dimensions[2] + "px");
      }
    }
  };

  Image.prototype.createRegions = function () {
    return new Regions({
      model: this.model,
      $container: this.$el
    });
  };

  Image.prototype.afterLoad = function () {
    if (this.model.get("action") === "regions") {
      this.regions.render();
    }
  };

  Image.prototype.$ = function (selector) {
    return this.$el.find(selector);
  };

  return Image;

});

define('@qubit---image@2.7.16', ['@qubit---image@2.7.16/image'], function (main) { return main; });

define('@qubit---modal@1.0.4/lib/css',['require','exports','module','@qubit/jquery'],function (require, exports, module) {var $ = require('@qubit/jquery')

module.exports = function applyCss (el, config) {
  if (config.css) {
    $(el).css(config.css)
  }
}

});

define('@qubit---modal@1.0.4/lib/defaults',['require','exports','module'],function (require, exports, module) {module.exports = {
  overlay: {
    css: {
      background: '#141414'
    },
    autoShow: false,
    opacity: 0.8
  },
  modal: {
    overlay: true,
    animation: {
      speed: '400',
      type: 'fade',
      delay: '0',
      direction: 'down'
    },
    position: {
      my: 'center center',
      x: '0px',
      y: '0px',
      fixed: true
    },
    css: {
      backgroundColor: '#fff',
      width: '400px',
      height: '200px',
      boxShadow: '0px 5px 20px 0px rgba(0, 0, 0, 0.2)'
    },
    closeButton: {
      type: 'thin',
      durationType: 'forever',
      durationString: '730days',
      top: 15,
      right: 15,
      bottom: 'auto',
      left: 'auto',
      width: 20,
      height: 20,
      color: '#000000',
      fontSize: '32px'
    }
  }
}

});

define('@qubit---modal@1.0.4/lib/position',['require','exports','module','@qubit/jquery','@qubit/such-dom','@qubit/jquery-ui/position'],function (require, exports, module) {var $ = require('@qubit/jquery')
var suchDom = require('@qubit/such-dom')
require('@qubit/jquery-ui/position')

function toFixed (el, options) {
  var $clone = $(el).clone()
  var position = suchDom.offset($(el))
  position.top -= $(window).scrollTop()
  position.left -= $(window).scrollLeft()
  $clone.css(position).css({
    position: 'fixed'
  }).appendTo('body')
  var newOffset = getOffset($clone.get(0), $.extend({}, {
    fixed: true
  }, options))
  $clone.remove()
  return $.extend({}, options, newOffset)
}

function toAbsolute (el, options) {
  var $clone = $(el).clone().empty()
  var position = $(el).position()
  $clone.css(position).css({
    position: 'absolute'
  }).appendTo('body')
  var newOffset = getOffset($clone.get(0), $.extend({}, {
    fixed: false
  }, options))
  $clone.remove()
  return $.extend({}, options, newOffset)
}

function getOffset (el, options) {
  var css = getPosition(el, {
    fixed: options.fixed,
    my: options.my,
    x: 0,
    y: 0
  })
  var isRight = /right/.test(options.my)
  var isBottom = /bottom/.test(options.my)
  var currentCss = $(el).position()
  var offset = {
    x: isRight ? css.left - currentCss.left : currentCss.left - css.left,
    y: isBottom ? css.top - currentCss.top : currentCss.top - css.top
  }

  if (options.fixed) {
    var scrollLeft = $(window).scrollLeft()
    offset.x += isRight ? scrollLeft : -scrollLeft
    var scrollTop = $(window).scrollTop()
    offset.y += isBottom ? scrollTop : -scrollTop
  }
  return offset
}

function getPosition (el, options) {
  var container = options.fixed ? window : document
  var $clone = $(el).clone().css({
    'position': options.fixed ? 'fixed' : 'absolute'
  })
  var positionOpts = {
    my: applyOffset(options),
    at: options.my,
    of: container,
    collision: 'none'
  }
  var result
  positionOpts.using = function (css) {
    result = limit($clone, container, css)
  }
  $clone.appendTo('body').position(positionOpts)
  $clone.remove()
  return result
}

function limit (el, container, css) {
  var $container = $(container)
  var maxLeft = $container.width() - $(el).outerWidth()
  var maxTop = $container.height() - $(el).outerHeight()
  css.left = (css.left < 0) ? 0 : css.left
  css.left = (css.left > maxLeft) ? maxLeft : css.left
  css.top = (css.top < 0) ? 0 : css.top
  css.top = (css.top > maxTop) ? maxTop : css.top
  return css
}

function applyOffset (options) {
  var i = 0
  return options.my.replace(/(left|right|center|top|bottom)([+-]\d+)?/gi, function (match, pos) {
    var amount = parseInt(i++ ? options.y : options.x, 10)
    if (amount === 0) {
      return pos
    } else if (pos === 'right' || pos === 'bottom') {
      amount = -amount
    }
    return pos + (amount >= 0 ? '+' : '') + amount
  })
}

module.exports = {
  getPosition: getPosition,
  limit: limit,
  applyOffset: applyOffset,
  getOffset: getOffset,
  toFixed: toFixed,
  toAbsolute: toAbsolute
}

});

define('@qubit---modal@1.0.4/lib/overlay',['require','exports','module','@qubit/overlay'],function (require, exports, module) {var Overlay = require('@qubit/overlay')

/*
 singleton overlay shared between modals
*/

var overlay

function render (options, cb) {
  if (!overlay) {
    overlay = new Overlay(document.body, options)
  } else {
    overlay.init(document.body, options)
  }
  overlay.show(cb)
  return overlay
}

function hide (cb) {
  if (overlay) overlay.hide(cb)
}

function destroy () {
  if (overlay) overlay.destroy()
  overlay = false
}

module.exports = {
  render: render,
  hide: hide,
  destroy: destroy
}

});

define('@qubit---modal@1.0.4/lib/animation',['require','exports','module','@qubit/jquery','@qubit/velocity'],function (require, exports, module) {var $ = require('@qubit/jquery')
var velocity = require('@qubit/velocity')
var animation

function render (el, opts, cb) {
  if (opts.type === 'slide') {
    animation.slide(el, opts, fixOverflow(el, cb))
  } else if (opts.type === 'fade') {
    animation.fade(el, opts, fixOverflow(el, cb))
  } else {
    $(el).hide(0)
    $(el).delay(Number(opts.delay || 0)).show(0, fixOverflow(el, cb))
  }
}

function fixOverflow (el, cb) {
  return function () {
    $(el).css('overflow', '')
    cb()
  }
}

function fade (el, opts, cb) {
  $(el).hide(0).delay(Number(opts.delay || 0)).fadeIn(Number(opts.speed), function () {
    return cb && cb()
  })
}

function slide (el, opts, cb) {
  var start = {}
  var end = {
    top: parseInt($(el).css('top'), 10),
    left: parseInt($(el).css('left'), 10)
  }
  var $container = $(document)
  var containerHeight = $container.height()
  var containerWidth = $container.width()
  switch (opts.direction) {
    case 'down':
      start.top = -el.offsetHeight
      start.left = end.left
      break
    case 'up':
      start.top = containerHeight + el.offsetHeight
      start.left = end.left
      break
    case 'right':
      start.top = end.top
      start.left = -el.offsetWidth
      break
    default:
      start.top = end.top
      start.left = containerWidth + el.offsetWidth
      break
  }
  $(el)
    .css(start)
    .delay(Number(opts.delay || 0))
    .queue(function () {
      var self = this
      velocity(el, end, {
        easing: 'swing',
        duration: Number(opts.speed),
        complete: function () {
          $(self).dequeue()
          return cb && cb()
        }
      })
    })
}

animation = {
  fade: fade,
  slide: slide,
  render: render
}

module.exports = animation

});

define('@qubit---modal@1.0.4/lib/render',['require','exports','module','@qubit/jquery','@qubit/maxz','./css','./defaults','./position','./overlay','./animation'],function (require, exports, module) {var $ = require('@qubit/jquery')
var maxz = require('@qubit/maxz')
var applyCss = require('./css')
var defaults = require('./defaults')
var position = require('./position')
var overlay = require('./overlay')
var animation = require('./animation')

var maxzCache, overlayInstance

function showTools (api) {
  return api && api.tools && api.tools.show()
}

function hideTools (api) {
  return api && api.tools && api.tools.hide()
}

function applyPosition (el, positionOpts) {
  $(el).css({
    position: positionOpts.fixed ? 'fixed' : 'absolute',
    top: 0,
    left: 0
  })
  if (positionOpts.my) {
    $(el).css(position.getPosition(el, positionOpts))
  }
}

function getCallback (todo, cb) {
  return function callback () {
    if (!--todo) cb()
  }
}

function renderModal (el, config, options) {
  options = options || {}
  config = config || {}
  hideTools(options.api)

  // These lines are important because we want
  // the existing modal to stay in the DOM
  // so that event propagation doesn't get
  // destroyed
  if ($(el).parents('body').length) {
    $(el).show()
  } else {
    $(el).appendTo(document.body)
  }

  applyCss(el, config)

  if (config.position) {
    applyPosition(el, config.position)
  }

  if (!options.sync && (config.overlay || config.animation)) {
    var todo = !!config.animation + !!config.overlay
    var cb = getCallback(todo, function () {
      $(el).hasClass('deliver-is-selected') && showTools(options.api)
    })
    var overlayOpts = $.extend({}, defaults.overlay, {
      speed: config.animation && config.animation.speed && Number(config.animation.speed),
      delay: options.minDelay
    })
    if (config.overlay) {
      overlayInstance = overlay.render(overlayOpts, cb)
    }
    if (config.animation) animation.render(el, config.animation, cb)
  } else {
    showTools(options.api)
  }
  maxzCache = maxzCache || maxz()
  var zIndex = overlayInstance ? overlayInstance.$overlay.css('zIndex') + 1 : maxzCache
  $('.deliver-component-Modal').css('zIndex', zIndex)
}

module.exports = renderModal

});

define('@qubit---modal@1.0.4/modal',['require','exports','module','@qubit/jquery','@qubit/close/close-button','@qubit/close/settings/convert-duration-to-ms','./lib/render','./lib/overlay'],function (require, exports, module) {var $ = require('@qubit/jquery')
var closeButton = require('@qubit/close/close-button')
var convertDurationToMs = require('@qubit/close/settings/convert-duration-to-ms')
var renderModal = require('./lib/render')
var overlay = require('./lib/overlay')

var modals = []
var closeButtonHelper
var className = 'deliver-component-Modal'

function Modal (options) {
  this.init(options)
  this.modals = modals
}

function init (options) {
  this.options = options || {}
  this.model = this.options.model
  this.api = this.options.api
  this.el = document.createElement('div')
  if (modals.indexOf(this) < 0) modals.push(this)
  $(this.el).addClass(className + ' deliver-allowChildren')
  this.closeButton = closeButton
}

function render () {
  this.bindEvents()
  this.removeModal()
  this.renderModalWithOptions()
  return this.el
}

function renderModalWithOptions (options) {
  options = options || {}
  var closeButtonOnly = options.closeButtonOnly === true
  var sync = options.sync === true
  var api = this.api
  var model = this.model

  if (!closeButtonOnly) {
    this.renderModal(this.el, model && model.toJSON(), {
      uiState: this.uiState,
      api: api,
      sync: sync,
      minDelay: getMinDelay()
    })
  }

  if (model && model.get('closeButton')) {
    this.renderCloseButton()
  }
}

function renderCloseButton () {
  var model = this.model
  var options = this.options
  closeButtonHelper = this.closeButton.render($.extend({}, model.get('closeButton'), {
    container: this.el,
    onChange: function (nextConfig) {
      model.set('closeButton', $.extend(true, {}, model.get('closeButton'), nextConfig))
    },
    onClick: onCloseButtonClick(this),
    uiState: options.uiState
  }))
}

function onCloseButtonClick (context) {
  return function () {
    var durationMs
    if (context.model.get('closeButton.type') !== 'none') {
      durationMs = convertDurationToMs(context.model.get('closeButton.durationString') || 0)
    }
    context.api.close(durationMs)
  }
}

function modalsWithActiveOverlay () {
  return $.grep(modals, function (modal) {
    return !!modal.activeOverlay
  }).length
}

function removeOverlay () {
  if (this.activeOverlay) {
    delete this.activeOverlay
    if (!modalsWithActiveOverlay()) overlay.destroy()
  }
}

function removeModal () {
  closeButtonHelper && closeButtonHelper.remove()
  $(this.el).stop().detach()
  this.removeOverlay()
}

function remove () {
  this.unbindEvents()
  var i = modals.indexOf(this)
  if (i >= 0) modals.splice(i, 1)
  this.removeModal()
  closeButtonHelper && closeButtonHelper.remove()
}

function getMinDelay () {
  return Math.min.apply(Math, $.map(modals, function (modal) {
    var delay = modal.model && modal.model.get('animation.delay')
    return delay && Number(delay) || 0
  }))
}

function onClick () {
  this.remove()
}

function bindEvents () {
  var self = this
  this.unbindEvents()
  this.boundRenderOnResize = this.boundRenderOnResize || function (e) {
    if (e.target !== window) return
    $(self.el).detach()
    return self.renderModal(self.el, self.model && self.model.toJSON(), {
      api: self.api,
      sync: true,
      minDelay: getMinDelay()
    })
  }
  $(window).on('resize', this.boundRenderOnResize)

  if (this.model && this.model.get('overlay')) {
    this.boundRemoveOnOverlayClick = this.boundRemoveOnOverlayClick || function (e) {
      if (self.el === e.target || $.contains(self.el, e.target)) return

      if ($(e.target).parents('.' + className).length && self.closeButton.isCloseButton(e.target)) {
        self.api.close()
      } else {
        self.onCloseButtonClick(self)()
      }
    }
    $(document.body).on('click', this.boundRemoveOnOverlayClick)
  }
}

function unbindEvents () {
  if (this.boundRenderOnResize) {
    $(window).off('resize', this.boundRenderOnResize)
    delete this.boundRenderOnResize
  }
  if (this.boundRemoveOnOverlayClick) {
    $(document.body).off('click', this.boundRemoveOnOverlayClick)
    delete this.boundRemoveOnOverlayClick
  }
}

function renderModalWrapper () {
  this.activeOverlay = !!(this.model && this.model.get('overlay'))
  renderModal.apply(this, arguments)
}

Modal.prototype = {
  init: init,
  render: render,
  removeModal: removeModal,
  renderModal: renderModalWrapper,
  renderModalWithOptions: renderModalWithOptions,
  renderCloseButton: renderCloseButton,
  removeOverlay: removeOverlay,
  onClick: onClick,
  onCloseButtonClick: onCloseButtonClick,
  bindEvents: bindEvents,
  unbindEvents: unbindEvents,
  getMinDelay: getMinDelay,
  remove: remove
}

module.exports = Modal

});

define('@qubit---modal@1.0.4', ['@qubit---modal@1.0.4/modal'], function (main) { return main; });


define('@qubit---css@0.1.6/css!@qubit-ce---qubit-recommendation@2.1.0/styles',[],function(){});
define('@qubit---text@2.0.12/text',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define('@qubit---text@2.0.12', ['@qubit---text@2.0.12/text'], function (main) { return main; });


define('@qubit---text@2.0.12/text!@qubit-ce---qubit-recommendation@2.1.0/template.html',[],function () { return '<h2><%= recentlyViewedTitleText %></h2>\n<ul class="deliver-component-QubitRec-list">\n<% _.each(products, function (product, index) { %>\n  <% if (index < (rowCount*columnCount)) { %>\n    <li data-sku="<%= product.sku_code %>" data-weight="<%= product.weight %>"\n      data-segment="<%= product.segment %>" data-position="<%= (index+1) %>" class="deliver-component-QubitRec-item">\n      <a class="deliver-component-QubitRec-itemLink" href="<%= product.url %>"><img class="deliver-component-QubitRec-itemImage" src="<%= product.image_url %>"/></a>\n\n    <% if (showName) { %>\n      <a class="deliver-component-QubitRec-itemLink" href="<%= product.url %>"><span class="deliver-component-QubitRec-itemTitle"><%= product.name %></span></a>\n    <% } %>\n\n    <% if (showPrice) { %>\n      <p><span class="deliver-component-QubitRec-itemPrice <%= showSalePrice && product.unit_price !== product.unit_sale_price ? \'deliver-is-disabled\' : \'deliver-is-enabled\' %>">\n        <%- currencySymbol + "" + product.unit_price.toFixed(2) %>\n      </span></p>\n    <% } %>\n\n    <% if (showSalePrice && product.unit_price !== product.unit_sale_price) { %>\n      <p><span class="deliver-component-QubitRec-itemPrice deliver-component-QubitRec-itemSalePrice">\n        <%- currencySymbol + "" + product.unit_sale_price.toFixed(2) %>\n      </span></p>\n    <% } %>\n    </li>\n    <% if ((index+1) % columnCount === 0 && (index !== (rowCount*columnCount))) { %>\n      </ul><ul class="deliver-component-QubitRec-list">\n    <% } %>\n  <% } %>\n<% }) %>\n<br style="clear:both"/>\n</ul>\n';});

define('@qubit-ce---qubit-recommendation@2.1.0/strategies',['require','exports','module'],function (require, exports, module) {module.exports = {
  engagement: 'universal_variable',
  boughtTogether: 'universal_variable',
  recommendedForYou: function () {
    try {
      var get = JSON.parse(window.localStorage.getItem('__qbPrItems') || '[]');
      if (get.length) return get;
      return null;
    } catch (err) {
      console.warn('JSON Pars Err: ' + err);
    }
  }
};

});

define('@qubit-ce---qubit-recommendation@2.1.0/productIdentifier',['require','exports','module'],function (require, exports, module) {module.exports = {
  productSku: 'product.sku_code',
  productId: 'product.id'
};

});

define('@qubit-ce---qubit-recommendation@2.1.0/providers/qubit/runtime',['require','exports','module','@qubit/underscore','cookieman','./../../strategies','./../../productIdentifier'],function (require, exports, module) {var _ = require('@qubit/underscore');
var cookieman = require('cookieman');
var strategies = require('./../../strategies');
var identifiers = require('./../../productIdentifier');

function getStrategy (strategy) {
  if (strategy === 'boughtTogether') {
    return 'pp3';
  }
  return 'pp1';
}


module.exports = {
  moduleConfig: function (trackingId, input) {
    var seed;
    if (input.strategy) {
      var recommend = strategies[input.strategy];
      if (typeof recommend === 'function') {
        seed = recommend() || ['' + window.universal_variable.product.sku_code] || false;
      } else {
        var identifier = identifiers[input.productIdentifier] || 'product.sku_code';
        var starter = strategies[input.strategy] + '.' + identifier;
        seed = [];
        seed.push('' + eval(starter));
      }
    }

    var columnCount = input.columnCount || 4;
    var rowCount = input.rowCount || 1;

    return {
      accountId: input.qubit_accountId || trackingId || false,
      noOfProducts: (rowCount * columnCount),
      strategy: getStrategy(input.strategy),
      seedProduct: seed,
      trackingId: cookieman.get('_qubitTracker')[0].value
    };
  },

  requestConfig: function (input) {
    return {
      url: 'https://recommend.qubitproducts.com/vc/recommend/2.0/' +
       input.accountId + '?strategy=' + input.strategy + '&id=' + input.trackingId + '&n=' + input.noOfProducts,
      type: 'POST',
      dataType: 'json',
      data: JSON.stringify({h: input.seedProduct})
    };
  },

  normalizeResults: function (data, strategy) {
    var skusAndWeightsArray = [];
    _.each(data.result.items, function (item) {
      skusAndWeightsArray.push({ sku: item.details.sku_code, weight: item.weight });
      item.details.weight = item.weight;
      item.details.segment = data.segment;
    });

    window.universal_variable.events.push({
      'category': 'qubit-recommendations',
      'action': 'recommendations-shown',
      'details': {
        'itemsShown': skusAndWeightsArray,
        'segment': data.segment,
        'strategy': strategy
      }
    });

    return _.pluck(data.result.items, 'details');
  }
};

});

define('@qubit-ce---qubit-recommendation@2.1.0/currency_conversion',['require','exports','module'],function (require, exports, module) {module.exports = {
  'GBP': '£', // British Pound Sterling
  'USD': '$', // US Dollar
  'EUR': '€', // Euro
  'CRC': '₡', // Costa Rican Colón
  'ILS': '₪', // Israeli New Sheqel
  'INR': '₹', // Indian Rupee
  'JPY': '¥', // Japanese Yen
  'KRW': '₩', // South Korean Won
  'NGN': '₦', // Nigerian Naira
  'PHP': '₱', // Philippine Peso
  'PLN': 'zł', // Polish Zloty
  'PYG': '₲', // Paraguayan Guarani
  'THB': '฿', // Thai Baht
  'UAH': '₴', // Ukrainian Hryvnia
  'VND': '₫' // Vietnamese Dong
};

});

define('@qubit-ce---qubit-recommendation@2.1.0/mock_products',['require','exports','module'],function (require, exports, module) {module.exports = [
  {
    'id': '1',
    'sku_code': '0001',
    'url': 'http://fashion-demo.qubitproducts.com/coats/agent-coat.html',
    'name': 'Agent Coat',
    'unit_price': 129,
    'unit_sale_price': 129,
    'description': 'Agent Coat',
    'category': 'Default Category',
    'subcategory': 'Coats',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/j/p/jpeg.jpg',
    'currency': 'USD'
  },
  {
    'id': '2',
    'sku_code': '0002',
    'url': 'http://fashion-demo.qubitproducts.com/coats/olive-coat.html',
    'name': 'Olive Coat',
    'unit_price': 119,
    'unit_sale_price': 119,
    'description': 'Olive Coat',
    'category': 'Default Category',
    'subcategory': 'Coats',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/1/4/14134.jpg',
    'currency': 'USD'
  },
  {
    'id': '13',
    'sku_code': '1005',
    'url': 'http://fashion-demo.qubitproducts.com/sweaters/striped-sweater.html',
    'name': 'Striped Sweater',
    'unit_price': 60,
    'unit_sale_price': 60,
    'description': 'Striped Sweater',
    'category': 'Default Category',
    'subcategory': 'Sweaters',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/j/p/jpeg-6.jpg',
    'currency': 'USD'
  },
  {
    'id': '17',
    'sku_code': '2000',
    'url': 'http://fashion-demo.qubitproducts.com/sweaters/zip-sweater.html',
    'name': 'Zip Sweater',
    'unit_price': 60,
    'unit_sale_price': 60,
    'description': 'Zip Sweater',
    'category': 'Default Category',
    'subcategory': 'Sweaters',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/s/w/sweater-front.jpg',
    'currency': 'USD'
  },
  {
    'id': '8',
    'sku_code': '0009',
    'url': 'http://fashion-demo.qubitproducts.com/dresses/two-tone-dress.html',
    'name': 'Two Tone Dress',
    'unit_price': 70,
    'unit_sale_price': 70,
    'description': 'Two Tone Dress',
    'category': 'Default Category',
    'subcategory': 'Dresses',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/d/r/dress_1.jpg',
    'currency': 'USD'
  },
  {
    'id': '9',
    'sku_code': '0007',
    'url': 'http://fashion-demo.qubitproducts.com/dresses/grey-dress.html',
    'name': 'Grey Dress',
    'unit_price': 80,
    'unit_sale_price': 80,
    'description': 'Grey Dress\r\n',
    'category': 'Default Category',
    'subcategory': 'Dresses',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/d/r/dress.jpg',
    'currency': 'USD'
  },
  {
    'id': '80',
    'sku_code': '20947',
    'url': 'http://fashion-demo.qubitproducts.com/dresses/port-dress.html',
    'name': 'Port Dress',
    'unit_price': 79,
    'unit_sale_price': 79,
    'description': 'A custom print striped dress',
    'category': 'Festival',
    'subcategory': 'Dresses',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/p/o/port-dress.jpg',
    'currency': 'USD'
  },
  {
    'id': '81',
    'sku_code': '20958',
    'url': 'http://fashion-demo.qubitproducts.com/dresses/polly-dress.html',
    'name': 'Polly Dress',
    'unit_price': 100,
    'unit_sale_price': 100,
    'description': 'A custom print striped dress',
    'category': 'Festival',
    'subcategory': 'Dresses',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/p/o/polly-dress.jpg',
    'currency': 'USD'
  },
  {
    'id': '82',
    'sku_code': '20458',
    'url': 'http://fashion-demo.qubitproducts.com/dresses/baisley-dress.html',
    'name': 'Baisley Dress',
    'unit_price': 59,
    'unit_sale_price': 59,
    'description': 'The ultimate casual look',
    'category': 'Festival',
    'subcategory': 'Dresses',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/b/a/baisley-dress.jpg',
    'currency': 'USD'
  },
  {
    'id': '4',
    'sku_code': '0004',
    'url': 'http://fashion-demo.qubitproducts.com/t-shirts/striped-t-shirt.html',
    'name': 'Striped T-Shirt',
    'unit_price': 40,
    'unit_sale_price': 40,
    'description': 'Striped T-Shirt',
    'category': 'Default Category',
    'subcategory': 'T-Shirts',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/1/2/12459.jpg',
    'currency': 'USD'
  },
  {
    'id': '18',
    'sku_code': '2001',
    'url': 'http://fashion-demo.qubitproducts.com/t-shirts/triangle-t-shirt.html',
    'name': 'Triangle T-Shirt',
    'unit_price': 30,
    'unit_sale_price': 20,
    'description': 'Triangle T-Shirt',
    'category': 'Festival',
    'subcategory': 'T-Shirts',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/t/r/triangle-t.jpg',
    'currency': 'USD'
  },
  {
    'id': '79',
    'sku_code': '20946',
    'url': 'http://fashion-demo.qubitproducts.com/t-shirts/stella-tee.html',
    'name': 'Stella Tee',
    'unit_price': 29.99,
    'unit_sale_price': 29.99,
    'description': 'Woman\'s Mid Length T-Shirt',
    'category': 'Festival',
    'subcategory': 'T-Shirts',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/s/t/stella-tee.jpg',
    'currency': 'USD'
  },
  {
    'id': '16',
    'sku_code': '1009',
    'url': 'http://fashion-demo.qubitproducts.com/pants/shorts.html',
    'name': 'Shorts',
    'unit_price': 50,
    'unit_sale_price': 50,
    'description': 'Shorts',
    'category': 'Default Category',
    'subcategory': 'Pants',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/s/h/shorts.jpg',
    'currency': 'USD'
  },
  {
    'id': '83',
    'sku_code': '20959',
    'url': 'http://fashion-demo.qubitproducts.com/pants/anchor-pant.html',
    'name': 'Anchor Pant',
    'unit_price': 45,
    'unit_sale_price': 45,
    'description': 'Cheerful sailor stripes',
    'category': 'Festival',
    'subcategory': 'Pants',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/a/n/anchor-pant.jpg',
    'currency': 'USD'
  },
  {
    'id': '12',
    'sku_code': '1003',
    'url': 'http://fashion-demo.qubitproducts.com/festival/sun-glasses.html',
    'name': 'Sun Glasses',
    'unit_price': 80,
    'unit_sale_price': 80,
    'description': 'Sun Glasses',
    'category': 'Festival',
    'subcategory': 'Accessories',
    'image_url': 'http://fashion-demo.qubitproducts.com/media/catalog/product/cache/1/image/800x800/9df78eab33525d08d6e5fb8d27136e95/s/u/sunnies-new.jpg',
    'currency': 'USD'
  }
]

});

define('@qubit-ce---qubit-recommendation@2.1.0/index',['require','exports','module','css!./styles','@qubit/underscore','@qubit/jquery','text!./template.html','./providers/qubit/runtime','./currency_conversion','./mock_products'],function (require, exports, module) {require('css!./styles');

var _ = require('@qubit/underscore');
var $ = require('@qubit/jquery');
var template = require('text!./template.html');
var qubitIntegration = require('./providers/qubit/runtime');
var currencyCodeToCurrencySymbol = require('./currency_conversion');
var mockProducts = require('./mock_products');

function Recommendations (options) {
  this.api = options.api;
  this.model = options.model;
  this.uiState = options.uiState;
  this.el = document.createElement('div');
  this.$el = $(this.el);
  this.$el.addClass('deliver-component-QubitRec');
  this.trackingId = options.meta.property.trackingId;

  var defaults = {
    showPrice: true,
    showName: true,
    columnCount: 4,
    rowCount: 1,
    productIdentifier: 'productSku',
    strategy: 'engagement',
    editing: {
      element: 'container'
    },
    css: {
      container: {
        fontSize: '22px',
        textAlign: 'center',
        fontWeight: 'normal'
      },
      name: {
        paddingLeft: 5
      },
      price: {},
      salePrice: {},
      title: {}
    }
  };
  this.model.set($.extend(true, {}, defaults, this.model.toJSON()));
  this.model.on('change', this.render, this);
}

function withDefault (modelAttributes, attribute, def) {
  if (typeof modelAttributes[attribute] !== undefined) {
    return modelAttributes[attribute];
  } else {
    return def;
  }
}

Recommendations.prototype.render = function () {
  // get the products from the source specificed in the dataSource
  // using the options defined in its runtime.js config file
  // then pass the normalized product array into the renderItems function
  this.getProducts(qubitIntegration)
    .then(_.bind(this.renderItems, this));
};

// render the product items block
Recommendations.prototype.renderItems = function (items) {
  var api = this.api;
  var templateData = this.getTemplateData(items);
  var productHtml = _.template(template)(templateData);

  this.$el.html(productHtml);

  this.applyCss();
  this.addStyleSheet(this.model.get('cssEditor'));

  if (!this.api.inEditor()) {
    this.setupTracking();
  }

  if (this.api.inEditor()) {
    // the images take a bit of time to load in, and
    // after they're loaded - the container height changes
    // tackle this issue imperfectly with a few setTimeouts
    burst(function () {
      api.tools.refresh();
    });
  }
};

function burst (fn) {
  _.each([1, 50, 100, 500, 1000], function (t) {
    setTimeout(fn, t);
  });
}

Recommendations.prototype.setupTracking = function () {
  var strategy = this.model.toJSON().strategy || 'pp1';

  $('.deliver-component-QubitRec-item').unbind('click.qbRecs');

  $('.deliver-component-QubitRec-item').on('click.qbRecs', function () {
    var $el = $(this);
    var productSku = $el.attr('data-sku');
    var productWeight = $el.attr('data-weight');
    var segment = $el.attr('data-segment');
    var position = $el.attr('data-position');

    window.universal_variable && window.universal_variable.events.push({
      'category': 'qubit-recommendations',
      'action': 'recommendations-clickthrough',
      'details': {
        'sku': productSku,
        'weight': productWeight,
        'position': position,
        'segment': segment,
        'strategy': strategy
      }
    });
  });
};

Recommendations.prototype.remove = function () {
  this.model.off('change', this.render);
  this.$el.remove();
};

// get the data required for the template rendering
Recommendations.prototype.getTemplateData = function (productList) {
  var currencyCode = this.model.get('currencyCode') || 'GBP';

  return {
    recentlyViewedTitleText: this.model.get('title') || 'Recommendations',
    products: productList,
    columnCount: parseInt(this.model.get('columnCount'), 10) || 4,
    rowCount: parseInt(this.model.get('rowCount'), 10) || 1,
    showPrice: withDefault(this.model.attributes, 'showPrice', true),
    showSalePrice: withDefault(this.model.attributes, 'showSalePrice', false),
    showName: withDefault(this.model.attributes, 'showName', true),
    currencySymbol: currencyCodeToCurrencySymbol[currencyCode]
  };
};

Recommendations.prototype.getProducts = function (config) {
  if (this.api.inEditor()) {
    var products = mockProducts;
    return $.Deferred().resolve(products);
  }

  var strategy = this.model.toJSON().strategy || 'pp1';

  return $.ajax(
            config.requestConfig(
              config.moduleConfig(
                this.trackingId, this.model.toJSON()
              )
            )
          )
          .then(function (data) {
            if (data.result === 'Backend error') {
              return false;
            }
            return config.normalizeResults(data, strategy);
          });
};

Recommendations.prototype.addStyleSheet = function (css) {
  var head, styleElement;
  head = document.getElementsByTagName('head')[0];
  styleElement = document.createElement('style');
  styleElement.setAttribute('type', 'text/css');
  if (css instanceof Array) {
    css = css.join('');
  }
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    styleElement.appendChild(document.createTextNode(css));
  }
  head.appendChild(styleElement);
  return styleElement;
};

Recommendations.prototype.applyCss = function () {
  var styles = this.model.get('css') || {};
  this.$el.css(styles.container);

  var width = (100 / (this.model.get('columnCount'))) + '%';
  this.$el.find('.deliver-component-QubitRec-item').css({width: width});

  this.$el.find('h2').css(styles.title);
  this.$el.find('.deliver-component-QubitRec-itemPrice').css(styles.price);
  this.$el.find('.deliver-component-QubitRec-itemSalePrice').css(styles.salePrice);
  this.$el.find('.deliver-component-QubitRec-itemTitle').css(styles.name);
};

module.exports = Recommendations;

});

define('@qubit-ce---qubit-recommendation@2.1.0', ['@qubit-ce---qubit-recommendation@2.1.0/index'], function (main) { return main; });

define('@qubit---remember-preview@1.0.1/index',['require','exports','module'],function (require, exports, module) {module.exports = function(minutes, creatives, domain) {
  minutes = minutes || 15;
  var creative = document.location.href.match(/etcForceCreative=([^\&]+)(&|$)/);
  if (creative && creative[1]) {
    creative = creative[1];
    if (creatives && creatives.length) {
      if (typeof creative === "string") {
        creative += ("," + creatives);
      } else {
        creative += ("," + creatives.join(","));
      }
    }
    if (creative) {
      var date = new Date();
      if (domain) {
        domain = "; domain=" + domain;
      } else {
        domain = "";
      }
      date.setTime(date.getTime() + (minutes * 60 * 1000));
      document.cookie = "smartserve_preview=true; expires=" + date.toGMTString() + "; path=/" + domain;
      document.cookie = "etcForceCreative=[" + creative + "]; expires=" + date.toUTCString() + "; path=/" + domain;
    }
  }
};
});

define('@qubit---remember-preview@1.0.1', ['@qubit---remember-preview@1.0.1/index'], function (main) { return main; });

define('@qubit---mvt@1.1.1/lib/id',['require','exports','module','@qubit/underscore'],function (require, exports, module) {var _ = require('@qubit/underscore')
var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

function val (id) {
  var total = 0, l = id.length, base = alphabet.length
  while (l--) {
    total += (alphabet.indexOf(id[id.length - 1 - l]) * Math.pow(base, l))
  }
  return total
}

function id (value) {
  var val = value, base = alphabet.length, digits, remainder
  if (!val) return alphabet[0]
  while (val > 0) {
    remainder = val % base
    digits = alphabet[remainder] + (digits || '')
    val = (val - remainder) / base
  }
  return digits
}

function next (ids) {
  if (!ids.length) {
    return alphabet[0]
  }
  var max = Math.max.apply(Math, (_.map(ids, function (id) {
    return val(id)
  })))
  return id(max + 1)
}

function random (n) {
  return Math.floor(Math.random() * n) + 1
}

module.exports = {
  val: val,
  id: id,
  next: next,
  random: random
}

});

define('@qubit---mvt@1.1.1/lib/state',['require','exports','module','@qubit/underscore','cookieman'],function (require, exports, module) {var _ = require('@qubit/underscore')
var cm = require('cookieman')
var namespace = 'qubit-deliver-amvt'

var state = {

  cm: cm,

  namespace: namespace,

  // get or set mvt state of all experiments
  val: function (cookieDomain, masterId, val) {
    if (_.isUndefined(val)) return this.get(masterId)
    var db = this.get()
    if (masterId) {
      db[masterId] = val
    } else {
      db = val
    }
    state.cm.set(namespace, this.serialize(db), {
      domain: cookieDomain,
      expires: new Date(new Date().valueOf() + (1000 * 60 * 60 * 24 * 365))
    })
    return db
  },

  // get mvt state of all or (optionally pass masterId) a specific experiment
  get: function (masterId) {
    var val = state.cm.get(namespace)
    var result = this.parse(val && val[0] && val[0].value)
    if (masterId) {
      return _.extend({}, result[masterId], this.override(window.location.href))
    }
    return result
  },

  // get experiment state override
  override: function (href) {
    var state = href.match(/qubit-deliver-mvt=([^&]+)/i)
    return state && state[1] && this.parseState(state[1])
  },

  /*
   * given '123:AA1B2C2,987:VC2W3D432,87:A1b2C3'
   * returns { 123:'AA1B2C2', 987:'VC2W3D432', 87:'A1b2C3' }
   */
  parseAllStates: function (val) {
    return (val && _.chain(val.split(',')).map(function (v) {
      return v.split(':')
    }).object().value()) || {}
  },

  /*
   *  given 'VC2W3D432' returns {VC: 2, W: 3, D: 432}
   */
  parseState: function (val) {
    return (val && _.chain(val.match(/[A-Z]+\d+/gi)).map(function (v) {
      return v.match(/([A-Z]+)(\d+)/i).slice(1)
    }).object().reduce(function (obj, value, key) {
      obj[key] = parseInt(value, 10)
      return obj
    }, {}).value()) || {}
  },

  /*
   * given '123:AA1B2C2,987:VC2W3D432,87:A1b2C3'
   * returns { 123:{ AA: 1, B: 2, C: 2 }', 987: { VC: 2, W: 3, D: 432 }, 87: { A: 1, b: 2, C: 3 } }
   */
  parse: function (val) {
    var self = this
    val = val && this.parseAllStates(val)
    return (val && _.reduce(val, function (obj, value, key) {
      obj[key] = self.parseState(value)
      return obj
    }, {})) || {}
  },

  /*
   *  given {VC: 2, W: 3, D: 432} returns 'VC2W3D432'
   */
  serializeState: function (val) {
    return (val && _.chain(val).pairs().sortBy(_.first).flatten().value().join('')) || ''
  },

  /*
   * given { 123: { AA: 1, B: 2, C: 2 }', 987: { VC: 2, W: 3, D: 432 }, 87: { A: 1, b: 2, C: 3 } }
   * returns '123:AA1B2C2,987:VC2W3D432,87:A1b2C3'
   */
  serialize: function (val) {
    var self = this
    return (val && _.chain(val).reduce(function (arr, value, key) {
      arr.push([key, self.serializeState(value)].join(':'))
      return arr
    }, []).value().join(',')) || ''
  }

}

module.exports = state

});

define('@qubit---mvt@1.1.1/lib/ping',['require','exports','module','./state'],function (require, exports, module) {var state = require('./state')

function ping (cookieDomain, masterId, iterationId, experimentId) {
  if (!masterId || !iterationId || !experimentId) return
  var experimentState = state.serializeState(state.val(cookieDomain, masterId))
  experimentState && window.universal_variable && window.universal_variable.events && window.universal_variable.events.push({
    action: 'mvt',
    e: experimentId,
    i: iterationId,
    cm: masterId,
    mvt: experimentState
  })
}

module.exports = ping

});

define('@qubit---mvt@1.1.1/lib/moveit',['require','exports','module','@qubit/underscore','./id','./state','./ping'],function (require, exports, module) {var _ = require('@qubit/underscore')
var id = require('./id')
var state = require('./state')
var ping = require('./ping')

var moveit
moveit = {
  id: id,
  state: state,
  ping: ping,
  mvt: function mvt (options, racks, disablePing) {
    var masterId = options.variationMasterId
    var iterationId = options.iterationId
    var experimentId = options.experimentId
    var cookieDomain = options.cookieDomain

    var db = moveit.state.val(cookieDomain, masterId)
    var ids = []
    _.each(racks, function (rack) {
      var rackId = moveit.id.next(ids)
      ids.push(rackId)
      var selected = db[rackId]
      if (!selected) {
        // select spice
        db[rackId] = selected = moveit.id.random(rack.length)
        // save new state
        moveit.state.val(cookieDomain, masterId, db)
      }
      // call selected callback
      if (_.isFunction(rack[selected - 1])) {
        try {
          rack[selected - 1]()
        } catch (e) {}
      }
    })
    // ping experiment state
    if (!disablePing) moveit.ping(cookieDomain, masterId, iterationId, experimentId)
  }
}

module.exports = moveit

});

define('@qubit---mvt@1.1.1/index',['require','exports','module','@qubit/underscore','./lib/moveit'],function (require, exports, module) {var _ = require('@qubit/underscore')
var moveit = require('./lib/moveit')

module.exports = _.bind(moveit.mvt, moveit)

});

define('@qubit---mvt@1.1.1', ['@qubit---mvt@1.1.1/index'], function (main) { return main; });

define('@qubit---send-uv-event@1.0.1/index',['require','exports','module','@qubit/underscore'],function (require, exports, module) {var _ = require('@qubit/underscore')

function sendEvent (action, meta, extra) {
  if (!_.isString(action)) throw new Error('action should be a String')
  if (meta && !_.isObject(meta)) throw new Error('meta should be an Object')
  if (meta && (!meta.experimentId || !meta.variationMasterId)) {
    throw new Error('meta should contain experiment Id and master Id')
  }
  if (extra && !_.isObject(extra)) throw new Error('extra should be an Object')

  var eventObject = {
    'action': action
  }

  if (!_.isEmpty(meta)) {
    _.extend(eventObject, {
      'creative_master': meta.variationMasterId,
      'experiment_id': meta.experimentId
    })
  }
  _.extend(eventObject, extra)
  if (!eventObject.category) eventObject.category = 'qubit-deliver'

  window.universal_variable = window.universal_variable || {}
  window.universal_variable.events = window.universal_variable.events || []
  window.universal_variable.events.push(eventObject)

  if (window._ss_debug && window.console) {
    console.log('Sending UV Event with action: ' + action, eventObject)
  }
}

module.exports = sendEvent

});

define('@qubit---send-uv-event@1.0.1', ['@qubit---send-uv-event@1.0.1/index'], function (main) { return main; });

define('@qubit---uv-api@2.0.1/uv-api',['require','exports','module'],function (require, exports, module) {/**
 * Creates a global uv object for emmitting and listening for events.
 */
(function () {

  /**
   * Creates the uv object with empty
   * events and listeners arrays.
   * @type {Object}
   */
  var uv = {
    events: [],
    listeners: []
  }

  /**
   * Pushes an event to the events array and triggers any handlers for that event
   * type, passing the data to that handler. Clones the data to prevent side effects.
   * @param {String} type The type of event.
   * @param {Object} data The data associated with the event.
   */
  uv.emit = function emit (type, data) {
    data = clone(data || {})
    data.meta = {
      type: type
    }
    uv.events.push(data)
    forEach(uv.listeners, function (listener) {
      if (listener.type === type || listener.type === '*') {
        try {
          listener.callback.call(listener.context, data)
        } catch (e) {
          if (console && console.error) {
            console.error('Error emitting UV event', e.stack)
          }
        }
      }
    })
  }

  /**
   * Attaches an event handler to listen to the type of event specified.
   * @param   {String}   type         The type of event.
   * @param   {Function} callback     The callback called when the event occurs.
   * @param   {Object}   context      The context that will be applied to the callback (optional).
   * @returns {Object}   subscription A subscription object which can off the handler using the dispose method.
   */
  uv.on = function on (type, callback, context) {
    var ref = {}
    uv.listeners.push({
      type: type,
      callback: callback,
      context: context || window,
      ref: ref
    })
    return {
      dispose: dispose
    }

    function dispose () {
      for (var i = 0; i < uv.listeners.length; i++) {
        if (uv.listeners[i].ref === ref) {
          uv.listeners.splice(i, 1)
          return
        }
      }
    }
  }

  /**
   * Attaches an event handler to listen to the type of event specified. The handle will only be executed once.
   * @param   {String}   type         The type of event.
   * @param   {Function} callback     The callback called when the event occurs.
   * @param   {Object}   context      The context that will be applied to the callback (optional).
   * @returns {Object}   subscription A subscription object which can off the handler using the dispose method.
   */
  uv.once = function once (type, callback, context) {
    var subscription = uv.on(type, function () {
      callback.apply(context || window, arguments)
      subscription.dispose()
    })
    return subscription
  }

  /**
   * Returns a new array by passing the iterator function over the events array in the given context.
   * @param  {Function} iterator The iterator to call for each event.
   * @param  {Object}   context  Optional. The context in which the iterator is called.
   * @return {Array}    result   A new array of the mapped events.
   */
  uv.map = function map (iterator, context) {
    var result = []
    context = context || window
    forEach(uv.events, function (event, i) {
      result.push(iterator.call(context, event, i))
    })
    return result
  }

  /**
   * Attaches uv to the window.
   */
  window.uv = uv

  function forEach (list, iterator) {
    for (var i = 0; i < list.length; i++) {
      iterator(list[i], i)
    }
  }

  /**
   * Returns a shallow clone of the input
   * object.
   * @param  {Object} input
   * @return {Object} output
   */
  function clone (input) {
    var output = {}
    for (var key in input) {
      if (input.hasOwnProperty(key)) {
        output[key] = input[key]
      }
    }
    return output
  }
}())

module.exports = uv

});

define('@qubit---uv-api@2.0.1', ['@qubit---uv-api@2.0.1/uv-api'], function (main) { return main; });

define('@qubit---uv-maps@1.12.0/kn8/index',['require','exports','module'],function (require, exports, module) {module.exports = function () {
  window.uv.emit('View')
}

});


(function(c){var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
('.deliver-component {\n  box-sizing: border-box;\n  clear: both;\n}\n\n.deliver-component.deliver-is-inTransit {\n  background: repeating-linear-gradient(\n    45deg,\n    rgba(0, 0, 0, 0.1),\n    rgba(0, 0, 0, 0.1) 5px,\n    rgba(0, 0, 0, 0) 5px,\n    rgba(0, 0, 0, 0) 10px\n  );\n  opacity: 0.3;\n}\n\n.deliver-dom-is-translucent {\n  opacity: .4;\n}\n\n.deliver-dom-is-editor .deliver-allowChildren:empty {\n  border: 1px dashed #bbb;\n  box-shadow: 0 0 7px rgba(0, 0, 0, .08) inset;\n  position: relative;\n}\n\n.deliver-dom-is-editor .deliver-allowChildren:empty:before {\n  box-sizing: border-box;\n  content: \"Drag components here\";\n  color: rgba(0, 0, 0, 0.6);\n  display: block;\n  font-family: Helvetica, Arial, sans-serif !important;\n  position: absolute;\n  left: 0;\n  top: 50%;\n  text-align: center;\n  transform: translateY(-50%);\n  -webkit-transform: translateY(-50%);\n  -ms-transform: translateY(-50%);\n  width: 100%;\n}\n\n.deliver-dom-is-editor .deliver-allowChildren--noText:empty:before {\n  content: none!important;\n}\n.deliver-component-Textbox.deliver-is-selected {\n  outline: none;\n}\n\n.deliver-component-Textbox-link {\n  background: transparent !important;\n  display: inline !important;\n}\n.deliver-is-editor .deliver-component-Block:empty {\n  padding: 10px;\n  min-height: 40px;\n}\n.deliver-component-Mimic:before {\n  content: \' \';\n  display: table;\n}\n\n.deliver-component-Mimic:after {\n  content: \' \';\n  display: table;\n}.deliver-component-ToggleSlider {\n  background: white;\n  box-shadow: 0 2px 2px rgba(0,0,0,0.2);\n\n  /* the default position */\n  position: fixed;\n  bottom: 100px;\n\n  /* this is random and will be improved in the future when we\n  come up with a z-index system */\n  z-index: 9000;\n}\n\n.deliver-component-ToggleSlider-container {\n  height: 100%;\n\n  /* this is primarily added so that the styling of\n  .deliver-allowChildren:empty looks correct */\n  box-sizing: border-box;\n\n  /* this is to put the content below the toggle */\n  z-index: 10;\n  position: relative;\n}\n\n.deliver-component-ToggleSlider-toggle {\n  height: 100%;\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  /* this is to put the toggle above the content */\n  z-index: 20;\n  /* this is to make sure it\'s clickable in IE8 */\n  background: url(\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\");\n}\n\n.deliver-is-placing .deliver-component-ToggleSlider-toggle {\n  /* hide it when in placing mode so that the toggle doesn\'t hijack\n  the mouse hovers from the container element */\n  display: none;\n}.deliver-component-CloseButton {\n  position: absolute;\n  display: block;\n  text-decoration: none;\n  cursor: pointer;\n  user-select: none;\n  text-align: center;\n  outline: none !important;\n}\n\n.deliver-component-CloseButton--transparent {\n  /* Fix for IE so that it is clickable */\n  background: url(\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\") !important;\n}\n\n.deliver-dom-is-editor .deliver-component-CloseButton.deliver-component-CloseButton--selected {\n  outline: 1px solid #5bacff !important;\n}\n\n.deliver-dom-is-editor .deliver-component-CloseButton--transparent {\n  outline: 1px dashed #bbb !important;\n}\n\n.deliver-component-CloseButton-times {\n  display: block;\n}\n\n.deliver-component-CloseButton > .ui-resizable-handle {\n  position: absolute;\n  font-size: 0.1px;\n  display: block;\n  box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);\n  background: white;\n  background: rgba(255, 255, 255, 0.9);\n  height: 6px;\n  width: 6px;\n}\n\n.deliver-component-CloseButton > .ui-resizable-n { cursor: ns-resize; }\n.deliver-component-CloseButton > .ui-resizable-s { cursor: ns-resize; }\n.deliver-component-CloseButton > .ui-resizable-e { cursor: ew-resize; }\n.deliver-component-CloseButton > .ui-resizable-w { cursor: ew-resize; }\n.deliver-component-CloseButton > .ui-resizable-se { cursor: nwse-resize; }\n.deliver-component-CloseButton > .ui-resizable-sw { cursor: nesw-resize; }\n.deliver-component-CloseButton > .ui-resizable-nw { cursor: nwse-resize; }\n.deliver-component-CloseButton > .ui-resizable-ne { cursor: nesw-resize; }\n.deliver-component-CloseButton > .ui-resizable-n { left: 50%; top: -4px; margin-left: -4px; }\n.deliver-component-CloseButton > .ui-resizable-s { left: 50%; margin-left: -4px; bottom: -4px;}\n.deliver-component-CloseButton > .ui-resizable-e { right: -4px; top: 50%; margin-top: -4px; }\n.deliver-component-CloseButton > .ui-resizable-w { left: -4px; top: 50%; margin-top: -4px; }\n.deliver-component-CloseButton > .ui-resizable-se { right: -4px; bottom: -4px; }\n.deliver-component-CloseButton > .ui-resizable-sw { left: -4px; bottom: -4px; }\n.deliver-component-CloseButton > .ui-resizable-nw { left: -4px; top: -4px; }\n.deliver-component-CloseButton > .ui-resizable-ne { right: -4px; top: -4px; }\n.deliver-component-Image-region {\n  display: block;\n  position: absolute;\n  background: url(\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\") !important;\n  padding: 0 !important;\n  margin: 0 !important;\n  border: 0 !important;\n}\n\n.deliver-component-Image-region:focus {\n  outline: none;\n}\n.deliver-component-Image {\n  /*\n    This is to make the container be of the same size as the image.\n    One caveat currently is that this doesn\'t work in IE8, the images\n    get stretched out.\n    But if this is changed to display: inline-block; then the image can\'t\n    be aligned using margin-left, margin-right auto\n   */\n  display: table;\n  /*\n    This is to make sure that regions only stay within the image.\n  */\n  position: relative !important;\n}\n\n.deliver-component-Image-img {\n  display: block;\n  /*\n    Important for iOS Safari\n    If the site has img { max-height: 100% }, our image is rendered\n    with 0 height. This counters that and renders the image at it\'s\n    natural height as intended.\n   */\n  max-height: none !important;\n}\n\n.deliver-component-Image-link {\n  background: transparent !important;\n  padding: 0 !important;\n  margin: 0 !important;\n  border: 0 !important;\n}\n.deliver-component-QubitRec-list {\n  width: 100%;\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n  clear: both;\n}\n\n.deliver-component-QubitRec-item {\n  display: inline-block;\n  vertical-align: top;\n  margin: 0;\n  padding: 0 5px;\n  float: left;\n  box-sizing: border-box;\n}\n\n.deliver-component-QubitRec-itemImage {\n  border: 0;\n  width: 100%;\n  height: auto;\n}\n\n.deliver-component-QubitRec-itemLink {\n  display: block;\n  width: 100%;\n}\n\n.deliver-component-QubitRec-itemPrice,\n.deliver-component-QubitRec-itemTitle {\n  display: block;\n  padding: 2px;\n  text-align: center;\n}\n\n.deliver-component-QubitRec-itemPrice.deliver-is-disabled {\n  text-decoration: line-through;\n}');

require(["main"]);


}());